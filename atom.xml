<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Luweir&#39;Blog</title>
  
  <subtitle>一旦你知道失败是什么感觉，就会决心追逐成功！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://luweir.github.io/"/>
  <updated>2020-11-07T15:53:29.927Z</updated>
  <id>http://luweir.github.io/</id>
  
  <author>
    <name>Mr.L</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>计算机网络常见面试题总结</title>
    <link href="http://luweir.github.io/2020/11/07/%E8%AE%A1%E7%BD%91%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    <id>http://luweir.github.io/2020/11/07/%E8%AE%A1%E7%BD%91%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/</id>
    <published>2020-11-07T15:20:00.000Z</published>
    <updated>2020-11-07T15:53:29.927Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1、OSI-，-TCP-IP-，五层协议的体系结构"><a href="#1、OSI-，-TCP-IP-，五层协议的体系结构" class="headerlink" title="1、OSI ， TCP/IP ，五层协议的体系结构"></a>1、OSI ， TCP/IP ，五层协议的体系结构</h2><p>OSI分层（7层） ：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层。 </p><p>TCP/IP分层（4层） ：网络接口层、网际层、运输层、应用层。 </p><p>五层协议（5层） ：物理层、数据链路层、网络层、运输层、应用层。 </p><p>每一层的作用如下 ： </p><p><strong>物理层</strong>：激活、维持、关闭通信端点之间的机械特性、电气特性、功能特性以及过程特性。该层为上层协议提供了一个传输数据的物理媒体。</p><p><strong>数据链路层</strong> ：数据链路层在不可靠的物理介质上提供可靠的传输。该层的作用包括：物理地址寻址、数据的成帧、流量控制、数据的检错、重发等。 </p><p><strong>网络层</strong> ：网络层负责对子网间的数据包进行路由选择。此外，网络层还可以实现拥塞控制、网际互连等功能。 </p><p><strong>传输层</strong> ：第一个端到端，即主机到主机的层次。传输层负责将上层数据分段并提供端到端的、可靠的或不可靠的传输。此外，传输层还要处理端到端的差错控制和流量控制问题。 </p><p><strong>会话层</strong> ：会话层管理主机之间的会话进程，即负责建立、管理、终止进程之间的会话。会话层还利用在数据中插入校验点来实现数据的同步。 </p><p><strong>表示层</strong> ：表示层对上层数据或信息进行变换以保证一个主机应用层信息可以被另一个主机的应用程序理解。表示层的数据转换包括数据的加密、压缩、格式转换等。 </p><p><strong>应用层</strong> ：为操作系统或网络应用程序提供访问网络服务的接口。 <a id="more"></a></p><h2 id="2、IP-地址的分类"><a href="#2、IP-地址的分类" class="headerlink" title="2、IP 地址的分类"></a>2、IP 地址的分类</h2><p><strong>A类地址</strong>：以0开头，第一个字节范围：0~127；</p><p><strong>B类地址</strong>：以10开头，第一个字节范围：128~191；</p><p><strong>C类地址</strong>：以110开头，第一个字节范围：192~223；</p><p><strong>D类地址</strong>：以1110开头，第一个字节范围：224~239；</p><h2 id="3、ARP-协议的工作原理"><a href="#3、ARP-协议的工作原理" class="headerlink" title="3、ARP 协议的工作原理"></a>3、ARP 协议的工作原理</h2><p>​        首先，每台主机都会在自己的ARP缓冲区中建立一个 ARP列表，以表示IP地址和MAC地址的对应关系。当源主机需要将一个数据包要发送到目的主机时，会首先检查自己 ARP列表中是否存在该 IP地址对应的MAC地址，如果有，就直接将数据包发送到这个MAC地址；如果没有，就向本地网段发起一个ARP请求的广播包，查询此目的主机对应的MAC地址。此ARP请求数据包里包括源主机的IP地址、硬件地址、以及目的主机的IP地址。网络中所有的主机收到这个ARP请求后，会检查数据包中的目的IP是否和自己的IP地址一致。如果不相同就忽略此数据包；如果相同，该主机首先将发送端的MAC地址和IP地址添加到自己的ARP列表中，如果ARP表中已经存在该IP的信息，则将其覆盖，然后给源主机发送一个 ARP响应数据包，告诉对方自己是它需要查找的MAC地址；源主机收到这个ARP响应数据包后，将得到的目的主机的IP地址和MAC地址添加到自己的ARP列表中，并利用此信息开始数据的传输。如果源主机一直没有收到ARP响应数据包，表示ARP查询失败。</p><h2 id="4、路由设备与相关层"><a href="#4、路由设备与相关层" class="headerlink" title="4、路由设备与相关层"></a>4、路由设备与相关层</h2><p>物理层 ：中继器（Repeater，也叫放大器），集线器。 </p><p>数据链路层 ：网桥，交换机。 </p><p>网络层 ：路由器。 </p><p>网关 ：网络层以上的设备。 </p><h2 id="5、常见的路由选择协议，以及它们的区别"><a href="#5、常见的路由选择协议，以及它们的区别" class="headerlink" title="5、常见的路由选择协议，以及它们的区别"></a>5、常见的路由选择协议，以及它们的区别</h2><p>常见的路由选择协议有：RIP协议、OSPF协议。</p><p>RIP协议 ：底层是贝尔曼福特算法，它选择路由的度量标准（metric)是跳数，最大跳数是15跳，如果大于15跳，它就会丢弃数据包。 </p><p>OSPF协议 ：底层是迪杰斯特拉算法，是链路状态路由选择协议，它选择路由的度量标准是带宽，延迟。 </p><h2 id="6、TCP-与-UDP-的区别"><a href="#6、TCP-与-UDP-的区别" class="headerlink" title="6、TCP 与 UDP 的区别"></a>6、TCP 与 UDP 的区别</h2><p>UDP是面向无连接的，不可靠的数据报服务；</p><p>TCP是面向连接的，可靠的字节流服务。</p><h2 id="7、TCP-的可靠性如何保证？"><a href="#7、TCP-的可靠性如何保证？" class="headerlink" title="7、TCP 的可靠性如何保证？"></a>7、TCP 的可靠性如何保证？</h2><p>TCP的可靠性是通过顺序编号和确认（ACK）来实现的。</p><h2 id="8、TCP-三次握手和四次挥手的全过程"><a href="#8、TCP-三次握手和四次挥手的全过程" class="headerlink" title="8、TCP 三次握手和四次挥手的全过程"></a>8、TCP 三次握手和四次挥手的全过程</h2><p><img src="https://raw.githubusercontent.com/luweir/picpicgo/main/img/20201107231632.jpg" alt="img"></p><h2 id="9、-在浏览器中输入-www-baidu-com-后执行的全部过程"><a href="#9、-在浏览器中输入-www-baidu-com-后执行的全部过程" class="headerlink" title="9、 在浏览器中输入** www.baidu.com **后执行的全部过程"></a>9、 在浏览器中输入** <code>www.baidu.com</code> **后执行的全部过程</h2><p>现在假设如果我们在客户端（客户端）浏览器中输入<code>http://www.baidu.com</code>，而<code>baidu.com</code>为要访问的服务器（服务器），下面详细分析客户端为了访问服务器而执行的一系列关于协议的操作：</p><p>1）客户端浏览器通过DNS解析到<code>www.baidu.com</code>的IP地址220.181.27.48，通过这个IP地址找到客户端到服务器的路径。客户端浏览器发起一个HTTP会话到220.161.27.48，然后通过TCP进行封装数据包，输入到网络层。</p><p>2）在客户端的传输层，把HTTP会话请求分成报文段，添加源和目的端口，如服务器使用80端口监听客户端的请求，客户端由系统随机选择一个端口如5000，与服务器进行交换，服务器把相应的请求返回给客户端的5000端口。然后使用IP层的IP地址查找目的端。</p><p>3）客户端的网络层不用关系应用层或者传输层的东西，主要做的是通过查找路由表确定如何到达服务器，期间可能经过多个路由器，这些都是由路由器来完成的工作，我不作过多的描述，无非就是通过查找路由表决定通过那个路径到达服务器。</p><p>4）客户端的链路层，包通过链路层发送到路由器，通过邻居协议查找给定IP地址的MAC地址，然后发送ARP请求查找目的地址，如果得到回应后就可以使用ARP的请求应答交换的IP数据包现在就可以传输了，然后发送IP数据包到达服务器的地址。</p><h2 id="10、-HTTP-协议包括哪些请求？"><a href="#10、-HTTP-协议包括哪些请求？" class="headerlink" title="10、 HTTP 协议包括哪些请求？"></a>10、 HTTP 协议包括哪些请求？</h2><p>GET：请求读取由URL所标志的信息。</p><p>POST：给服务器添加信息（如注释）。</p><p>PUT：在给定的URL下存储一个文档。</p><p>DELETE：删除给定的URL所标志的资源。</p><h2 id="11、HTTP-中，-POST-与-GET-的区别"><a href="#11、HTTP-中，-POST-与-GET-的区别" class="headerlink" title="11、HTTP 中， POST 与 GET 的区别"></a>11、HTTP 中， POST 与 GET 的区别</h2><p>(1)Get是从服务器上获取数据，Post是向服务器传送数据。</p><p>(2)Get是把参数数据队列加到提交表单的Action属性所指向的URL中，值和表单内各个字段一一对应，在URL中科院看到。</p><p>(3)Get传送的数据量小，不能大于2KB；post传送的数据量较大，一般被默认为不受限制。</p><p>(4)根据HTTP规范，GET用于信息获取，而且应该是安全的和幂等的。</p><p>I.所谓 安全的 意味着该操作用于获取信息而非修改信息。换句话说，GET 请求一般不应产生副作用。就是说，它仅仅是获取资源信息，就像数据库查询一样，不会修改，增加数据，不会影响资源的状态。 </p><p>II. 幂等 的意味着对同一URL的多个请求应该返回同样的结果。 </p><h2 id="12、TCP-IP-中，每一层对应的协议"><a href="#12、TCP-IP-中，每一层对应的协议" class="headerlink" title="12、TCP/IP 中，每一层对应的协议"></a>12、TCP/IP 中，每一层对应的协议</h2><p>网络层 ：IP协议、ICMP协议、ARP协议、RARP协议。 </p><p>传输层 ：UDP协议、TCP协议。 </p><p>应用层 ：FTP（文件传送协议）、Telenet（远程登录协议）、DNS（域名解析协议）、SMTP（邮件传送协议），POP3协议（邮局协议），HTTP协议。 </p><h2 id="13、TCP-对应的协议和-UDP-对应的协议"><a href="#13、TCP-对应的协议和-UDP-对应的协议" class="headerlink" title="13、TCP 对应的协议和 UDP 对应的协议"></a>13、TCP 对应的协议和 UDP 对应的协议</h2><p>TCP对应的协议：</p><p>（1） FTP ：定义了文件传输协议，使用21端口。常说某某计算机开了FTP服务便是启动了文件传输服务。下载文件，上传主页，都要用到FTP服务。 </p><p>（2） Telnet ：它是一种用于远程登陆的端口，用户可以以自己的身份远程连接到计算机上，通过这种端口可以提供一种基于DOS模式下的通信服务。如以前的BBS是-纯字符界面的，支持BBS的服务器将23端口打开，对外提供服务。 </p><p>（3） SMTP ：定义了简单邮件传送协议，现在很多邮件服务器都用的是这个协议，用于发送邮件。如常见的免费邮件服务中用的就是这个邮件服务端口，所以在电子邮件设置-中常看到有这么SMTP端口设置这个栏，服务器开放的是25号端口。 </p><p>（4） POP3 ：它是和SMTP对应，POP3用于接收邮件。通常情况下，POP3协议所用的是110端口。也是说，只要你有相应的使用POP3协议的程序（例如Fo-xmail或Outlook），就可以不以Web方式登陆进邮箱界面，直接用邮件程序就可以收到邮件（如是163邮箱就没有必要先进入网易网站，再进入自己的邮-箱来收信）。 </p><p>（5）HTTP协议： 是从 Web 服务器传输超文本到本地浏览器的传送协议。</p><p>UDP对应的协议：</p><p>（1） DNS ：用于域名解析服务，将域名地址转换为IP地址。DNS用的是53号端口。 </p><p>（2） SNMP ：简单网络管理协议，使用161号端口，是用来管理网络设备的。由于网络设备很多，无连接的服务就体现出其优势。 </p><p>（3） TFTP (Trival File Transfer Protocal)，简单文件传输协议，该协议在熟知端口69上使用UDP服务。 </p><h2 id="14、特殊的IP地址"><a href="#14、特殊的IP地址" class="headerlink" title="14、特殊的IP地址"></a>14、特殊的IP地址</h2><p>（1）网络地址</p><p>IP地址由网络号（包括子网号）和主机号组成，网络地址的主机号为全0，网络地址代表着整个网络。</p><p>（2）广播地址</p><p>广播地址通常称为直接广播地址，是为了区分受限广播地址。</p><p>广播地址与网络地址的主机号正好相反，广播地址中，主机号为全1。当向某个网络的广播地址发送消息时，该网络内的所有主机都能收到该广播消息。</p><p>（3）组播地址</p><p>D类地址就是组播地址。</p><p>先回忆下A，B，C，D类地址吧</p><p>A类地址以00开头，第一个字节作为网络号，地址范围为：0.0.0.0~127.255.255.255；</p><p>B类地址以10开头，前两个字节作为网络号，地址范围是：128.0.0.0~191.255.255.255;</p><p>C类地址以110开头，前三个字节作为网络号，地址范围是：192.0.0.0~223.255.255.255。</p><p>D类地址以1110开头，地址范围是224.0.0.0~239.255.255.255，D类地址作为组播地址（一对多的通信）；</p><p>E类地址以1111开头，地址范围是240.0.0.0~255.255.255.255，E类地址为保留地址，供以后使用。</p><p>Notice：只有A,B,C有网络号和主机号之分，D类地址和E类地址没有划分网络号和主机号。</p><p>（4）255.255.255.255</p><p>该IP地址指的是受限的广播地址。受限广播地址与一般广播地址（直接广播地址）的区别在于，受限广播地址之只能用于本地网络，路由器不会转发以受限广播地址为目的地址的分组；一般广播地址既可在本地广播，也可跨网段广播。例如：主机192.168.1.1/30上的直接广播数据包后，另外一个网段192.168.1.5/30也能收到该数据报；若发送受限广播数据报，则不能收到。</p><p>Notice：一般的广播地址（直接广播地址）能够通过某些路由器（当然不是所有的路由器），而受限的广播地址不能通过路由器。</p><p>（5）0.0.0.0</p><p>常用于寻找自己的IP地址，例如在我们的 RARP，BOOTP（DHCP协议的前身）和DHCP协议中，若某个未知IP地址的无盘机想要知道自己的IP地址，它就以255.255.255.255为目的地址，向本地范围（具体而言是被各个路由器屏蔽的范围内）的服务器发送IP请求分组。</p><p>（6）回环地址</p><p>127.0.0.0/8 被用作回环地址，回环地址表示本机的地址，常用于对本机的测试，用的最多的是127.0.0.1。</p><p>（7）A、B、C类私有地址</p><p>私有地址(private address)也叫专用地址，它们不会在全球使用，只具有本地意义。</p><p>A类私有地址：10.0.0.0/8，范围是：10.0.0.0~10.255.255.255</p><p>B类私有地址：172.16.0.0/12，范围是：172.16.0.0~172.31.255.255</p><p>C类私有地址：192.168.0.0/16，范围是：192.168.0.0~192.168.255.255</p><h2 id="15、-NAT-协议、-DHCP-协议、-DNS-协议的作用"><a href="#15、-NAT-协议、-DHCP-协议、-DNS-协议的作用" class="headerlink" title="15、 NAT 协议、 DHCP 协议、 DNS 协议的作用"></a>15、 NAT 协议、 DHCP 协议、 DNS 协议的作用</h2><p>NAT协议 ：网络地址转换(NAT,Network Address Translation)属接入广域网(WAN)技术， </p><p>是一种将私有（保留）地址转化为合法IP地址的转换技术，它被广泛应用于各种类型Internet接入方式和各种类型的网络中。原因很简单，NAT不仅完美地解决了lP地址不足的问题，而且还能够有效地避免来自网络外部的攻击，隐藏并保护网络内部的计算机。</p><p>DHCP协议 ：动态主机设置协议（Dynamic Host Configuration Protocol, DHCP） </p><p>是一个局域网的网络协议，使用UDP协议工作，主要有两个用途：给内部网络或网络服务供应商自动分配IP地址，给用户或者内部网络管理员作为对所有计算机作中央管理的手段。</p><p>DNS协议 ：DNS 是域名系统 (Domain Name System) 的缩写，是因特网的一项核心服务，它作为可以将域名和IP地址相互映射的一个分布式数据库，能够使人更方便的访问互联网，而不用去记住能够被机器直接读取的IP数串。</p><h2 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h2><p><a href="https://mp.weixin.qq.com/s/qO8ZismodyFi4Xv70akh_g" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/qO8ZismodyFi4Xv70akh_g</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1、OSI-，-TCP-IP-，五层协议的体系结构&quot;&gt;&lt;a href=&quot;#1、OSI-，-TCP-IP-，五层协议的体系结构&quot; class=&quot;headerlink&quot; title=&quot;1、OSI ， TCP/IP ，五层协议的体系结构&quot;&gt;&lt;/a&gt;1、OSI ， TCP/IP ，五层协议的体系结构&lt;/h2&gt;&lt;p&gt;OSI分层（7层） ：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层。 &lt;/p&gt;
&lt;p&gt;TCP/IP分层（4层） ：网络接口层、网际层、运输层、应用层。 &lt;/p&gt;
&lt;p&gt;五层协议（5层） ：物理层、数据链路层、网络层、运输层、应用层。 &lt;/p&gt;
&lt;p&gt;每一层的作用如下 ： &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;物理层&lt;/strong&gt;：激活、维持、关闭通信端点之间的机械特性、电气特性、功能特性以及过程特性。该层为上层协议提供了一个传输数据的物理媒体。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;数据链路层&lt;/strong&gt; ：数据链路层在不可靠的物理介质上提供可靠的传输。该层的作用包括：物理地址寻址、数据的成帧、流量控制、数据的检错、重发等。 &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;网络层&lt;/strong&gt; ：网络层负责对子网间的数据包进行路由选择。此外，网络层还可以实现拥塞控制、网际互连等功能。 &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;传输层&lt;/strong&gt; ：第一个端到端，即主机到主机的层次。传输层负责将上层数据分段并提供端到端的、可靠的或不可靠的传输。此外，传输层还要处理端到端的差错控制和流量控制问题。 &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;会话层&lt;/strong&gt; ：会话层管理主机之间的会话进程，即负责建立、管理、终止进程之间的会话。会话层还利用在数据中插入校验点来实现数据的同步。 &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;表示层&lt;/strong&gt; ：表示层对上层数据或信息进行变换以保证一个主机应用层信息可以被另一个主机的应用程序理解。表示层的数据转换包括数据的加密、压缩、格式转换等。 &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;应用层&lt;/strong&gt; ：为操作系统或网络应用程序提供访问网络服务的接口。
    
    </summary>
    
    
      <category term="面试" scheme="http://Luweir.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="CN" scheme="http://Luweir.github.io/tags/CN/"/>
    
  </entry>
  
  <entry>
    <title>Windows命令行脚本学习</title>
    <link href="http://luweir.github.io/2020/11/07/Windows%E5%91%BD%E4%BB%A4%E8%A1%8C%E8%84%9A%E6%9C%AC%E5%AD%A6%E4%B9%A0/"/>
    <id>http://luweir.github.io/2020/11/07/Windows%E5%91%BD%E4%BB%A4%E8%A1%8C%E8%84%9A%E6%9C%AC%E5%AD%A6%E4%B9%A0/</id>
    <published>2020-11-07T14:17:00.000Z</published>
    <updated>2020-11-07T14:52:56.589Z</updated>
    
    <content type="html"><![CDATA[<h2 id="可以执行cmd命令的-bat脚本"><a href="#可以执行cmd命令的-bat脚本" class="headerlink" title="可以执行cmd命令的.bat脚本"></a>可以执行cmd命令的.bat脚本</h2><p>1、可以先新建一个记事本，然后将后缀名改为“.bat”，例如“test.bat”；<br>2、然后编辑内容；</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@<span class="built_in">echo</span> off</span><br><span class="line"><span class="built_in">start</span> <span class="built_in">cmd</span> /k "<span class="built_in">cd</span>/d D:\AA\service\redis &amp;&amp;redis-server.exe redis.windows.conf &amp;&amp;<span class="built_in">taskkill</span> /f /t /im <span class="built_in">cmd</span>.exe"</span><br><span class="line"></span><br><span class="line"><span class="built_in">start</span> <span class="built_in">cmd</span> /k "<span class="built_in">cd</span>/d D:\AA\service\zookeeper-<span class="number">3</span>.<span class="number">4</span>.<span class="number">8</span>\bin &amp;&amp;zkServer.<span class="built_in">cmd</span> &amp;&amp;<span class="built_in">taskkill</span> /f /t /im <span class="built_in">cmd</span>.exe"</span><br><span class="line"></span><br><span class="line"><span class="built_in">start</span> <span class="built_in">cmd</span> /c "<span class="built_in">cd</span>/d D:\tmp\tomcat8\bin &amp;&amp;startup.bat"</span><br><span class="line"></span><br><span class="line"><span class="built_in">start</span> <span class="built_in">cmd</span> /k "makecab F:\Users\Administrator\Desktop\SelectClass.xlsx F:\Users\Administrator\Desktop\SelectClass.zip"</span><br></pre></td></tr></table></figure><p>3、保存此文件，然后双击此文件即可；</p><p><strong>解释：</strong></p><p><code>start 是用来启动一个应用的，使用方式为：start 程序名</code><br><code>cmd /k 表示cmd后面的命令执行完后不关闭窗口</code><br><code>cmd /c 表示执行完cmd命令后关闭命令窗口</code></p><p>关于<code>@echo off</code>命令：</p><blockquote><p><code>echo off</code>关闭其他命令的显示（但是不包括自身这条命令）<br><code>@echo off</code>关闭所有命令的显示（@关闭其后命令的显示）</p></blockquote><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><h3 id="压缩命令"><a href="#压缩命令" class="headerlink" title="压缩命令"></a>压缩命令</h3><p><code>makecab F:\Users\Administrator\Desktop\SelectClass.xlsx F:\Users\Administrator\Desktop\SelectClass.zip</code></p><p><code>makecab 源路径\文件名 目的路径\文件名</code></p>]]></content>
    
    <summary type="html">
    
      用Windows运行固定的几个程序，或者操作时，觉得繁琐，学点命令行脚本点一点自动运行还是挺香的；
    
    </summary>
    
    
      <category term="编程" scheme="http://Luweir.github.io/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Windows" scheme="http://Luweir.github.io/tags/Windows/"/>
    
      <category term="脚本" scheme="http://Luweir.github.io/tags/%E8%84%9A%E6%9C%AC/"/>
    
  </entry>
  
  <entry>
    <title>picgo+github+typora搭建免费图床</title>
    <link href="http://luweir.github.io/2020/11/06/picgo+github+typora/"/>
    <id>http://luweir.github.io/2020/11/06/picgo+github+typora/</id>
    <published>2020-11-06T15:10:00.000Z</published>
    <updated>2020-11-06T15:52:41.147Z</updated>
    
    <content type="html"><![CDATA[<p>前面的步骤依旧没啥变化，Github创建仓库、获取token等等；</p><h1 id="新版本变化"><a href="#新版本变化" class="headerlink" title="新版本变化"></a>新版本变化</h1><p>那么直接从PicGo中Github设置说起：</p><p><img src="https://raw.githubusercontent.com/Luweir/picpicgo/main/img/20201106232010.png" alt=""></p><p>还是加上自定义域名吧，建议：<code>https://raw.githubusercontent.com/用户名/仓库名</code>；</p><p>然后就可以直接上传了，建议设置改为以下：</p><p><img src="https://raw.githubusercontent.com/Luweir/picpicgo/main/img/20201106232352.png" alt=""></p><p>还有就是快捷键也可以更改下，我改成的<code>ctrl+u</code>；</p><h1 id="提高Github图片加载速度"><a href="#提高Github图片加载速度" class="headerlink" title="提高Github图片加载速度"></a>提高Github图片加载速度</h1><p>设置完成后，上传没问题了，只是这个图片在github中经常加载不出来，自然复制链接到 Typora 也是经常加载不出，很蛋疼，参考知乎一篇文章：<a href="https://zhuanlan.zhihu.com/p/139219691" target="_blank" rel="noopener">GitHub 图片加载不出来怎么办</a></p><p>更改 host 文件（之前也改过，不知道为啥没用了），在最后面加上这些，亲测有用：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># GitHub Start </span><br><span class="line"><span class="number">192.30</span><span class="number">.253</span><span class="number">.112</span> Build software better, together </span><br><span class="line"><span class="number">192.30</span><span class="number">.253</span><span class="number">.119</span> gist.github.com</span><br><span class="line"><span class="number">151.101</span><span class="number">.184</span><span class="number">.133</span> assets-cdn.github.com</span><br><span class="line"><span class="number">151.101</span><span class="number">.184</span><span class="number">.133</span> raw.githubusercontent.com</span><br><span class="line"><span class="number">151.101</span><span class="number">.184</span><span class="number">.133</span> gist.githubusercontent.com</span><br><span class="line"><span class="number">151.101</span><span class="number">.184</span><span class="number">.133</span> cloud.githubusercontent.com</span><br><span class="line"><span class="number">151.101</span><span class="number">.184</span><span class="number">.133</span> camo.githubusercontent.com</span><br><span class="line"><span class="number">151.101</span><span class="number">.184</span><span class="number">.133</span> avatars0.githubusercontent.com</span><br><span class="line"><span class="number">151.101</span><span class="number">.184</span><span class="number">.133</span> avatars1.githubusercontent.com</span><br><span class="line"><span class="number">151.101</span><span class="number">.184</span><span class="number">.133</span> avatars2.githubusercontent.com</span><br><span class="line"><span class="number">151.101</span><span class="number">.184</span><span class="number">.133</span> avatars3.githubusercontent.com</span><br><span class="line"><span class="number">151.101</span><span class="number">.184</span><span class="number">.133</span> Build software better, together</span><br><span class="line"><span class="number">151.101</span><span class="number">.184</span><span class="number">.133</span> avatars5.githubusercontent.com</span><br><span class="line"><span class="number">151.101</span><span class="number">.184</span><span class="number">.133</span> avatars6.githubusercontent.com</span><br><span class="line"><span class="number">151.101</span><span class="number">.184</span><span class="number">.133</span> avatars7.githubusercontent.com</span><br><span class="line"><span class="number">151.101</span><span class="number">.184</span><span class="number">.133</span> Build software better, together</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Luweir/picpicgo/main/img/20201106233404.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      之前一直用的阿里云搭建图床，后来觉得这始终不是个办法，随着图片上传量的增大，40G的容量明显不够用（虽然采用了不到1G），而且续费、到期之后图片无法显示的问题也一直存在；所以，索引今天就改成github的免费图床，方便管理，也没有容量限制，只是速度慢了点，哈哈哈；
    
    </summary>
    
    
      <category term="环境配置" scheme="http://Luweir.github.io/categories/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
    
    
      <category term="Github" scheme="http://Luweir.github.io/tags/Github/"/>
    
      <category term="PicGo" scheme="http://Luweir.github.io/tags/PicGo/"/>
    
      <category term="Typora" scheme="http://Luweir.github.io/tags/Typora/"/>
    
  </entry>
  
  <entry>
    <title>帮朋友看电脑有感</title>
    <link href="http://luweir.github.io/2020/08/30/%E5%B8%AE%E6%9C%8B%E5%8F%8B%E7%9C%8B%E7%94%B5%E8%84%91%E6%9C%89%E6%84%9F/"/>
    <id>http://luweir.github.io/2020/08/30/%E5%B8%AE%E6%9C%8B%E5%8F%8B%E7%9C%8B%E7%94%B5%E8%84%91%E6%9C%89%E6%84%9F/</id>
    <published>2020-08-30T14:33:00.000Z</published>
    <updated>2020-11-06T16:11:25.548Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1、处理器"><a href="#1、处理器" class="headerlink" title="1、处理器"></a>1、处理器</h1><p>​        2020年 AMD Yes!  R7 4800H明显优过i7 10730，与10800不相上下；其次，在intel处理器中，i7也不一定比i5厉害，比如i7 4代就不如i5 十代，i7 4000 比如 i7 4200；对于AMD和intel两大厂商，intel常年居龙头位置，靠着先进的技术碾压AMD，但由于其每次进步较小，AMD与它的差距也就越来越小；不过我这神州也才i5 7400，要啥自行车啊；玩lol、吃鸡没压力，ps、pr、pycharm也不在话下，四年也没出过岔子，在我心中，神州确实还算性价比很高、很不错的机子；</p><p>​        下一个电脑暂定试试AMD系列的处理器，体验体验；</p><p><img src="https://raw.githubusercontent.com/Luweir/picpicgo/main/img/20201106230842.png" alt="image-20200830224522367"></p><h1 id="2、集成显卡"><a href="#2、集成显卡" class="headerlink" title="2、集成显卡"></a>2、集成显卡</h1><p>冲2060不如稳1660Ti，性能差别，价格却相差很大；对于<strong>华硕的天选</strong>，同其它配置的2060超出1660Ti达500块钱，感觉还是可以不冲的！</p><p><img src="https://tacotuesdayyy.oss-cn-shenzhen.aliyuncs.com/umg/42d8ea246b600c336215f95b144c510fd8f9a174.jpg" alt="img"></p><p>不过对于我的GTX1050，已经在图上都不标的显卡，我无fuck说，哈哈哈哈 开玩笑的，还是挺满意的，这些高端配置于我而言，感觉很多时候用不上；</p><h1 id="3、硬盘"><a href="#3、硬盘" class="headerlink" title="3、硬盘"></a>3、硬盘</h1><p>512G固态也够了，现在大多也就这配置；再自己加一个1T的硬盘也没问题咯；</p><h1 id="4、色域"><a href="#4、色域" class="headerlink" title="4、色域"></a>4、色域</h1><p>这是今天的重点，第一次了解到色域的概念；大概就是屏幕颜色的饱和度吧；一般有45&lt;60&lt;72三个版本，当然还有更猛的；没有对比就没有伤害，从没觉得我的45色域有个不妥，但贴吧上都说，看见了72色域的，在看45色域的会晕、会吐；下一个笔记本就试试72色域的；</p><h1 id="5、刷新率"><a href="#5、刷新率" class="headerlink" title="5、刷新率"></a>5、刷新率</h1><p>刷新率现在有144Hz的，不过应当不影响，或者看不出啥，我的应该是60Hz；</p>]]></content>
    
    <summary type="html">
    
      帮朋友选电脑时，顺带查资料巩固了自己的一些认识，记录下来；
    
    </summary>
    
    
      <category term="个人" scheme="http://Luweir.github.io/categories/%E4%B8%AA%E4%BA%BA/"/>
    
    
      <category term="Feeling" scheme="http://Luweir.github.io/tags/Feeling/"/>
    
  </entry>
  
  <entry>
    <title>学习前端</title>
    <link href="http://luweir.github.io/2020/08/15/%E5%AD%A6%E4%B9%A0%E5%89%8D%E7%AB%AF/"/>
    <id>http://luweir.github.io/2020/08/15/%E5%AD%A6%E4%B9%A0%E5%89%8D%E7%AB%AF/</id>
    <published>2020-08-15T09:38:00.000Z</published>
    <updated>2020-11-06T16:07:48.093Z</updated>
    
    <content type="html"><![CDATA[<p>​        学习前端的初衷是为了学习、工作之余接一些外包的单子，赚一些钱给我俩花；这肯定不是一个短期的过程，不过我也会努力快速完成他；今天听了40集B站pink老师的前端视频，感觉不仅在学习前端，也在巩固，接触一些有印象但不了解的知识，简直是保姆级教程；</p><p>​        我的设计审美能力肯定不足，但是基本的前端开发要完成、微信小程序的开发要能做到；</p><p>​        回顾这8个月，感觉除了准备复试和考研上岸的喜悦，我的确没有收获什么东西，数学建模比赛的培训我也没多大的动力了，毕竟数学的功底摆在这，然后算法我也不是很会灵活运用，但也不会放弃吧；人工智能的比赛多半凉了，赶上哥们当兵回来，其它三个的积极性也不太高；</p><p>​        现在对自己的要求就是好好务实基础、切勿动了赚快钱的念头，尤其是做小时工、廉价地消耗自己是不值得的；好好学习前端知识、巩固后端、务实408基础是我的首要目标；</p><p><img src="https://tacotuesdayyy.oss-cn-shenzhen.aliyuncs.com/umg/timg" alt="img"></p>]]></content>
    
    <summary type="html">
    
      今天开始学习前端知识，涉及到微信小程序开发以及一写外包，我想看能不能通过前端接单赚些钱，主要学习HTML5+CSS+JavaScript等知识；
    
    </summary>
    
    
      <category term="前端" scheme="http://Luweir.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="HTML" scheme="http://Luweir.github.io/tags/HTML/"/>
    
      <category term="CSS" scheme="http://Luweir.github.io/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>Idea永久破解</title>
    <link href="http://luweir.github.io/2020/08/15/Idea%E6%B0%B8%E4%B9%85%E7%A0%B4%E8%A7%A3/"/>
    <id>http://luweir.github.io/2020/08/15/Idea%E6%B0%B8%E4%B9%85%E7%A0%B4%E8%A7%A3/</id>
    <published>2020-08-14T16:58:13.910Z</published>
    <updated>2020-11-06T16:06:54.767Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1、下载安装IntelliJ-IDEA"><a href="#1、下载安装IntelliJ-IDEA" class="headerlink" title="1、下载安装IntelliJ IDEA"></a>1、下载安装IntelliJ IDEA</h1><h1 id="2、下载破解压缩包"><a href="#2、下载破解压缩包" class="headerlink" title="2、下载破解压缩包"></a>2、下载破解压缩包</h1><p>链接: <a href="https://pan.baidu.com/s/1s6tiktsNDAOSxvb9WCPH_w" target="_blank" rel="noopener">https://pan.baidu.com/s/1s6tiktsNDAOSxvb9WCPH_w</a> 提取码: 2iyt</p><p>解压后将 lib 文件夹中的 jetbrains-agent.jar 复制在IDEA的安装目录中的lib目录下；</p><p><img src="https://tacotuesdayyy.oss-cn-shenzhen.aliyuncs.com/umg/image-20200815004555134.png" alt="image-20200815004555134"></p><h1 id="3、破解"><a href="#3、破解" class="headerlink" title="3、破解"></a>3、破解</h1><p>help中打开此项：</p><p><img src="https://tacotuesdayyy.oss-cn-shenzhen.aliyuncs.com/umg/image-20200815005444698.png" alt="image-20200815005444698"></p><p><img src="https://tacotuesdayyy.oss-cn-shenzhen.aliyuncs.com/umg/image-20200815005345408.png" alt="image-20200815005345408"></p><p>输入以下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-javaagent:你的目录\jetbrains-agent.jar</span><br></pre></td></tr></table></figure><p>help中打开此项进行注册：</p><p><img src="https://tacotuesdayyy.oss-cn-shenzhen.aliyuncs.com/umg/image-20200815005557494.png" alt="image-20200815005557494"></p><p><img src="https://tacotuesdayyy.oss-cn-shenzhen.aliyuncs.com/umg/image-20200815005707072.png" alt="image-20200815005707072"></p><p>输入以下激活码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3AGXEJXFK9-eyJsaWNlbnNlSWQiOiIzQUdYRUpYRks5IiwibGljZW5zZWVOYW1lIjoiaHR0cHM6Ly96aGlsZS5pbyIsImFzc2lnbmVlTmFtZSI6IiIsImFzc2lnbmVlRW1haWwiOiIiLCJsaWNlbnNlUmVzdHJpY3Rpb24iOiIiLCJjaGVja0NvbmN1cnJlbnRVc2UiOmZhbHNlLCJwcm9kdWN0cyI6W3siY29kZSI6IklJIiwiZmFsbGJhY2tEYXRlIjoiMjA4OS0wNy0wNyIsInBhaWRVcFRvIjoiMjA4OS0wNy0wNyJ9LHsiY29kZSI6IkFDIiwiZmFsbGJhY2tEYXRlIjoiMjA4OS0wNy0wNyIsInBhaWRVcFRvIjoiMjA4OS0wNy0wNyJ9LHsiY29kZSI6IkRQTiIsImZhbGxiYWNrRGF0ZSI6IjIwODktMDctMDciLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJQUyIsImZhbGxiYWNrRGF0ZSI6IjIwODktMDctMDciLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJHTyIsImZhbGxiYWNrRGF0ZSI6IjIwODktMDctMDciLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJETSIsImZhbGxiYWNrRGF0ZSI6IjIwODktMDctMDciLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJDTCIsImZhbGxiYWNrRGF0ZSI6IjIwODktMDctMDciLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJSUzAiLCJmYWxsYmFja0RhdGUiOiIyMDg5LTA3LTA3IiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiUkMiLCJmYWxsYmFja0RhdGUiOiIyMDg5LTA3LTA3IiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiUkQiLCJmYWxsYmFja0RhdGUiOiIyMDg5LTA3LTA3IiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiUEMiLCJmYWxsYmFja0RhdGUiOiIyMDg5LTA3LTA3IiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiUk0iLCJmYWxsYmFja0RhdGUiOiIyMDg5LTA3LTA3IiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiV1MiLCJmYWxsYmFja0RhdGUiOiIyMDg5LTA3LTA3IiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiREIiLCJmYWxsYmFja0RhdGUiOiIyMDg5LTA3LTA3IiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiREMiLCJmYWxsYmFja0RhdGUiOiIyMDg5LTA3LTA3IiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiUlNVIiwiZmFsbGJhY2tEYXRlIjoiMjA4OS0wNy0wNyIsInBhaWRVcFRvIjoiMjA4OS0wNy0wNyJ9XSwiaGFzaCI6IjEyNzk2ODc3LzAiLCJncmFjZVBlcmlvZERheXMiOjcsImF1dG9Qcm9sb25nYXRlZCI6ZmFsc2UsImlzQXV0b1Byb2xvbmdhdGVkIjpmYWxzZX0&#x3D;-WGTHs6XpDhr+uumvbwQPOdlxWnQwgnGaL4eRnlpGKApEEkJyYvNEuPWBSrQkPmVpim&#x2F;8Sab6HV04Dw3IzkJT0yTc29sPEXBf69+7y6Jv718FaJu4MWfsAk&#x2F;ZGtNIUOczUQ0iGKKnSSsfQ&#x2F;3UoMv0q&#x2F;yJcfvj+me5Zd&#x2F;gfaisCCMUaGjB&#x2F;lWIPpEPzblDtVJbRexB1MALrLCEoDv3ujcPAZ7xWb54DiZwjYhQvQ+CvpNNF2jeTku7lbm5v+BoDsdeRq7YBt9ANLUKPr2DahcaZ4gctpHZXhG96IyKx232jYq9jQrFDbQMtVr3E+GsCekMEWSD&#x2F;&#x2F;dLT+HuZdc1sAIYrw&#x3D;&#x3D;-MIIElTCCAn2gAwIBAgIBCTANBgkqhkiG9w0BAQsFADAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBMB4XDTE4MTEwMTEyMjk0NloXDTIwMTEwMjEyMjk0NlowaDELMAkGA1UEBhMCQ1oxDjAMBgNVBAgMBU51c2xlMQ8wDQYDVQQHDAZQcmFndWUxGTAXBgNVBAoMEEpldEJyYWlucyBzLnIuby4xHTAbBgNVBAMMFHByb2QzeS1mcm9tLTIwMTgxMTAxMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA5ndaik1GD0nyTdqkZgURQZGW+RGxCdBITPXIwpjhhaD0SXGa4XSZBEBoiPdY6XV6pOfUJeyfi9dXsY4MmT0D+sKoST3rSw96xaf9FXPvOjn4prMTdj3Ji3CyQrGWeQU2nzYqFrp1QYNLAbaViHRKuJrYHI6GCvqCbJe0LQ8qqUiVMA9wG&#x2F;PQwScpNmTF9Kp2Iej+Z5OUxF33zzm+vg&#x2F;nYV31HLF7fJUAplI&#x2F;1nM+ZG8K+AXWgYKChtknl3sW9PCQa3a3imPL9GVToUNxc0wcuTil8mqveWcSQCHYxsIaUajWLpFzoO2AhK4mfYBSStAqEjoXRTuj17mo8Q6M2SHOcwIDAQABo4GZMIGWMAkGA1UdEwQCMAAwHQYDVR0OBBYEFGEpG9oZGcfLMGNBkY7SgHiMGgTcMEgGA1UdIwRBMD+AFKOetkhnQhI2Qb1t4Lm0oFKLl&#x2F;GzoRykGjAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBggkA0myxg7KDeeEwEwYDVR0lBAwwCgYIKwYBBQUHAwEwCwYDVR0PBAQDAgWgMA0GCSqGSIb3DQEBCwUAA4ICAQBonMu8oa3vmNAa4RQP8gPGlX3SQaA3WCRUAj6Zrlk8AesKV1YSkh5D2l+yUk6njysgzfr1bIR5xF8eup5xXc4&#x2F;G7NtVYRSMvrd6rfQcHOyK5UFJLm+8utmyMIDrZOzLQuTsT8NxFpbCVCfV5wNRu4rChrCuArYVGaKbmp9ymkw1PU6+HoO5i2wU3ikTmRv8IRjrlSStyNzXpnPTwt7bja19ousk56r40SmlmC04GdDHErr0ei2UbjUua5kw71Qn9g02tL9fERI2sSRjQrvPbn9INwRWl5+k05mlKekbtbu2ev2woJFZK4WEXAd&#x2F;GaAdeZZdumv8T2idDFL7cAirJwcrbfpawPeXr52oKTPnXfi0l5+g9Gnt&#x2F;wfiXCrPElX6ycTR6iL3GC2VR4jTz6YatT4Ntz59&#x2F;THOT7NJQhr6AyLkhhJCdkzE2cob&#x2F;KouVp4ivV7Q3Fc6HX7eepHAAF&#x2F;DpxwgOrg9smX6coXLgfp0b1RU2u&#x2F;tUNID04rpNxTMueTtrT8WSskqvaJd3RH8r7cnRj6Y2hltkja82HlpDURDxDTRvv+krbwMr26SB&#x2F;40BjpMUrDRCeKuiBahC0DCoU&#x2F;4+ze1l94wVUhdkCfL0GpJrMSCDEK+XEurU18Hb7WT+ThXbkdl6VpFdHsRvqAnhR2g4b+Qzgidmuky5NUZVfEaZqV&#x2F;g&#x3D;&#x3D;</span><br></pre></td></tr></table></figure><p>直接激活就行</p>]]></content>
    
    <summary type="html">
    
      记录下破解Idea的方法，方便以后更换设备；
    
    </summary>
    
    
      <category term="软件&amp;&amp;工具" scheme="http://Luweir.github.io/categories/%E8%BD%AF%E4%BB%B6-%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="Idea" scheme="http://Luweir.github.io/tags/Idea/"/>
    
      <category term="Crack" scheme="http://Luweir.github.io/tags/Crack/"/>
    
  </entry>
  
  <entry>
    <title>数学建模培训之现代优化算法作业</title>
    <link href="http://luweir.github.io/2020/07/18/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E5%9F%B9%E8%AE%AD%E7%8E%B0%E4%BB%A3%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95%E4%BD%9C%E4%B8%9A/"/>
    <id>http://luweir.github.io/2020/07/18/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E5%9F%B9%E8%AE%AD%E7%8E%B0%E4%BB%A3%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95%E4%BD%9C%E4%B8%9A/</id>
    <published>2020-07-17T18:15:00.000Z</published>
    <updated>2020-11-06T16:08:08.820Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>分别用<strong>随机游走</strong>、<strong>粒子群算法</strong>对下面的函数求最小值,请用Word或PDF文档给出实现代码( Matlab、Python均可 ) , 并用表格汇总各算法的参数值,寻优所需时间,最优值和最优值坐标。Z =100(x^2^-y)^2^+(x-1)^2^，-2.048&lt;= x, y&lt;= 2.048；</p><h1 id="问题求解"><a href="#问题求解" class="headerlink" title="问题求解"></a>问题求解</h1><h2 id="1、随机游走算法-RandomWalk"><a href="#1、随机游走算法-RandomWalk" class="headerlink" title="1、随机游走算法 RandomWalk"></a>1、随机游走算法 RandomWalk</h2><p><strong>算法原理</strong>：</p><p>​    每次随机选择一个当前解的邻近点进行比较,如果优于当前解,则将该点作为新的中心。如果连续n次都找不到更优的值，则认为最优解就在以当前<br>最优解为中心,当前步长为半径的D维球内(如果是三维,则刚好是空间中的球体)。如果此时步长已经小于阈值,则结束算法;否则,令步长减半，开始新一轮游走。</p><p>贴上代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># 使用随机游走算法求解函数极值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> __future__  <span class="keyword">import</span> print_function</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">N = <span class="number">3000</span> <span class="comment"># 迭代次数 N=100</span></span><br><span class="line">step = <span class="number">5</span> <span class="comment"># 初始步长 λ=5</span></span><br><span class="line">epsilon = <span class="number">0.00001</span> <span class="comment"># 精度达到10^(-5)</span></span><br><span class="line">variables = <span class="number">2</span> <span class="comment"># 变量数目为2</span></span><br><span class="line">x = [<span class="number">-2</span>,<span class="number">2</span>] <span class="comment"># 初始点坐标[-2,2]</span></span><br><span class="line">walk_num = <span class="number">1</span> <span class="comment"># 初始化随机游走次数</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出参数</span></span><br><span class="line">print(<span class="string">"迭代次数:"</span>,N)</span><br><span class="line">print(<span class="string">"初始步长:"</span>,step)</span><br><span class="line">print(<span class="string">"epsilon:"</span>,epsilon)</span><br><span class="line">print(<span class="string">"变量数目:"</span>,variables)</span><br><span class="line">print(<span class="string">"初始点坐标:"</span>,x)</span><br><span class="line"><span class="comment"># 定义目标函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">function</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> abs(x[<span class="number">0</span>])&lt;=<span class="number">2.048</span> <span class="keyword">and</span> abs(x[<span class="number">1</span>])&lt;=<span class="number">2.048</span>:</span><br><span class="line">        f = <span class="number">100</span>*(x[<span class="number">0</span>]**<span class="number">2</span>-x[<span class="number">1</span>])**<span class="number">2</span> + (x[<span class="number">0</span>]<span class="number">-1</span>)**<span class="number">2</span></span><br><span class="line">        <span class="keyword">return</span> f</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">100000</span> <span class="comment"># 取得某个不可能为最优解的值 </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 开始随机游走</span></span><br><span class="line">start=time.process_time() <span class="comment">#记录开始时间</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(step &gt; epsilon):</span><br><span class="line">    k = <span class="number">1</span> <span class="comment"># 初始化计数器</span></span><br><span class="line">    <span class="keyword">while</span>(k &lt; N):</span><br><span class="line">        u = [random.uniform(<span class="number">-1</span>,<span class="number">1</span>) <span class="keyword">for</span> i <span class="keyword">in</span> range(variables)] <span class="comment"># 随机向量</span></span><br><span class="line">        <span class="comment"># u1 为标准化之后的随机向量</span></span><br><span class="line">        u1 = [u[i]/math.sqrt(sum([u[i]**<span class="number">2</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(variables)])) <span class="keyword">for</span> i <span class="keyword">in</span> range(variables)]</span><br><span class="line">        x1 = [x[i] + step*u1[i] <span class="keyword">for</span> i <span class="keyword">in</span> range(variables)]</span><br><span class="line">        <span class="keyword">if</span>(function(x1) &lt; function(x)): <span class="comment"># 如果找到了更优点</span></span><br><span class="line">            k = <span class="number">1</span></span><br><span class="line">            x = x1</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            k += <span class="number">1</span></span><br><span class="line">    step = step/<span class="number">2</span></span><br><span class="line">    print(<span class="string">"第%d次随机游走完成。"</span> % walk_num)</span><br><span class="line">    walk_num += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">end=time.process_time() <span class="comment">#记录结束时间</span></span><br><span class="line">print(<span class="string">"耗时 (s): "</span>, end-start)</span><br><span class="line">print(<span class="string">"随机游走次数:"</span>,walk_num<span class="number">-1</span>)</span><br><span class="line">print(<span class="string">"最终最优点:"</span>,x)</span><br><span class="line">print(<span class="string">"最终最优值:"</span>,function(x))</span><br></pre></td></tr></table></figure><p>结果如下图所示：</p><p><img src="https://tacotuesdayyy.oss-cn-shenzhen.aliyuncs.com/umg/image-20200716224814889.png" alt="image-20200716224814889"></p><h2 id="2、粒子群算法-PSO"><a href="#2、粒子群算法-PSO" class="headerlink" title="2、粒子群算法 PSO"></a>2、粒子群算法 PSO</h2><p><strong>算法原理</strong>：</p><p>​    粒子群算法用粒子来模拟鸟群中的鸟,即用粒子代表问题的可能解,每个粒子在搜索空间中单独的搜寻最优解,通过粒子个体的简单行为和群体内的信息交互,实现了问题求解的智能性。粒子具有两个属性:速度和位置。速度代表移动的快慢,位置代表移动的方向。每个粒子每次搜索得到的最优解,记为当前粒子的个体极值。然后将此个体极值与整个粒子群里的其他粒子共享,找出最优的个体极值,作为整个粒子群的当前全局最优解。所有粒子根据自己的个体极值和整个粒子群共享的当前全局最优解来不断调整自己的速度和位置。</p><p>贴上代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Plot particle history as animation</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> sko.PSO <span class="keyword">import</span> PSO</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">demo_func</span><span class="params">(p)</span>:</span></span><br><span class="line">    x, y = p</span><br><span class="line">    <span class="keyword">return</span> <span class="number">100</span> * ((x ** <span class="number">2</span> - y) ** <span class="number">2</span>) + (x - <span class="number">1</span>) ** <span class="number">2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">lbs=[<span class="number">-2.048</span>, <span class="number">-2.048</span>]</span><br><span class="line">ubs=[<span class="number">2.048</span>, <span class="number">2.048</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">pso = PSO(func=demo_func, dim=<span class="number">2</span>, pop=<span class="number">40</span>, max_iter=<span class="number">300</span>, lb=lbs, ub=ubs, w=<span class="number">0.8</span>, c1=<span class="number">0.5</span>, c2=<span class="number">0.5</span>)</span><br><span class="line"><span class="comment"># 搜索空间维数: dim=2</span></span><br><span class="line"><span class="comment"># 初始群体的个体数量: pop=40</span></span><br><span class="line"><span class="comment"># 最大迭代次数: max_iter=300</span></span><br><span class="line"><span class="comment"># x,y的下限分别为 lbs=[-2.048, -2.048]</span></span><br><span class="line"><span class="comment"># x,y的上限分别为 ubs=[2.048, 2.048]</span></span><br><span class="line"><span class="comment"># 惯性权重: w=0.8 越大越有利于全局最优</span></span><br><span class="line"><span class="comment"># 社会经验和自身经验对半分: c1=0.5,c2=0.5</span></span><br><span class="line">pso.record_mode = <span class="literal">True</span> <span class="comment">#记录模式</span></span><br><span class="line"></span><br><span class="line">start=time.process_time()</span><br><span class="line">pso.run()</span><br><span class="line">end=time.process_time()</span><br><span class="line">print(<span class="string">'best_x is '</span>, pso.gbest_x, <span class="string">'\n best_z is'</span>, pso.gbest_y)</span><br><span class="line">print(<span class="string">"运行耗时：(s) "</span>,end-start)</span><br></pre></td></tr></table></figure><p>结果如下图所示：</p><p><img src="https://tacotuesdayyy.oss-cn-shenzhen.aliyuncs.com/umg/image-20200717000646084.png" alt="image-20200717000646084"></p><p>当max_iter最大迭代次数仅为100时，得到的结果精度达不到这么高，如图所示：</p><p><img src="https://tacotuesdayyy.oss-cn-shenzhen.aliyuncs.com/umg/image-20200717000728261.png" alt="image-20200717000728261"></p><h1 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h1><p>分别用<strong>模拟退火或蚁群算法(二选一)和遗传算法</strong>对给定坐标的<strong>TSP问题</strong>进行求解,请用Word或PDF文档给出实现代码(Matlab、Python均可) , 并用表格汇总各算法的参数值,寻优所需时间,最短路径及距离。</p><p>部分数据如下图所示：</p><p><img src="https://tacotuesdayyy.oss-cn-shenzhen.aliyuncs.com/umg/image-20200717080331585.png" alt="image-20200717080331585"></p><h1 id="问题求解-1"><a href="#问题求解-1" class="headerlink" title="问题求解"></a>问题求解</h1><p>首先对数据进行处理，即删除第一列，将其保存为新的文件；</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="comment"># 从指定文件夹中读取数据，非使用第一行的数据为列名，以' '为分隔符</span></span><br><span class="line">data1=pd.read_csv(<span class="string">r'F:\Users\Administrator\Desktop\建模培训\7.12第8天 现代优化算法\作业\作业2数据.txt'</span>,header=<span class="literal">None</span>,delimiter=<span class="string">' '</span>)</span><br><span class="line"><span class="comment"># 将数据的保存至数据4.txt，其索引、列名皆不保存，默认以','为分隔符</span></span><br><span class="line">df.to_csv(<span class="string">r'F:\Users\Administrator\Desktop\建模培训\7.12第8天 现代优化算法\作业\数据4.txt'</span>,index=<span class="literal">False</span>,header=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure><p>部分数据如图所示：</p><p><img src="https://tacotuesdayyy.oss-cn-shenzhen.aliyuncs.com/umg/image-20200717235635799.png" alt="image-20200717235635799"></p><h2 id="1、遗传算法-GA"><a href="#1、遗传算法-GA" class="headerlink" title="1、遗传算法 GA"></a>1、遗传算法 GA</h2><p><strong>算法原理</strong>：</p><p>​    遗传算法是一种基于自然选择、 生物进化过程来求解问题的方法。在每一步中,算法随机地从当前种群( Population )中选择若千个体(Individual )作为父辈,并且使用它们产生下一-代的子孙种群。在连续若干代之后,种群朝着优化解的方向进化。遗传算法可求解各种优化问题,如:目标函数不连续、不可微、随机或高度非线性。</p><p><strong>算法特点</strong>：<br>1、直接对结构对象进行操作,不存在求导和函数连续性的限定;<br>2、具有内在的隐并行性和更好的全局寻优能力;<br>3、概率化的寻优方法,自适应地调整搜索方向；</p><p><strong>一般步骤</strong>：<br>1.随机产生初始候选种群。<br>2.计算候选种群中所有个体的适应度。若符合结束条件,则输出最佳个体及最优解,结束进化。不符合,则步骤3<br>3.在候选种群中进行个体选择,适应度高的个体高概率被选为父母个体,适应度低的个体被淘汰。<br>4.用父母的染色体进行交叉,生成新个体。<br>5.对子代染色体进行变异,生成新个体。<br>6.将新个体加入候选种群中,返回步骤2。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> scipy <span class="keyword">import</span> spatial</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取数据</span></span><br><span class="line">points_coordinate =np.loadtxt(<span class="string">'数据4.txt'</span>,delimiter=<span class="string">","</span>)</span><br><span class="line"><span class="comment"># 一共有num_points个点</span></span><br><span class="line">num_points = points_coordinate.shape[<span class="number">0</span>]</span><br><span class="line"><span class="comment"># 得到任意两个点之间的距离</span></span><br><span class="line">distance_matrix = spatial.distance.cdist(points_coordinate, points_coordinate, metric=<span class="string">'euclidean'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cal_total_distance</span><span class="params">(routine)</span>:</span></span><br><span class="line">    num_points, = routine.shape</span><br><span class="line">    <span class="keyword">return</span> sum([distance_matrix[routine[i % num_points], routine[(i + <span class="number">1</span>) % num_points]] <span class="keyword">for</span> i <span class="keyword">in</span> range(num_points)])</span><br><span class="line"></span><br><span class="line"><span class="comment"># do GA</span></span><br><span class="line"><span class="keyword">from</span> sko.GA <span class="keyword">import</span> GA_TSP</span><br><span class="line">ga_tsp = GA_TSP(func=cal_total_distance, n_dim=num_points, size_pop=<span class="number">80</span>, max_iter=<span class="number">3000</span>, prob_mut=<span class="number">0.1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行并计算耗时</span></span><br><span class="line">start=time.process_time()</span><br><span class="line">best_points, best_distance = ga_tsp.run()</span><br><span class="line">end=time.process_time()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进行输出</span></span><br><span class="line">print(<span class="string">"运行耗时: (s)"</span>,end-start)</span><br><span class="line">print(best_distance)</span><br></pre></td></tr></table></figure><p>可视化图形所下所示：</p><p><img src="https://tacotuesdayyy.oss-cn-shenzhen.aliyuncs.com/umg/image-20200718014056308.png" alt="image-20200718014056308"></p><p>运行耗时、最短路径以及最短距离如图所示：</p><p><img src="https://tacotuesdayyy.oss-cn-shenzhen.aliyuncs.com/umg/image-20200718020250167.png" alt="image-20200718020250167"></p><h2 id="2、模拟退火算法-SA"><a href="#2、模拟退火算法-SA" class="headerlink" title="2、模拟退火算法 SA"></a>2、模拟退火算法 SA</h2><p>​        模拟退火算法SA出发点是基于物理中固体物质的退火过程与一般组合优化问题之间的相似性；</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> scipy <span class="keyword">import</span> spatial</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取数据集</span></span><br><span class="line">file_name = sys.argv[<span class="number">1</span>] <span class="keyword">if</span> len(sys.argv) &gt; <span class="number">1</span> <span class="keyword">else</span> <span class="string">'数据4.txt'</span></span><br><span class="line">points_coordinate = np.loadtxt(file_name, delimiter=<span class="string">','</span>)</span><br><span class="line"><span class="comment"># 一共有num_points个点</span></span><br><span class="line">num_points = points_coordinate.shape[<span class="number">0</span>]</span><br><span class="line"><span class="comment"># 得到任意两个点之间的距离</span></span><br><span class="line">distance_matrix = spatial.distance.cdist(points_coordinate, points_coordinate, metric=<span class="string">'euclidean'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cal_total_distance</span><span class="params">(routine)</span>:</span></span><br><span class="line">    num_points, = routine.shape</span><br><span class="line">    <span class="keyword">return</span> sum([distance_matrix[routine[i % num_points], routine[(i + <span class="number">1</span>) % num_points]] <span class="keyword">for</span> i <span class="keyword">in</span> range(num_points)])</span><br><span class="line"></span><br><span class="line"><span class="comment"># do SA</span></span><br><span class="line"><span class="keyword">from</span> sko.SA <span class="keyword">import</span> SA_TSP</span><br><span class="line">sa_tsp = SA_TSP(func=cal_total_distance, x0=range(num_points), T_max=<span class="number">100</span>, T_min=<span class="number">1</span>, L=<span class="number">5</span> * num_points)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行并计算耗时</span></span><br><span class="line">start=time.process_time()</span><br><span class="line">best_points, best_distance = sa_tsp.run()</span><br><span class="line">end=time.process_time()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进行输出</span></span><br><span class="line">print(<span class="string">"运行耗时: (s)"</span>,end-start)</span><br><span class="line">print(best_points, best_distance, cal_total_distance(best_points))</span><br></pre></td></tr></table></figure><p>可视化图形如下所示：</p><p><img src="https://tacotuesdayyy.oss-cn-shenzhen.aliyuncs.com/umg/image-20200718014330364.png" alt="image-20200718014330364"></p><p><img src="https://tacotuesdayyy.oss-cn-shenzhen.aliyuncs.com/umg/image-20200718014340636.png" alt="image-20200718014340636"></p><p>运行耗时、最佳路径以及最短距离如下所示：</p><p><img src="https://tacotuesdayyy.oss-cn-shenzhen.aliyuncs.com/umg/image-20200718014633486.png" alt="image-20200718014633486"></p>]]></content>
    
    <summary type="html">
    
      记录求解现代优化算法作业的步骤
    
    </summary>
    
    
      <category term="数学建模" scheme="http://Luweir.github.io/categories/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/"/>
    
    
      <category term="Algorithm" scheme="http://Luweir.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>建模培训之回归分析作业</title>
    <link href="http://luweir.github.io/2020/07/15/%E5%9B%9E%E5%BD%92%E5%88%86%E6%9E%90%E4%BD%9C%E4%B8%9A/"/>
    <id>http://luweir.github.io/2020/07/15/%E5%9B%9E%E5%BD%92%E5%88%86%E6%9E%90%E4%BD%9C%E4%B8%9A/</id>
    <published>2020-07-15T14:58:00.000Z</published>
    <updated>2020-11-06T16:08:18.327Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>​        数据文件是1995-2018年的中国有关粮食种植方面的数据,我们认为播种面积(千公顷) (y)可能受以下六个因素影响,分别为产量(万吨)(x1),农业劳动力人口(万人) (x2),农民受教育程度(年) (x3)， 全国.小麦进口额(万吨) (x4), 城乡收入差距(x5),家庭负担(元/人)(x6), .请分别用<strong>经典最小二乘回归、主成分回归以及偏最小二乘回归</strong>三种方法进行分析并给出合理解释。</p><p><img src="https://tacotuesdayyy.oss-cn-shenzhen.aliyuncs.com/umg/image-20200715001040735.png" alt="粮食数据"></p><h1 id="问题求解"><a href="#问题求解" class="headerlink" title="问题求解"></a>问题求解</h1><h2 id="1、使用最小二乘回归分析"><a href="#1、使用最小二乘回归分析" class="headerlink" title="1、使用最小二乘回归分析"></a>1、使用最小二乘回归分析</h2><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">xdata=xlsread(<span class="string">'粮食数据1.xlsx'</span>);</span><br><span class="line">x=xdata(:,<span class="number">3</span>:<span class="keyword">end</span>);<span class="comment">%自变量6个</span></span><br><span class="line">y=xdata(:,<span class="number">2</span>);<span class="comment">%因变量1个</span></span><br><span class="line">reglm(y,x);</span><br></pre></td></tr></table></figure><p>得到以下结果：</p><p><img src="https://tacotuesdayyy.oss-cn-shenzhen.aliyuncs.com/umg/image-20200714222851951.png" alt="image-20200714222851951"></p><p>由分析表中可以看出，存在多重线性关系，比如x1，x2，x4的p值就大于0.05，其对因变量的影响较小，接下来应该消除多重线性关系；</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">inmodel=<span class="number">1</span>:<span class="number">6</span>;</span><br><span class="line">stepwise(x,y,inmodel)</span><br></pre></td></tr></table></figure><p>消除之前是这样的：</p><p><img src="https://tacotuesdayyy.oss-cn-shenzhen.aliyuncs.com/umg/image-20200714223227698.png" alt="image-20200714223227698"></p><p>把<strong>p值最大的变量X4</strong>移除之后：</p><p><img src="https://tacotuesdayyy.oss-cn-shenzhen.aliyuncs.com/umg/image-20200714223419622.png" alt="image-20200714223419622"></p><p>我们可以看到剩下的<strong>自变量P值皆小于0.05</strong>，符合要求；</p><p>并且调整后的<strong>拟合度达到0.955</strong>，即此方程解释的信息超过95%，并且<strong>整体P值远小于0.05</strong>，通过显著性检验，达到要求；</p><p>所以我们可以得到使用最小二乘回归分析后的方程：<br>$$<br>y=2406.2-0.234144X1-0.427047X2+553.76X3-272.711X5-0.107136X6<br>$$<br>从方程式中可以看出，粮食播种面积由农民受教育程度以及城乡收入差距影响；（不知道怎么分析啊  😂😂😂）</p><h2 id="2、使用主成分回归分析"><a href="#2、使用主成分回归分析" class="headerlink" title="2、使用主成分回归分析"></a>2、使用主成分回归分析</h2><p><strong>步骤1：对自变量进行主成分分析</strong></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">xdata=xlsread(<span class="string">'粮食数据1.xlsx'</span>);</span><br><span class="line">x=xdata(:,<span class="number">3</span>:<span class="keyword">end</span>);<span class="comment">%自变量6个</span></span><br><span class="line">y=xdata(:,<span class="number">2</span>);<span class="comment">%因变量1个</span></span><br><span class="line">xz=zscore(x); <span class="comment">%数据标准化</span></span><br><span class="line">[coeff, score, latent, tsquare, explained]=pca (xz) <span class="comment">%由观测数据矩阵作分析</span></span><br></pre></td></tr></table></figure><p>得到的 coeff 系数矩阵如图所示：</p><p><img src="https://tacotuesdayyy.oss-cn-shenzhen.aliyuncs.com/umg/image-20200714232054645.png" alt="image-20200714232054645"></p><p><strong>步骤2：因变量对主成分变量进行回归</strong></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">z1=score(:,<span class="number">1</span>:<span class="number">6</span>);</span><br><span class="line">reglm(y,z1)</span><br></pre></td></tr></table></figure><p><img src="https://tacotuesdayyy.oss-cn-shenzhen.aliyuncs.com/umg/image-20200714232505482.png" alt="image-20200714232505482"></p><p>可以看出X2，X3，X5，X6对因变量的影响较小，剔除后：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">z1=scorez(:,[<span class="number">1</span> <span class="number">4</span>]);<span class="comment">%发现第2,3,5,6个主成分得分量对因变量影响不显著（p&gt;0.05）,因而删除它！</span></span><br><span class="line">reglm(y,z1)</span><br></pre></td></tr></table></figure><p><img src="https://tacotuesdayyy.oss-cn-shenzhen.aliyuncs.com/umg/image-20200714235654248.png" alt="image-20200714235654248"></p><p>拟合度达到0.94以上，各参数P值均小于0.05，符合要求；</p><p>注意这里的X1，X2指Z1和Z4，需要步骤3的操作将Z转换为X；</p><p><strong>步骤3：因变量对原始变量进行回归</strong></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%计算因变量对原始自变量的回归方程系数</span></span><br><span class="line">xn=zscore(x);</span><br><span class="line">yn=zscore(y);</span><br><span class="line">d=xn*coeff;</span><br><span class="line">st=coeff(:,[<span class="number">1</span> <span class="number">4</span>])*(d(:,[<span class="number">1</span> <span class="number">4</span>])\yn);</span><br><span class="line">st2=[<span class="built_in">mean</span>(y)-std(y)*<span class="built_in">mean</span>(x)./std(x)*st,std(y)*st'./std(x)];</span><br></pre></td></tr></table></figure><p>结果如图所示：</p><p><img src="https://tacotuesdayyy.oss-cn-shenzhen.aliyuncs.com/umg/image-20200715000500316.png" alt="image-20200715000500316"></p><p>即方程为：<br>$$<br>y=7482.6+0.1X1-1.1X2+54.2X3-0.1X4-27.5X5<br>$$<br>贴上完整Matlab代码：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">xdata=xlsread(<span class="string">'粮食数据1.xlsx'</span>);</span><br><span class="line">x=xdata(:,<span class="number">3</span>:<span class="keyword">end</span>);<span class="comment">%自变量6个</span></span><br><span class="line">y=xdata(:,<span class="number">2</span>);<span class="comment">%因变量1个</span></span><br><span class="line">xz=zscore(x);</span><br><span class="line">[coeff, score, latent, tsquare, explained]=pca (xz)</span><br><span class="line">z1=score(:,[<span class="number">1</span>:<span class="number">6</span>]);</span><br><span class="line">reglm(y,z1)</span><br><span class="line">z1=score(:,[<span class="number">1</span> <span class="number">4</span>]);</span><br><span class="line">reglm(y,z1)</span><br><span class="line"></span><br><span class="line"><span class="comment">%计算因变量对原始自变量的回归方程系数</span></span><br><span class="line">xn=zscore(x);</span><br><span class="line">yn=zscore(y);</span><br><span class="line">d=xn*coeff;</span><br><span class="line">st=coeff(:,[<span class="number">1</span> <span class="number">4</span>])*(d(:,[<span class="number">1</span> <span class="number">4</span>])\yn);</span><br><span class="line">st2=[<span class="built_in">mean</span>(y)-std(y)*<span class="built_in">mean</span>(x)./std(x)*st,std(y)*st'./std(x)];</span><br></pre></td></tr></table></figure><p>分析：xxxxxxxxx</p><h2 id="3、偏最小二乘回归分析"><a href="#3、偏最小二乘回归分析" class="headerlink" title="3、偏最小二乘回归分析"></a>3、偏最小二乘回归分析</h2><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">xdata=xlsread(<span class="string">'粮食数据1.xlsx'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">%只有一个因变量</span></span><br><span class="line">mu=<span class="built_in">mean</span>(xdata(:,<span class="number">2</span>:<span class="number">8</span>));sig=std(xdata(:,<span class="number">2</span>:<span class="number">8</span>)); <span class="comment">%求均值和标准差</span></span><br><span class="line">ab=zscore(xdata(:,<span class="number">2</span>:<span class="number">8</span>));<span class="comment">%数据标准化</span></span><br><span class="line">a=ab(:,<span class="number">2</span>:<span class="number">7</span>);b1=ab(:,<span class="number">1</span>);</span><br><span class="line">[XL,YL,XS,YS,BETA,PCTVAR,MSE]=plsregress(a,b1,<span class="number">6</span>,<span class="string">'cv'</span>,<span class="number">10</span>);<span class="comment">%观测整体所有成分对的情况，用10折(把样本分成十份，每次用9份建模，最后一份来检验)交叉验证</span></span><br></pre></td></tr></table></figure><p><img src="https://tacotuesdayyy.oss-cn-shenzhen.aliyuncs.com/umg/image-20200715211152634.png" alt="image-20200715211152634"></p><p><img src="https://tacotuesdayyy.oss-cn-shenzhen.aliyuncs.com/umg/image-20200715211218030.png" alt="image-20200715211218030"></p><p><img src="https://tacotuesdayyy.oss-cn-shenzhen.aliyuncs.com/umg/image-20200715211229324.png" alt="image-20200715211229324"></p><p><strong>BETA为标准化系数矩阵</strong>，常数项为0，如下图所示：</p><p><img src="https://tacotuesdayyy.oss-cn-shenzhen.aliyuncs.com/umg/image-20200715211257426.png" alt="image-20200715211257426"></p><p><strong>PCTVAR为信息贡献率</strong>，如下图所示：</p><p><img src="https://tacotuesdayyy.oss-cn-shenzhen.aliyuncs.com/umg/image-20200715211403066.png" alt="image-20200715211403066"></p><p>第一个成分可以解释自变量组的63%的信息量，可以解释因变量的93%的信息量；</p><p>可以发现越后面的成分，信息的贡献量越低；</p><p>可以做累计和，即为这些成分的总的贡献率；</p><p><strong>MSE为用n个成分时的均方根误差</strong>，如下图所示：</p><p><img src="https://tacotuesdayyy.oss-cn-shenzhen.aliyuncs.com/umg/image-20200715212055655.png" alt="image-20200715212055655"></p><p>可以发现，用0个成分时，自变量的均方根误差为6.5959，因变量的均方根误差为1.1033；</p><p>用1个成分时，自变量的均方根误差为2.9808，因变量的均方根误差为0.0784；</p><p>用2个成分时，自变量的均方根误差为1.2281，因变量的均方根误差为0.1001；</p><p>到了用5、6个成分时，可以发现因变量的均方根误差明显必用4个成分时的大，说明这两个成分时噪声、无用信息，<strong>成分的选取最多4个</strong>；</p><p>随后对这4个成分再次进行分析：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">contr=cumsum(PCTVAR,<span class="number">2</span>); <span class="comment">%六个成分的累计贡献率</span></span><br><span class="line">ncomp=<span class="number">4</span>;<span class="comment">%根据整体情况，选择成分</span></span><br><span class="line">[XL,YL,XS,YS,BETA,PCTVAR,MSE,stats]=plsregress(a,b1,<span class="number">4</span>,<span class="string">'cv'</span>,<span class="number">10</span>)</span><br><span class="line">contr=cumsum(PCTVAR,<span class="number">2</span>) <span class="comment">% 4个成分的累计贡献率</span></span><br></pre></td></tr></table></figure><p>4个成分的累计贡献率如下图所示：</p><p><img src="https://tacotuesdayyy.oss-cn-shenzhen.aliyuncs.com/umg/image-20200715213617179.png" alt="image-20200715213617179"></p><p>即用4个成分可以提取自变量组99.6%的信息量，可以提取因变量95.7%的信息量；</p><p>标准化系数矩阵BETA如下图所示：</p><p><img src="https://tacotuesdayyy.oss-cn-shenzhen.aliyuncs.com/umg/image-20200715213746900.png" alt="image-20200715213746900"></p><p>最后我们通过计算得到原始变量的回归方程：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">n=<span class="built_in">size</span>(a,<span class="number">2</span>);m=<span class="built_in">size</span>(b1,<span class="number">2</span>);<span class="comment">%n是自变量的个数,m是因变量的个数</span></span><br><span class="line">BETA2(<span class="number">1</span>,:)=mu(n+<span class="number">1</span>:<span class="keyword">end</span>)-mu(<span class="number">1</span>:n)./sig(<span class="number">1</span>:n)*BETA(<span class="number">2</span>:<span class="keyword">end</span>,:).*sig(n+<span class="number">1</span>:<span class="keyword">end</span>);<span class="comment">%原始数据回归方程的常数项</span></span><br><span class="line">BETA2(<span class="number">2</span>:n+<span class="number">1</span>,:)=(<span class="number">1.</span>/sig(<span class="number">1</span>:n))'*sig(n+<span class="number">1</span>:<span class="keyword">end</span>).*BETA(<span class="number">2</span>:<span class="keyword">end</span>,:)<span class="comment">%计算原始自变量x</span></span><br></pre></td></tr></table></figure><p><img src="https://tacotuesdayyy.oss-cn-shenzhen.aliyuncs.com/umg/image-20200715225446109.png" alt="image-20200715225446109"></p><p>即原始变量的回归方程为：<br>$$<br>y=6854.9+0.1909X1-0.9898X2+96.2804X3-0.1486X4-43.3423X5-0.0285X6<br>$$</p><p><img src="https://tacotuesdayyy.oss-cn-shenzhen.aliyuncs.com/umg/image-20200715220103998.png" alt="image-20200715220103998"></p><p>贴上代码：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">xdata=xlsread(<span class="string">'粮食数据1.xlsx'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">%只有一个因变量</span></span><br><span class="line">mu=<span class="built_in">mean</span>(xdata(:,<span class="number">2</span>:<span class="number">8</span>));sig=std(xdata(:,<span class="number">2</span>:<span class="number">8</span>)); <span class="comment">%求均值和标准差</span></span><br><span class="line">ab=zscore(xdata(:,<span class="number">2</span>:<span class="number">8</span>));<span class="comment">%数据标准化</span></span><br><span class="line">a=ab(:,<span class="number">2</span>:<span class="number">7</span>);b1=ab(:,<span class="number">1</span>); </span><br><span class="line">[XL,YL,XS,YS,BETA,PCTVAR,MSE,stats]=plsregress(a,b1,<span class="number">6</span>,<span class="string">'cv'</span>,<span class="number">10</span>);<span class="comment">%观测整体所有成分对的情况，用10折(把样本分成十份，每次用9份建模，最后一份来检验)交叉验证</span></span><br><span class="line"></span><br><span class="line">contr=cumsum(PCTVAR,<span class="number">2</span>);</span><br><span class="line">ncomp=<span class="number">4</span>;<span class="comment">%根据整体情况，选择成分</span></span><br><span class="line">[XL,YL,XS,YS,BETA,PCTVAR,MSE,stats]=plsregress(a,b1,ncomp,<span class="string">'cv'</span>,<span class="number">10</span>)</span><br><span class="line">contr=cumsum(PCTVAR,<span class="number">2</span>) <span class="comment">%求累计贡献率</span></span><br><span class="line"></span><br><span class="line">n=<span class="built_in">size</span>(a,<span class="number">2</span>);m=<span class="built_in">size</span>(b1,<span class="number">2</span>);<span class="comment">%n是自变量的个数,6个,m是因变量的个数,1个</span></span><br><span class="line">BETA2(<span class="number">1</span>,:)=mu(<span class="number">1</span>)-mu(<span class="number">2</span>:n+<span class="number">1</span>)./sig(<span class="number">2</span>:n+<span class="number">1</span>)*BETA(<span class="number">2</span>:<span class="keyword">end</span>,:).*sig(<span class="number">1</span>);<span class="comment">%原始数据回归方程的常数项</span></span><br><span class="line">BETA2(<span class="number">2</span>:n+<span class="number">1</span>,:)=(<span class="number">1.</span>/sig(<span class="number">2</span>:n+<span class="number">1</span>))'*sig(<span class="number">1</span>).*BETA(<span class="number">2</span>:<span class="keyword">end</span>,:)<span class="comment">%计算原始自变量x</span></span><br></pre></td></tr></table></figure><p>分析：xxxxxx</p>]]></content>
    
    <summary type="html">
    
      记录求解数学建模培训之回归分析作业的解题过程
    
    </summary>
    
    
      <category term="数学建模" scheme="http://Luweir.github.io/categories/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/"/>
    
    
  </entry>
  
  <entry>
    <title>数学建模培训学习笔记</title>
    <link href="http://luweir.github.io/2020/07/13/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E5%9F%B9%E8%AE%AD%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://luweir.github.io/2020/07/13/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E5%9F%B9%E8%AE%AD%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2020-07-13T04:32:00.000Z</published>
    <updated>2020-11-06T16:04:23.092Z</updated>
    
    <content type="html"><![CDATA[<h1 id="2020-7-5学习笔记–Python使用"><a href="#2020-7-5学习笔记–Python使用" class="headerlink" title="2020.7.5学习笔记–Python使用"></a>2020.7.5学习笔记–Python使用</h1><p>Python 语言具有通用性、高效性、跨平台移植性和安全性，广泛应用于科学计算、自然语言处理、图形图像处理、游戏开发、Web 应用等方面，在全球范围内拥有众多开发者专业社群。</p><p>安装python后使用pip进行库的安装；</p><p>常见的库有：</p><p><img src="https://tacotuesdayyy.oss-cn-shenzhen.aliyuncs.com/umg/image-20200710154400856.png" alt="image-20200710154400856"></p><p>建模里面要用到的库大概有：Numpy、Scipy、Pandas、Matplotlib、Networkx、cvxpy、Tensorflow等等</p><p>Anaconda中的jupyterNotebook同样也能实现很好的展示；</p><p>后面大概介绍了python的语法；</p><p>SciPy 是在 NumPy 库的基础上增加了众多的数学、科学以及工程计算中常用函数的库。SciPy 库依赖于 NumPy，提供了便捷且快速的 维数组操作。SciPy 库与 NumPy 数组一起工作，提供了许多友好和高效的处理方法，它包括了统计、优化、线性代数模块、傅里叶变换、信号、图像处理和常微分方程的求解等，功能十分强大。</p><p>Scipy还能用的积分计算模式；</p><p>使用 pylab 或 pyplot 绘图的一般过程为：首先读入数据，然后根据实际需要绘制折线图、散点图、柱状图、雷达图或三维曲线和曲面，接下来设置轴和图形属性，最后显示或保存绘图结果。</p><h1 id="2020-7-6学习笔记–线性模型"><a href="#2020-7-6学习笔记–线性模型" class="headerlink" title="2020.7.6学习笔记–线性模型"></a>2020.7.6学习笔记–线性模型</h1><p>今天开始接触了线性代数的模型和整数规划模型，有点偏数学概念了，比较难以消化；</p><p><strong>数学规划是运筹学的一个重要分支</strong>，而线性规划又是数学规划中的一部分主要内容。</p><p>整个步骤大致分为：</p><p>1、问题分析；</p><p>2、模型假设；</p><p>3、符号说明；</p><p>4、模型建立；</p><p>5、模型的求解与分析</p><p>6、可行解、可行域；</p><p>7、灵敏度分析；</p><p>通过几个案例很好的阐述了这样一个过程，比如4-5使用python软件计算6个产地8个销地的最小运费问题；</p><p>从决策变量的取值范围来看，整数规划通常可以分为以下几种类型：</p><p>1、纯整数规划；</p><p>2、混合整数规划；</p><p>3、0-1整数规划：主要用于<strong>指派问题、分配任务问题</strong>；</p><h1 id="2020-7-7学习笔记–非线性模型"><a href="#2020-7-7学习笔记–非线性模型" class="headerlink" title="2020.7.7学习笔记–非线性模型"></a>2020.7.7学习笔记–非线性模型</h1><p>今天主要学习非线性规划和多目标规划模型</p><p>​        ==线性规划==的最优解存在，但最优解只能在可行域的边界上达到（特别是在可行域的顶点上达到），且求出的是全局最优解。但是==非线性规划==却没有这样好的性质，其最优解(如果存在)可能在可行域的任意一点达到，而一般非线性规划算法给出的也只能是局部最优解，不能保证是全局最优解。</p><p>​        非线性规划目前还没有适合各种问题的一般算法，各个算法都有其特定的适用范围； </p><p>​        罚函数法：把约束非线性规划问题转化一系列无约束非线性规划问题求解；</p><p>​        定义在有限凸集上的有限个凸函数的非负线性组合仍为凸函数；</p><p>​        ==solver=‘CVXOPT’==进行优化；</p><p>能用图片表示的就不用表格；</p><p>能用表格描述就不用文字描述；</p><p>必须要做灵敏度分析；</p><p>Markowitz建议风险可以用收益的方差(或标准差)来衡量：方差越大，风险越大；在一定条件下，这种方法来衡量风险是合适的；</p><p>于是，一种股票收益的均值衡量的是这种股票的平均收益状况,而收益的方差衡量的是这种股票收益的波动幅度，方差越大则波动越大，收益越不稳定。两种股票收益的协方差表示的则是它们之间的相关程度:<br>1)协方差为0时两者不相关。<br>2)协方差为正表示两者正相关，协方差越大则正相关性越强(越有可能一赚兼赚，一赔俱赔)</p><h1 id="2020-7-8学习笔记–图论算法"><a href="#2020-7-8学习笔记–图论算法" class="headerlink" title="2020.7.8学习笔记–图论算法"></a>2020.7.8学习笔记–图论算法</h1><p>图论模型是数学建模中常见又重要的一个模型，近几十年来发展的十分活跃，因为图本身的特性，大量的最优化问题都可以抽象成网络模型结构来加以解释、描述和求解。它在建模时，具有直观、易理解、适应性强等特点，已被广泛用于各个领域；</p><p>图重要有以下属性：</p><p>1、顶点 （+ 顶点位置）</p><p>2、边</p><p>3、权值</p><p>在有向图中，从顶点v引出的弧的数目称为v的出度，记为,从顶点v引入的弧的数目称为v的入度；</p><p>对于图的展示，需要用到networkx库的draw函数；</p><p><img src="https://tacotuesdayyy.oss-cn-shenzhen.aliyuncs.com/umg/image-20200710160333279.png" alt="image-20200710160333279"></p><p>图包括很多算法， 用于解决不同类型的问题：</p><p>1、最短路径算法：找出途中两个顶点之间的最短路径，常用于解决很多实际的优化问题；该问题下同样可以使用到整数规划、0-1规划模型来解决问题；</p><p>2、最小生成树：常用破圈法来求生成树</p><p>3、关键路径</p><p>4、Dijkstra算法：</p><p>5、Floyd算法；</p><p>论文写作表述越齐全越好</p><p>出弧入弧问题</p><p>写论文一定要写清楚，有时候评委不看题，论文三分写，七分改；</p><p>论文有闪光点</p><p><strong>管道订购和运输问题</strong></p><p>2000数学建模竞赛问题</p><p>要不不供货，供货就要&gt;500并且&lt;最大数量Si</p><p>15个铺设结点   ；</p><p>1、根据钢管厂生产额能力约束或购买限制</p><p>{0}∪[1000,2000]</p><p>2、配送量==需求量，配送量和小于储备量</p><p>3、</p><p>4、非负约束</p><p>把非线性约束转化为线性约束</p><p><img src="https://tacotuesdayyy.oss-cn-shenzhen.aliyuncs.com/umg/image-20200708111351959.png" alt="image-20200708111351959"></p><p>分支定界</p><p><img src="https://tacotuesdayyy.oss-cn-shenzhen.aliyuncs.com/umg/image-20200708111517144.png" alt="image-20200708111517144"></p><p><img src="https://tacotuesdayyy.oss-cn-shenzhen.aliyuncs.com/umg/image-20200708111814321.png" alt="image-20200708111814321"></p><p><img src="https://tacotuesdayyy.oss-cn-shenzhen.aliyuncs.com/umg/image-20200708111850965.png" alt="image-20200708111850965"></p><p><img src="https://tacotuesdayyy.oss-cn-shenzhen.aliyuncs.com/umg/image-20200708112007295.png" alt="image-20200708112007295"></p><p><img src="https://tacotuesdayyy.oss-cn-shenzhen.aliyuncs.com/umg/image-20200708112122257.png" alt="image-20200708112122257"></p><p><img src="https://tacotuesdayyy.oss-cn-shenzhen.aliyuncs.com/umg/image-20200708112313232.png" alt="image-20200708112313232"></p><p>零阶矩阵结点一个个输入</p><p>python输入比较方便，发现错误很容易修正；</p><p>能打括号的就打括号；</p><p><img src="https://tacotuesdayyy.oss-cn-shenzhen.aliyuncs.com/umg/image-20200708111733509.png" alt="image-20200708111733509"></p><p>数据处理很重要！！！</p><p>现学现卖！！！</p><h1 id="2020-7-9学习笔记–多元统计分析"><a href="#2020-7-9学习笔记–多元统计分析" class="headerlink" title="2020.7.9学习笔记–多元统计分析"></a>2020.7.9学习笔记–多元统计分析</h1><p>今天学的多元统计分析，处理多变量问题，变量多-&gt;处理问题复杂，信息重叠；</p><p>一种“降维”的思维方式，跟信息的相关性也有很大的关系；</p><p>拿一个椭圆，a趋近于无穷大和b趋近于无穷大作比较；</p><p>都是对矩阵的运算，矩阵的迹，矩阵的特征向量等；</p><p>在研究实际问题时，主体成分分析的步骤大概可归纳为：</p><p>1、将原始数据标准化；</p><p>2、建立变量的相关系数矩阵；</p><p>3、求特征向量、特征根；</p><p>4、由累计方差贡献率确定主成分的个数；</p><p>软件主要使用SPSS进行主成分分析，因子分析；</p><p>分析主要跟金融、经济的分析相关，课上的例题消化，代码在计算机上实现；</p><h1 id="2020-7-10学习笔记–回归分析"><a href="#2020-7-10学习笔记–回归分析" class="headerlink" title="2020.7.10学习笔记–回归分析"></a>2020.7.10学习笔记–回归分析</h1><p>今天学的回归分析主要分析事物之间的相关性，得到变量之间的数量变化规律并加以总结反映；</p><p>回归分析主要与线性模型有着很大的联系；</p><p>整个过程大概分以下几部分：<br>1、选择回归模型和回归方程；</p><p>2、回归方程的参数估计和检验；</p><p>3、回归判断</p><p>4、模型验证；</p><p>参数一般用最小二乘法估计；</p><p>多重共线性太强同样导致很多问题：比如回归系数标准误差的估计偏大，造成回归系数置信区间增大，回归系数的准确性和稳定性降低，回归系数检验的结果不显著等；</p><p>经典最小二乘回归，有模型假设，数据未必满足假设，大多数情况下存在多重共线性，需要进行变量选择;</p><p>主成分回归和偏最小二乘回归，不需要考虑多重共线性，不需要进行变量选择，最终是所有变量进入模型。</p><p>当样本量少，变量多且存在多重共线性，且多对多回归时，偏最小二乘回归更有优势。</p><h1 id="2020-7-11学习笔记–论文研读"><a href="#2020-7-11学习笔记–论文研读" class="headerlink" title="2020.7.11学习笔记–论文研读"></a>2020.7.11学习笔记–论文研读</h1><p>如何有收获的研读一篇优秀论文</p><p>取长补短 分工明确  强强联手</p><p>研究生建模论文： 30+页；</p><p>学习数学模型的描述; (目 标，约束条件)<br>学习模型的建立和求解(算法)<br>试着用求得的数据解释实际问题(量变→质变)</p><p>今天主要讲的<strong>资源优化配置</strong>，如何优化现有资源，合理配置，以便更好地服务社会；—-选址问题</p><p>大学校园：教师、宿舍、食堂、体育场……</p><p>社会上：银行网点、快递中心、物流中心、出租车、地铁公交站、基站、学校、医院、110网点、119消防站、商业中心、超市、餐馆、WC、理发店…..</p><p>常用的<strong>数学工具</strong>：</p><p>微积分、微分方程、线性代数、概率统计、图论…..</p><p>0-1规划、多目标规划….</p><p><strong>数学书</strong>：</p><p>高等数学、线性代数、线性规划、概率论与数理统计、图论、运筹学……</p><p><strong>常见算法</strong>：<br>最优化类算法：遗传/拟退火/神经网络<br>规划类算法：线性/整数/多元/二次规划…..<br>图论算法：网络流、二分图、最短路<br>计算机算法：动态规划/回溯搜索/分治/分枝界定…..<br>数据处理算法：数据拟合/参数估计/插值/蒙特卡罗/禁忌搜索/粒子群/聚类/蚁群/层次分析/数值分析/图像处理/网格化/离散化/穷举…..</p><p>熟悉并分类算法，求适用性；</p><p>步骤：</p><p>1、遇到问题；</p><p>2、处理问题；</p><p>3、提炼问题；</p><p>4、解决问题（建模）；</p><p>5、求解问题（算法）；</p><h2 id="从论文中学到什么内容？"><a href="#从论文中学到什么内容？" class="headerlink" title="从论文中学到什么内容？"></a>从论文中学到什么内容？</h2><ol><li><strong>找</strong>：找出文中所建立的数学模型，思考自己队建立新的模型；</li><li><strong>读</strong>：读懂文中模型的求解算法（不唯一），试着用其它算法去求解；</li><li><strong>悟</strong>：找出作者队要回答的问题是否得到了较理想的结果；</li><li><strong>用</strong>：是否能对所得到的结果给出可靠性的分析说明；</li><li><strong>思</strong>：如果让我们自己完成，我们会怎么做？</li></ol><p><strong>110警车配置及巡逻方案</strong></p><p>阅读优秀论文的意义：<br>1、学会重述问题（经得起查重）</p><p>2、如何让论文有闪光灯，在几千个队中脱颖而出</p><p>3、怎么选关键词</p><p>4、好的模型、好的结果、独特的思路、好的算法、好的排版；</p><h1 id="2020-7-12学习笔记–智能算法"><a href="#2020-7-12学习笔记–智能算法" class="headerlink" title="2020.7.12学习笔记–智能算法"></a>2020.7.12学习笔记–智能算法</h1><p>今天主要学的智能算法，对于现代优化算法，可以解决诸多实际问题；</p><p><strong>盲目搜索</strong>：搜索过程中不改变搜索策略，比如：DFS、BFS等等</p><p><strong>启发式搜索</strong>：对搜索过程中的信息进行处理，用来改进搜索策略，找最优化；比如：爬山法、模拟退火、遗传、粒子群、蚁群等；</p><p>贪心算法：以迭代进行寻优；很多启发式算法本质上就是贪心算法+随机算法</p><h2 id="1、爬山法-HC"><a href="#1、爬山法-HC" class="headerlink" title="1、爬山法 HC"></a>1、爬山法 HC</h2><p>​        一种局部择优的贪心搜索算法,其本质上是梯度下降法。该算法每次从当前的节点开始，与周围的邻接点进行比较:若当前节点是最大的,那么返回当前节点作为最大值；若当前节点是较小的,就用最大的邻接点替换当前节点,从而实现不断向山峰的高处攀爬,如此循环往复,直到达到最高点为止；</p><p>​        该算法的主要问题:对初始解(状态)敏感,容易陷入局部最优,即某个节点会比周围任何一个邻接点都大,但这只是局部最优解,并非全局最优解。</p><p><img src="https://tacotuesdayyy.oss-cn-shenzhen.aliyuncs.com/umg/image-20200713110821315.png" alt=""></p><p>起始点的选择非常重要；</p><p>优点：快速收敛于局部最优解；</p><p>缺点：遇到平台无所事从；</p><h2 id="2、随机游走算法-RW"><a href="#2、随机游走算法-RW" class="headerlink" title="2、随机游走算法 RW"></a>2、随机游走算法 RW</h2><p>​    一个操作简单,但是不易陷入局部极小值的方法。是局部搜索算法中最简单的一个,它的基本策略就是每次从当前候选解的邻居中选择一个    更优的进行转移。在二维世界里,如果你一直这样随机游走下去,你还是可能到达你的目的地的,但是如果是三维世界,概率就很低了。维度越高,概率越低；</p><p><strong>起始点</strong>和<strong>步长</strong>对于随机选择算法来说是非常重要！！！</p><p><strong>步长</strong>和<strong>迭代次数</strong>的越大，自然精度越高，所需要的时间也会增加！具体设定要参考特定的应用场所，如果是自动驾驶，要求反应时间很快，那么就不能设大；</p><p>​    基本的随机游走算法对于初始点比较敏感，可以看出 ,当初始点位于最优点附近时,可以很好地达到全局最优点;如果将初始点设置得离最优点较远,则容易陷入局部最优,不一定能达到全局最优点。<br>​    当增大迭代次数以及初始步长之后,函数最终达到了全局最优点。但是迭代次数增加的代价则是运行时间的增加。总得来说，基本的随机游走算法可以很好地达到全局最优点,但是有时会依赖于初始点的选择。</p><p><strong>改进的随机游走算法</strong>：</p><p>不同之处在于第三步：原来是产生一个随机向量u，现在是产生m个随机向量u1，u2….um改进之后随机游走算法的<strong>寻优能力大大提高</strong>，而且对于初始值的依赖程度也降低了；</p><p><strong>python库：scikit-opt库，包含常用现代优化算法</strong></p><h2 id="3、粒子群算法PSO"><a href="#3、粒子群算法PSO" class="headerlink" title="3、粒子群算法PSO"></a>3、粒子群算法PSO</h2><p>群智能算法，通过<strong>模拟鸟群捕食行为</strong>来设计；</p><p>​    假设区域里只有一块食物(即最优解),鸟群的任务是找到这个食物。鸟群在搜寻的过程中相互传递信息,互相告知各自的位置,通过这样的协作，每只 鸟可判断自己找到的是不是最优解,同时也将最优解传递给整个鸟群，最终,整个鸟群都能聚集在食物周围,即找到了最优解；</p><p>​    粒子群算法用粒子来模拟鸟群中的鸟,即用粒子代表问题的可能解,每个粒子在搜索空间中单独的搜寻最优解,通过粒子个体的简单行为和群体内的信息交互,实现了问题求解的智能性。</p><p><strong>粒子具有两个属性:速度和位置</strong>；速度代表移动的快慢，位置代表移动的方向。</p><p>❗ <strong>关键问题</strong>：是个性(个体认知)体现多一点，还是更服从团队(社会认知)！！</p><p>每个粒子每次搜索得到的最优解，记为当前粒子的<strong>个体极值</strong>；然后将此个体极值与整个粒子群里的其他粒子共享，找出最优的个体极值，作为整个粒子群的当前全局最优解。所有粒子根据自己的个体极值和整个粒子群共享的当前全局最优解来不断调整自己的速度和位置。</p><p><img src="https://tacotuesdayyy.oss-cn-shenzhen.aliyuncs.com/umg/image-20200713170920596.png" alt="image-20200713170920596"></p><p>算法流程：</p><p>1、初始化；C1，C2∈[0,4]</p><p>2、根据目标函数计算每个粒子的适应值；</p><p>3、更新粒子的速度</p>]]></content>
    
    <summary type="html">
    
      记录下从7月5日开始，我参加湖南大学数学建模培训课程所做的笔记、收获和心得
    
    </summary>
    
    
      <category term="数学建模" scheme="http://Luweir.github.io/categories/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/"/>
    
    
  </entry>
  
  <entry>
    <title>数学建模培训第四题</title>
    <link href="http://luweir.github.io/2020/07/10/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E5%9F%B9%E8%AE%AD%E7%AC%AC%E5%9B%9B%E9%A2%98/"/>
    <id>http://luweir.github.io/2020/07/10/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E5%9F%B9%E8%AE%AD%E7%AC%AC%E5%9B%9B%E9%A2%98/</id>
    <published>2020-07-10T02:51:00.000Z</published>
    <updated>2020-11-06T16:09:01.968Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>已知95个目标点的数据见Excel文件data6.xlsx，第1列是这95个点的编号，第2,3列是这95个点的坐标，第4列是这些点重要性分类，标明“1”的是第一类重要目标点，标明“2”的是第二类重要目标点，未标明类别的是一般目标点，第5，6，7标明了这些点的连接关系。</p><p><img src="https://tacotuesdayyy.oss-cn-shenzhen.aliyuncs.com/umg/image-20200709105449816.png" alt="image-20200709105449816"></p><p><img src="https://tacotuesdayyy.oss-cn-shenzhen.aliyuncs.com/umg/image-20200709105654721.png" alt="image-20200709105654721"></p><p><img src="https://tacotuesdayyy.oss-cn-shenzhen.aliyuncs.com/umg/image-20200709105706908.png" alt="image-20200709105706908"></p><p>如第三行的数据，表示顶点C的坐标为（-1160，587.5），它是一般目标点，C点和D点相连，C点也和F点相连。</p><h1 id="三个问题"><a href="#三个问题" class="headerlink" title="三个问题"></a>三个问题</h1><p>（1）画出上面的无向图，一类重要目标点用“五角星”画出，二类重要点用“*”画出，一般目标点用“.”画出。要求必须画出无向图的度量图，顶点的位置坐标必须准确，不要画出无向图的拓扑图。</p><p>（2）当权重为距离时，求上面无向图的最小生成树，并画出最小生成树。</p><p>（3）求顶点L到顶点R3的最短距离及最短路径，并画出最短路径。</p><h1 id="问题求解"><a href="#问题求解" class="headerlink" title="问题求解"></a>问题求解</h1><p><strong>坐标、无向、顶点类别、度量图</strong></p><p>待解决的问题：</p><ul><li><input checked="" disabled="" type="checkbox"> 点的坐标表示；</li><li><input checked="" disabled="" type="checkbox"> 点的类别判断；</li><li><input checked="" disabled="" type="checkbox"> 不同颜色不同形状点的设置；</li><li><input disabled="" type="checkbox"> 度量图/拓扑图；</li></ul><p>参考文章：</p><p>1、<a href="https://blog.csdn.net/weixin_38246633/article/details/85342109" target="_blank" rel="noopener">networkx.draw()详解</a></p><p>2、<a href="https://www.cnblogs.com/gispathfinder/p/5790949.html" target="_blank" rel="noopener">网络分析之networkx（转载）</a></p><p>3、<a href="https://blog.csdn.net/qq_40357974/article/details/95590230?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase" target="_blank" rel="noopener">使用networkx绘制带节点坐标图（节点、节点坐标和边）</a></p><p>4、<a href="https://blog.csdn.net/baidu_37995814/article/details/94006280?utm_medium=distribute.pc_relevant.none-task-blog-baidujs-3" target="_blank" rel="noopener">得到不同颜色和节点形状的网络结构图</a></p><h2 id="第一问："><a href="#第一问：" class="headerlink" title="第一问："></a>第一问：</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: gb2312 -*-</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cvxpy <span class="keyword">as</span> cp</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> networkx <span class="keyword">as</span> nx</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1、使用pandas读取excel表格文件，避免一个个输入数据</span></span><br><span class="line">df=pd.read_excel(<span class="string">r'F:\Users\Administrator\Desktop\data6.xlsx'</span>)</span><br><span class="line"><span class="comment"># 2、将df中的顶点列转化成列表nodes</span></span><br><span class="line">nodes=df.顶点.tolist()</span><br><span class="line"><span class="comment"># 3、创建一个空的无向图G</span></span><br><span class="line">G=nx.Graph()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4、给所有结点根据重要性标识分类</span></span><br><span class="line"><span class="comment"># 5、node1表示第1类结点</span></span><br><span class="line"><span class="comment">#node2表示第2类结点</span></span><br><span class="line"><span class="comment">#    node表示一般结点</span></span><br><span class="line">node1 = []</span><br><span class="line">node2 = []</span><br><span class="line">node = []</span><br><span class="line"></span><br><span class="line"><span class="comment"># vnode1表示第1类结点坐标</span></span><br><span class="line"><span class="comment"># vnode2表示第2类结点坐标</span></span><br><span class="line"><span class="comment"># vnode 表示一般结点坐标  </span></span><br><span class="line"><span class="comment"># vnode存放所有结点坐标</span></span><br><span class="line">vnode1 = []</span><br><span class="line">vnode2 = []</span><br><span class="line">vnode = []</span><br><span class="line">vnodes = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(df)):</span><br><span class="line">    vnodes.append(df[[<span class="string">'x坐标'</span>, <span class="string">'y坐标'</span>]].values[i])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (df.顶点类别[i] == <span class="number">1</span>):</span><br><span class="line">        node1.append(df.loc[i, <span class="string">'顶点'</span>])</span><br><span class="line">        vnode1.append(df[[<span class="string">'x坐标'</span>, <span class="string">'y坐标'</span>]].values[i])</span><br><span class="line">    <span class="keyword">if</span> (df.顶点类别[i] == <span class="number">2</span>):</span><br><span class="line">        node2.append(df.loc[i, <span class="string">'顶点'</span>])</span><br><span class="line">        vnode2.append(df[[<span class="string">'x坐标'</span>, <span class="string">'y坐标'</span>]].values[i])</span><br><span class="line">    <span class="keyword">if</span> (df.顶点类别.isnull()[i]):</span><br><span class="line">        node.append(df.loc[i, <span class="string">'顶点'</span>])</span><br><span class="line">        vnode.append(df[[<span class="string">'x坐标'</span>, <span class="string">'y坐标'</span>]].values[i])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 6、把nodes存入G中</span></span><br><span class="line">G.add_nodes_from(nodes)</span><br><span class="line"><span class="comment"># 7、获取结点与坐标之间的映射关系，用字典表示;</span></span><br><span class="line">npos1 = dict(zip(node1,vnode1))</span><br><span class="line">npos2 = dict(zip(node2,vnode2))</span><br><span class="line">npos = dict(zip(node,vnode))</span><br><span class="line">pos=dict(zip(nodes,vnodes))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 8、标志字典，构件结点与表示点之间的关系</span></span><br><span class="line">nlabels = dict(zip(nodes, nodes))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 9、edges中存放所有的边</span></span><br><span class="line">edges = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(df)):</span><br><span class="line">    <span class="comment"># 如果有相邻的顶点，就把把这条边加入到edges中</span></span><br><span class="line">    <span class="keyword">if</span> df[<span class="string">'相邻的顶点1'</span>].notnull()[i]:</span><br><span class="line">        edges.append([df.loc[i, <span class="string">'顶点'</span>], df.loc[i, <span class="string">'相邻的顶点1'</span>]])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> df[<span class="string">'相邻的顶点2'</span>].notnull()[i]:</span><br><span class="line">        edges.append([df.loc[i, <span class="string">'顶点'</span>], df.loc[i, <span class="string">'相邻的顶点2'</span>]])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> df[<span class="string">'相邻的顶点3'</span>].notnull()[i]:</span><br><span class="line">        edges.append([df.loc[i, <span class="string">'顶点'</span>], df.loc[i, <span class="string">'相邻的顶点3'</span>]])</span><br><span class="line">        </span><br><span class="line"><span class="comment"># 绘制坐标轴</span></span><br><span class="line">x_max=df[<span class="string">'x坐标'</span>].max()</span><br><span class="line">y_max=df[<span class="string">'y坐标'</span>].max()</span><br><span class="line">x_min=df[<span class="string">'x坐标'</span>].min()</span><br><span class="line">y_min=df[<span class="string">'y坐标'</span>].min()</span><br><span class="line"></span><br><span class="line">x_num = (x_max - x_min) / <span class="number">10</span></span><br><span class="line">y_num = (y_max - y_min) / <span class="number">10</span></span><br><span class="line"></span><br><span class="line">fig,ax = plt.subplots()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 10、按点的类边绘制无向图，</span></span><br><span class="line">nx.draw_networkx_nodes(G,npos1,nodelist=node1,node_shape=<span class="string">'p'</span>,node_size=<span class="number">50</span>) <span class="comment">#绘制顶点</span></span><br><span class="line">nx.draw_networkx_nodes(G,npos2,nodelist=node2,node_shape=<span class="string">'*'</span>,node_size=<span class="number">50</span>) <span class="comment">#绘制顶点</span></span><br><span class="line">nx.draw_networkx_nodes(G,npos,nodelist=node,node_shape=<span class="string">'.'</span>,node_size=<span class="number">50</span>) <span class="comment">#绘制顶点</span></span><br><span class="line">nx.draw_networkx_edges(G,pos,edges) <span class="comment"># 绘制边</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># nx.draw_networkx_labels(G, pos, nlabels)  # 添加标签</span></span><br><span class="line"><span class="comment"># 注释x轴y轴</span></span><br><span class="line">plt.xlabel(<span class="string">'x'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'y'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加坐标系</span></span><br><span class="line">plt.xlim((x_min - x_num, x_max + x_num))</span><br><span class="line">plt.ylim((y_min - y_num, y_max + y_num))</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>最终无向图如下：<br><img src="https://tacotuesdayyy.oss-cn-shenzhen.aliyuncs.com/umg/image-20200710124855614.png" alt="image-20200710124855614" style="zoom:1200%;" /></p><p>注解：</p><p>1、第一步中只用pandas读取的表格数据如下：</p><p><img src="https://tacotuesdayyy.oss-cn-shenzhen.aliyuncs.com/umg/image-20200710000903683.png" alt="image-20200710000903683"></p><p>2、第5步得到的各类结点以及对应坐标如图所示</p><p><img src="https://tacotuesdayyy.oss-cn-shenzhen.aliyuncs.com/umg/image-20200710102726326.png" alt="三类顶点"></p><p><img src="https://tacotuesdayyy.oss-cn-shenzhen.aliyuncs.com/umg/image-20200710102902025.png" alt="所有顶点的坐标"></p><p>3、edges如图所示：</p><p><img src="https://tacotuesdayyy.oss-cn-shenzhen.aliyuncs.com/umg/image-20200710103004131.png" alt="image-20200710103004131"></p><p>4、pos，即各个顶点的坐标如图所示：</p><p><img src="https://tacotuesdayyy.oss-cn-shenzhen.aliyuncs.com/umg/image-20200710103634834.png" alt="image-20200710103634834"></p><h2 id="第二问："><a href="#第二问：" class="headerlink" title="第二问："></a>第二问：</h2><p>第二问参考的例题6-12 </p><p><img src="https://tacotuesdayyy.oss-cn-shenzhen.aliyuncs.com/umg/image-20200710125053894.png" alt="image-20200710125053894"></p><p>每条边的权值都是两点间的距离，但这一题由于点的位置都存放在表格中，所以我们只能通过表格来获取点的坐标，再平方和开根号，算出存在边的两个点之间的距离：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: gb2312 -*-</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> networkx <span class="keyword">as</span> nx</span><br><span class="line"><span class="keyword">import</span> pylab <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> cvxpy <span class="keyword">as</span> cp</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="comment"># 1、前面这部分同第一问</span></span><br><span class="line">df=pd.read_excel(<span class="string">r'F:\Users\Administrator\Desktop\建模培训\四次作业\data6.xlsx'</span>)</span><br><span class="line">G=nx.Graph()</span><br><span class="line"></span><br><span class="line">node1 = []</span><br><span class="line">node2 = []</span><br><span class="line">node = []</span><br><span class="line">nodes = []</span><br><span class="line"></span><br><span class="line">vnode1 = []</span><br><span class="line">vnode2 = []</span><br><span class="line">vnode = []</span><br><span class="line">vnodes = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(df)):</span><br><span class="line">    nodes.append(df.loc[i, <span class="string">'顶点'</span>])</span><br><span class="line">    vnodes.append(df[[<span class="string">'x坐标'</span>, <span class="string">'y坐标'</span>]].values[i])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (df.顶点类别[i] == <span class="number">1</span>):</span><br><span class="line">        node1.append(df.loc[i, <span class="string">'顶点'</span>])</span><br><span class="line">        vnode1.append(df[[<span class="string">'x坐标'</span>, <span class="string">'y坐标'</span>]].values[i])</span><br><span class="line">    <span class="keyword">if</span> (df.顶点类别[i] == <span class="number">2</span>):</span><br><span class="line">        node2.append(df.loc[i, <span class="string">'顶点'</span>])</span><br><span class="line">        vnode2.append(df[[<span class="string">'x坐标'</span>, <span class="string">'y坐标'</span>]].values[i])</span><br><span class="line">    <span class="keyword">if</span> (df.顶点类别.isnull()[i]):</span><br><span class="line">        node.append(df.loc[i, <span class="string">'顶点'</span>])</span><br><span class="line">        vnode.append(df[[<span class="string">'x坐标'</span>, <span class="string">'y坐标'</span>]].values[i])</span><br><span class="line"></span><br><span class="line">G.add_nodes_from(nodes)</span><br><span class="line"><span class="comment"># 获取结点与坐标之间的映射关系，用字典表示</span></span><br><span class="line">npos1 = dict(zip(node1,vnode1))</span><br><span class="line">npos2 = dict(zip(node2,vnode2))</span><br><span class="line">npos = dict(zip(node,vnode))</span><br><span class="line">pos=dict(zip(nodes,vnodes))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 存放所有的边，构成无向图</span></span><br><span class="line">edges = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(df)):</span><br><span class="line">    <span class="comment"># 如果有相邻的顶点</span></span><br><span class="line">    <span class="keyword">if</span> df[<span class="string">'相邻的顶点1'</span>].notnull()[i]:</span><br><span class="line">        edges.append([df.loc[i, <span class="string">'顶点'</span>], df.loc[i, <span class="string">'相邻的顶点1'</span>]])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> df[<span class="string">'相邻的顶点2'</span>].notnull()[i]:</span><br><span class="line">        edges.append([df.loc[i, <span class="string">'顶点'</span>], df.loc[i, <span class="string">'相邻的顶点2'</span>]])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> df[<span class="string">'相邻的顶点3'</span>].notnull()[i]:</span><br><span class="line">        edges.append([df.loc[i, <span class="string">'顶点'</span>], df.loc[i, <span class="string">'相邻的顶点3'</span>]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2、开始计算两点之间的权重，用L存放所有的带权重边</span></span><br><span class="line">L=[]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(edges)):</span><br><span class="line">    a=edges[i][<span class="number">0</span>]  <span class="comment"># 第一个点</span></span><br><span class="line">    b=edges[i][<span class="number">1</span>]  <span class="comment"># 第二个点</span></span><br><span class="line">    x1=pos[a][<span class="number">0</span>]  <span class="comment"># a点横坐标</span></span><br><span class="line">    x2=pos[a][<span class="number">1</span>]  <span class="comment"># a点纵坐标</span></span><br><span class="line">    y1=pos[b][<span class="number">0</span>]  <span class="comment"># b点横坐标</span></span><br><span class="line">    y2=pos[b][<span class="number">1</span>]  <span class="comment"># b点纵坐标</span></span><br><span class="line">    temp=(a,b,math.sqrt(math.pow(x1-x2,<span class="number">2</span>)+math.pow(y1-y2,<span class="number">2</span>))) <span class="comment"># 求两点之间距离</span></span><br><span class="line">    L.append(temp) </span><br><span class="line"></span><br><span class="line">G.add_weighted_edges_from(L) <span class="comment"># 将L加入G中</span></span><br><span class="line">T = nx.minimum_spanning_tree(G)  <span class="comment"># 返回可迭代对象</span></span><br><span class="line">c = nx.to_numpy_matrix(T)  <span class="comment"># 返回最小生成树的邻接矩阵</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出邻接矩阵</span></span><br><span class="line">cdf=pd.DataFrame(c)</span><br><span class="line">cdf.to_excel(<span class="string">r"work4Data.xlsx"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 求最小生成树的权重</span></span><br><span class="line">w = c.sum() / <span class="number">2</span>  </span><br><span class="line">print(<span class="string">"最小生成树的权重:\n w = "</span>,w) </span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据图的拉普拉斯特征向量排列各节点</span></span><br><span class="line">pos=nx.spectral_layout(G)</span><br><span class="line"><span class="comment"># 3、最小生成树绘制</span></span><br><span class="line"></span><br><span class="line">nx.draw_networkx_nodes(G,pos,nodelist=node1,node_shape=<span class="string">'p'</span>,node_size=<span class="number">50</span>) <span class="comment">#绘制顶点</span></span><br><span class="line">nx.draw_networkx_nodes(G,pos,nodelist=node2,node_shape=<span class="string">'*'</span>,node_size=<span class="number">50</span>) <span class="comment">#绘制顶点</span></span><br><span class="line">nx.draw_networkx_nodes(G,pos,nodelist=node,node_shape=<span class="string">'.'</span>,node_size=<span class="number">50</span>) <span class="comment">#绘制顶点</span></span><br><span class="line">nx.draw_networkx_edges(T,pos,with_labels=<span class="literal">True</span>,font_weight=<span class="string">"bold"</span>)</span><br><span class="line">w2=nx.get_edge_attributes(T,<span class="string">'weight'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4、添加标签 （透明度为0.8 数字大小为2）</span></span><br><span class="line"><span class="comment"># nx.draw_networkx_edge_labels(T,pos,edge_labels=w2,alpha=0.8,font_size=2)  </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 5、保存图片</span></span><br><span class="line">plt.savefig(<span class="string">'figure4-2 最小生成树图形'</span>,dpi=<span class="number">1000</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>最终结果如下：</p><p><img src="https://tacotuesdayyy.oss-cn-shenzhen.aliyuncs.com/umg/image-20200710131656654.png" alt="image-20200710131656654"></p><p>不显示标签（权值）最小生成树为：</p><p><img src="https://tacotuesdayyy.oss-cn-shenzhen.aliyuncs.com/umg/image-20200710131805230.png" alt="image-20200710131805230"></p><p>显示标签（权值）最小生成树为：</p><p><img src="https://tacotuesdayyy.oss-cn-shenzhen.aliyuncs.com/umg/20200710131913.png" alt=""></p><p>注解：</p><p>1、第2步计算各点之间的距离，部分结果如图所示</p><p><img src="https://tacotuesdayyy.oss-cn-shenzhen.aliyuncs.com/umg/image-20200710131319360.png" alt="image-20200710131319360"></p><p>2、<strong>邻接矩阵c</strong>的部分数据如图所示</p><p><img src="https://tacotuesdayyy.oss-cn-shenzhen.aliyuncs.com/umg/image-20200710131545865.png" alt="image-20200710131545865"></p>]]></content>
    
    <summary type="html">
    
      记录做数学建模培训第四题的过程和心得
    
    </summary>
    
    
      <category term="数学建模" scheme="http://Luweir.github.io/categories/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/"/>
    
    
  </entry>
  
  <entry>
    <title>数学建模培训第二题</title>
    <link href="http://luweir.github.io/2020/07/09/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E5%9F%B9%E8%AE%AD%E7%AC%AC%E4%BA%8C%E9%A2%98/"/>
    <id>http://luweir.github.io/2020/07/09/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E5%9F%B9%E8%AE%AD%E7%AC%AC%E4%BA%8C%E9%A2%98/</id>
    <published>2020-07-09T01:43:00.000Z</published>
    <updated>2020-11-06T16:09:13.756Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>已知某物资有8个配送中心可以供货，有15个部队用户需要该物资，配送中心和部队用户之间单位物资的运费，15个部队用户的物资需求量和8个配送中心的物资储备量数据见表1。    </p><p>​                                                                  表1  配送中心和部队用户之间单位物资的运费和物资需求量、储备量数据</p><p><img src="https://tacotuesdayyy.oss-cn-shenzhen.aliyuncs.com/umg/image-20200709095703981.png" alt=" 表1  配送中心和部队用户之间单位物资的运费和物资需求量、储备量数据"> </p><h1 id="两个问题"><a href="#两个问题" class="headerlink" title="两个问题"></a>两个问题</h1><p>（1）根据题目给定的数据，求最小运费调用计划。</p><p>（2）若每个配送中心，可以对用户配送物资，也可以不对用户配送物资；若配送物资的话，<strong>配送量要大于等于1000且小于等于2000</strong>，求此时的费用最小调用计划。</p><h1 id="求解过程"><a href="#求解过程" class="headerlink" title="求解过程"></a>求解过程</h1><h2 id="第一问："><a href="#第一问：" class="headerlink" title="第一问："></a>第一问：</h2><p>第一问虽然不难，但第一次上手这类题目，要注意行列不要搞混；</p><p>贴上代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cvxpy <span class="keyword">as</span> cp</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="comment"># 从data4_5_1.txt中获得数据，c(15,8)代表整个运费数据；</span></span><br><span class="line">c=np.genfromtxt(<span class="string">"data4_5_1.txt"</span>,dtype=float,max_rows=<span class="number">15</span>,usecols=range(<span class="number">8</span>))</span><br><span class="line">d=np.genfromtxt(<span class="string">"data4_5_1.txt"</span>,dtype=float,max_rows=<span class="number">15</span>,usecols=<span class="number">8</span>) <span class="comment"># 取第9列，即15个用户的需求量</span></span><br><span class="line">e=np.genfromtxt(<span class="string">"data4_5_1.txt"</span>,dtype=float,skip_header=<span class="number">15</span>) <span class="comment"># 跳过15行，取第16行，取8个配送中心得储备量</span></span><br><span class="line"><span class="comment"># x(15,8)为未知量，X[i,j]代表配送中心j配送给用户i的量;</span></span><br><span class="line">x=cp.Variable((<span class="number">15</span>,<span class="number">8</span>),pos=<span class="literal">True</span>)</span><br><span class="line"><span class="comment"># Minimize表示求得最优解，存放于obj中</span></span><br><span class="line">obj=cp.Minimize(cp.sum(cp.multiply(c,x)))</span><br><span class="line"><span class="comment"># con列表存放各种限制条件</span></span><br><span class="line">con=[cp.sum(x,axis=<span class="number">0</span>,keepdims=<span class="literal">True</span>)&lt;=e.reshape(<span class="number">1</span>,<span class="number">8</span>), <span class="comment"># axis=0按列求和，各列之和要小于对应配送中心的储备量</span></span><br><span class="line">     cp.sum(x,axis=<span class="number">1</span>,keepdims=<span class="literal">True</span>)==d.reshape(<span class="number">15</span>,<span class="number">1</span>)] <span class="comment"># axis=1按行求和，各行之和要等于(或者大于)对应用户的需求量</span></span><br><span class="line"><span class="comment"># 构建问题</span></span><br><span class="line">prob=cp.Problem(obj,con)</span><br><span class="line"><span class="comment"># 使用GLPK_MI对问题进行求解</span></span><br><span class="line">prob.solve(solver=<span class="string">'GLPK_MI'</span>)</span><br><span class="line"><span class="comment"># 输出最小运费</span></span><br><span class="line">print(<span class="string">"最优值为："</span>,prob.value)</span><br><span class="line"><span class="comment"># 输出最小运费方案（即x)</span></span><br><span class="line">print(<span class="string">"最优解为：\n"</span>,x.value)l+l</span><br><span class="line"><span class="comment"># 将x数据保存至表格中</span></span><br><span class="line">xd=pd.DataFrame(x.value)</span><br><span class="line">xd.to_excel(<span class="string">"data4_5_2.xlsx"</span>)</span><br></pre></td></tr></table></figure><p>结果：</p><p><img src="https://tacotuesdayyy.oss-cn-shenzhen.aliyuncs.com/umg/image-20200709102639445.png" alt="image-20200709102639445"></p><p>一开始就是<strong>搞混了d，e所代表得含义</strong>，从而导致约束条件那里出问题，结果显示无解！</p><p>Notice：</p><p>1、cp.Variable()参数中：pos=True表示x的所有元素为正，integer=True表示x的所有元素为整数；</p><h2 id="第二问："><a href="#第二问：" class="headerlink" title="第二问："></a>第二问：</h2><p>第二问一开始考虑比较欠缺，直接用0，1模型来做，发现在con约束条件那里行不通！</p><p>随后放弃0，1模型，直接对x进行约束，同样得不到正确结果，因为这样的约束是对x的所有取值而言的；</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">con=[x&gt;=<span class="number">1000</span>,x&lt;=<span class="number">2000</span>,</span><br><span class="line">     cp.sum(x,axis=<span class="number">0</span>,keepdims=<span class="literal">True</span>)&lt;=e.reshape(<span class="number">1</span>,<span class="number">8</span>),</span><br><span class="line">     cp.sum(x,axis=<span class="number">1</span>,keepdims=<span class="literal">True</span>)&gt;=d.reshape(<span class="number">15</span>,<span class="number">1</span>) ]</span><br></pre></td></tr></table></figure><p>当设定x&gt;=1000后，结果x中所有元素的最小值就要是1000，就会得到这样的结果；</p><p><img src="https://tacotuesdayyy.oss-cn-shenzhen.aliyuncs.com/umg/image-20200709102709057.png" alt="image-20200709102709057"></p><p>显然这是不符合条件的，所以下一步我就想到能不能这样约束x：</p><p><code>x==0 or (x&gt;=1000 and x&lt;=2000)</code>这样的话x就能取0或者[1000,2000]里面的值，就能求出最优解了；</p><p>但遗憾的是结果报错，反复实验几次后请教司守奎老师，了解到con列表中的各元素之间都是与的关系，并且元素不能为元组，所以这个方法亦行不通；</p><p>经过这么久，我就只能得到一个不符合条件但接近最优解的结果：</p><p><img src="https://tacotuesdayyy.oss-cn-shenzhen.aliyuncs.com/umg/image-20200709103140217.png" alt="image-20200709103140217"></p><p>显然这里的900不符合[1000,2000]的范围；</p><p>在学完第六节的钢管运输问题后，这道题目就有些思路了，我可以利用==整数模型和线性模型结合的办法==，令<strong>矩阵T [ i , j ]表示配送中心 j 是否对用户 i 进行配送</strong>，而<strong>X[ i , j ]依旧表示配送中心 j 配送各用户 i 的量</strong>，这样T 和 X 就有着对应关系，T[i,j]为0，那么配送了必为0，T[i,j]为1，那么配送量就限制在[1000,2000]之间；</p><p>这样的话最终得到的X矩阵必满足条件：<code>1000*T&lt;=X&lt;=2000*T</code></p><p>贴上代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cvxpy <span class="keyword">as</span> cp</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">c=np.genfromtxt(<span class="string">"data4_5_1.txt"</span>,dtype=float,max_rows=<span class="number">15</span>,usecols=range(<span class="number">8</span>))</span><br><span class="line">d=np.genfromtxt(<span class="string">"data4_5_1.txt"</span>,dtype=float,max_rows=<span class="number">15</span>,usecols=<span class="number">8</span>) </span><br><span class="line">e=np.genfromtxt(<span class="string">"data4_5_1.txt"</span>,dtype=float,skip_header=<span class="number">15</span>) </span><br><span class="line"></span><br><span class="line">x=cp.Variable((<span class="number">15</span>,<span class="number">8</span>),pos=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 8个配送中心，每次配送给用户的量都要在1000和2000之间，用于建立0，1模型;</span></span><br><span class="line">t=cp.Variable((<span class="number">15</span>,<span class="number">8</span>),integer=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">obj=cp.Minimize(cp.sum(cp.multiply(c,x)))</span><br><span class="line"></span><br><span class="line">con=[x&gt;=<span class="number">1000</span>*t,</span><br><span class="line">     x&lt;=<span class="number">2000</span>*t,</span><br><span class="line">     t&gt;=<span class="number">0</span>,t&lt;=<span class="number">1</span>,x&gt;=<span class="number">0</span>,</span><br><span class="line">     cp.sum(x,axis=<span class="number">0</span>,keepdims=<span class="literal">True</span>)&lt;=e.reshape(<span class="number">1</span>,<span class="number">8</span>),</span><br><span class="line">     cp.sum(x,axis=<span class="number">1</span>,keepdims=<span class="literal">True</span>)&gt;=d.reshape(<span class="number">15</span>,<span class="number">1</span>)]</span><br><span class="line"></span><br><span class="line">prob=cp.Problem(obj,con)</span><br><span class="line">prob.solve(solver=<span class="string">'GLPK_MI'</span>)</span><br><span class="line">print(<span class="string">"最优值为："</span>,prob.value)</span><br><span class="line">print(<span class="string">"最优解为：\n"</span>,x.value)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出t</span></span><br><span class="line">print(<span class="string">"题解t：\n"</span>,t.value)</span><br><span class="line"></span><br><span class="line">xd=pd.DataFrame(x.value)</span><br><span class="line">xd.to_excel(<span class="string">"data4_5_2.xlsx"</span>)</span><br></pre></td></tr></table></figure><p>得到最优解：</p><p><img src="https://tacotuesdayyy.oss-cn-shenzhen.aliyuncs.com/umg/image-20200709104214516.png" alt="image-20200709104214516"></p><p>具体的建模过程还得参照我组大佬的文档，我这只是代码实现部分！</p>]]></content>
    
    <summary type="html">
    
      写下完成数学建模培训第二题的一点思路
    
    </summary>
    
    
      <category term="数学建模" scheme="http://Luweir.github.io/categories/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/"/>
    
    
  </entry>
  
  <entry>
    <title>Mr.L的工具栏</title>
    <link href="http://luweir.github.io/2020/07/04/Mr.L%E7%9A%84%E5%B7%A5%E5%85%B7%E6%A0%8F/"/>
    <id>http://luweir.github.io/2020/07/04/Mr.L%E7%9A%84%E5%B7%A5%E5%85%B7%E6%A0%8F/</id>
    <published>2020-07-03T23:52:00.000Z</published>
    <updated>2020-11-06T16:17:13.319Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、初始必备"><a href="#一、初始必备" class="headerlink" title="一、初始必备"></a>一、初始必备</h1><p>1、百度云</p><p>各种软件、电子书、教程都存在百度云！</p><p>2、Google浏览器 + 书签 + 相关插件</p><p>时常备份百度云书签以及插件、换设备时不用重新开始；</p><p>3、清理工具：Ccleaner</p><p>麻雀虽小、五脏俱全，清理强大，无广告！</p><p>4、文件搜索工具：Everything</p><p>速度是自带搜索的n倍以上</p><h1 id="二、文档类工具"><a href="#二、文档类工具" class="headerlink" title="二、文档类工具"></a>二、文档类工具</h1><p>1、WPS </p><p>各设备平台同步，超大云空间；</p><p><strong>文档阅读、标注都在云文档上完成</strong>，方便同步；不要保存在本地(除非要发送至他人)！</p><p>2、Office 2016 </p><p>写论文啥的要用word，比wps稳定；</p><p>3、Typora + PicGo </p><p>写markdown文档以及图床工具(使用的阿里云)；</p><p>4、Subline Text3 </p><p>查看各种类型的代码；</p><p>5、Xmind</p><p>构件思维导图；</p><h1 id="三、编程类工具"><a href="#三、编程类工具" class="headerlink" title="三、编程类工具"></a>三、编程类工具</h1><p>1、Vscode</p><p>暂且用它来刷Leetcode等算法题；轻便、五脏俱全；</p><p>2、pycharm</p><p>3、Anaconda</p><p>4、IntelliJ IDEA</p><p>5、Matlab</p><p>6、Git</p><h1 id="四、剪辑类工具"><a href="#四、剪辑类工具" class="headerlink" title="四、剪辑类工具"></a>四、剪辑类工具</h1><p>1、PS</p><p>2、PR</p><h1 id="五、其它工具"><a href="#五、其它工具" class="headerlink" title="五、其它工具"></a>五、其它工具</h1><p>1、To Do</p><p>任务清单神奇、Windows多平台同步；</p><p>2、Fiddler</p><p>抓包神器，抓一些网站上的视频啥的；</p><p>3、Mathpix Snipping </p><p>截图识别公式，直接粘贴在文档中</p><h1 id="六、耳机"><a href="#六、耳机" class="headerlink" title="六、耳机"></a>六、耳机</h1><p>1、有线耳机– 索尼MH750</p><p>2、无线耳机–Airpods</p>]]></content>
    
    <summary type="html">
    
      备份下我的常用工具（存放于百度云），换设备的时候提高效率
    
    </summary>
    
    
      <category term="个人" scheme="http://Luweir.github.io/categories/%E4%B8%AA%E4%BA%BA/"/>
    
    
      <category term="Mark" scheme="http://Luweir.github.io/tags/Mark/"/>
    
  </entry>
  
  <entry>
    <title>A Module</title>
    <link href="http://luweir.github.io/2020/07/04/A%20Module/"/>
    <id>http://luweir.github.io/2020/07/04/A%20Module/</id>
    <published>2020-07-03T23:37:00.000Z</published>
    <updated>2020-11-06T16:10:04.167Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>安装cvxpy包</title>
    <link href="http://luweir.github.io/2020/07/03/%E5%AE%89%E8%A3%85cvspy%E5%8C%85/"/>
    <id>http://luweir.github.io/2020/07/03/%E5%AE%89%E8%A3%85cvspy%E5%8C%85/</id>
    <published>2020-07-03T15:04:20.822Z</published>
    <updated>2020-11-06T16:14:58.254Z</updated>
    
    <content type="html"><![CDATA[<p>下载压缩包：链接：<a href="https://pan.baidu.com/s/1wxMO5IN0R9S8fZnoGv75XQ" target="_blank" rel="noopener">https://pan.baidu.com/s/1wxMO5IN0R9S8fZnoGv75XQ</a>  ；提取码：svrc</p><p>注意版本要对应，我用的python3.7.2；不同版本参考这篇文章：<a href="https://blog.csdn.net/qq_36477513/article/details/104779850" target="_blank" rel="noopener">Python下载安装第三方库cvxpy包</a></p><p><strong>1、将压缩包解压(记住解压的位置，我是解压到的桌面)</strong></p><p><img src="https://tacotuesdayyy.oss-cn-shenzhen.aliyuncs.com/umg/image-20200703153111851.png" alt="image-20200703153111851"></p><p>里面是这些文件：</p><p><img src="https://tacotuesdayyy.oss-cn-shenzhen.aliyuncs.com/umg/image-20200703153134772.png" alt="image-20200703153134772"></p><p><strong>2、在文件所在的文件夹中打开DOC界面（win10直接在当前文件夹空白处按住shift，右键打开powershell窗口）</strong></p><h2 id=""><a href="#" class="headerlink" title=""></a><img src="https://tacotuesdayyy.oss-cn-shenzhen.aliyuncs.com/umg/image-20200703153318636.png" alt="image-20200703153318636"></h2><p>然后依次安装下列包</p><p><img src="https://tacotuesdayyy.oss-cn-shenzhen.aliyuncs.com/umg/image-20200703153749989.png" alt="image-20200703153749989"></p><p>在命令行中依次输入<code>pip install xxxxx.whl</code>  </p><p>xxxxx.whl就是上面说的包的全名！ 一定要复制全名 加后缀；</p><p>类似这个：</p><p><img src="https://tacotuesdayyy.oss-cn-shenzhen.aliyuncs.com/umg/image-20200703154007070.png" alt="image-20200703154007070"></p><p>每安装一个 下面就有进度，成功的话最后一句是<code>successfully installed  xxxxx-xx</code></p><p>最后安装cvxpy后</p><p><img src="https://tacotuesdayyy.oss-cn-shenzhen.aliyuncs.com/umg/image-20200703154149223.png" alt="image-20200703154149223"></p><p><strong>3、在win + R ，输入cmd</strong></p><p> 然后再命令行中先输入 <code>python</code> 再输入<code>import cvxpy</code></p><p>如果是下面这样 则表示成功；</p><p><img src="https://tacotuesdayyy.oss-cn-shenzhen.aliyuncs.com/umg/image-20200703154413352.png" alt="image-20200703154413352"></p><p>失败的话它会显示 <strong>找不到 名字为cvspy的module</strong>windows下安装pandoc并通过Typora导出pdf和word详细攻略</p>]]></content>
    
    <summary type="html">
    
      安装python库cvspy
    
    </summary>
    
    
      <category term="环境配置" scheme="http://Luweir.github.io/categories/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
    
    
      <category term="Python" scheme="http://Luweir.github.io/tags/Python/"/>
    
      <category term="Cvxpy" scheme="http://Luweir.github.io/tags/Cvxpy/"/>
    
  </entry>
  
  <entry>
    <title>Google浏览器安装Google访问助手</title>
    <link href="http://luweir.github.io/2020/07/03/Google%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AE%89%E8%A3%85%E8%AE%BF%E9%97%AE%E5%8A%A9%E6%89%8B/"/>
    <id>http://luweir.github.io/2020/07/03/Google%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AE%89%E8%A3%85%E8%AE%BF%E9%97%AE%E5%8A%A9%E6%89%8B/</id>
    <published>2020-07-03T15:04:13.944Z</published>
    <updated>2020-11-06T16:09:23.557Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1、下载Google浏览器和访问助手"><a href="#1、下载Google浏览器和访问助手" class="headerlink" title="1、下载Google浏览器和访问助手"></a>1、下载Google浏览器和访问助手</h1><p>在链接中下载Google浏览器和Google访问助手；</p><p>链接：<a href="https://pan.baidu.com/s/1nn6SbqSLwvVhkOSVocTUzg" target="_blank" rel="noopener">https://pan.baidu.com/s/1nn6SbqSLwvVhkOSVocTUzg</a> ；提取码：zbdo；</p><h1 id="2、解压"><a href="#2、解压" class="headerlink" title="2、解压"></a>2、解压</h1><p>安装Google浏览器，将下载好的Google访问助手<strong>后缀 crx 改成 rar</strong></p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly90YWNvdHVlc2RheXl5Lm9zcy1jbi1zaGVuemhlbi5hbGl5dW5jcy5jb20vdW1nL2ltYWdlLTIwMjAwNzAyMjI0NjAyMjk0LnBuZw?x-oss-process=image/format,png" alt="image-20200702224602294"></p><p>在桌面新建一个文件夹；</p><p>然后打开Google访问助手进行解压，将里面的<strong>所有文件解压到桌面的新建文件夹</strong>中；</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly90YWNvdHVlc2RheXl5Lm9zcy1jbi1zaGVuemhlbi5hbGl5dW5jcy5jb20vdW1nL2ltYWdlLTIwMjAwNzAyMjI0ODI4MjEyLnBuZw?x-oss-process=image/format,png" alt="image-20200702224828212"></p><h1 id="3、Google浏览器加载"><a href="#3、Google浏览器加载" class="headerlink" title="3、Google浏览器加载"></a>3、Google浏览器加载</h1><p>在Google浏览器中打开<strong>扩展程序</strong></p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly90YWNvdHVlc2RheXl5Lm9zcy1jbi1zaGVuemhlbi5hbGl5dW5jcy5jb20vdW1nL2ltYWdlLTIwMjAwNzAyMjI1MjUwNTQwLnBuZw?x-oss-process=image/format,png" alt="image-20200702225250540"></p><p>点击 <strong>加载已解压的扩展程序</strong></p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly90YWNvdHVlc2RheXl5Lm9zcy1jbi1zaGVuemhlbi5hbGl5dW5jcy5jb20vdW1nL2ltYWdlLTIwMjAwNzAyMjI1NTEzNjkzLnBuZw?x-oss-process=image/format,png" alt="image-20200702225513693"></p><p>然后选择<strong>桌面的新建文件夹</strong>！</p><p>然后就加载成功了</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly90YWNvdHVlc2RheXl5Lm9zcy1jbi1zaGVuemhlbi5hbGl5dW5jcy5jb20vdW1nL2ltYWdlLTIwMjAwNzAyMjI1NTU1NTM3LnBuZw?x-oss-process=image/format,png" alt="image-20200702225555537"></p><h1 id="4、永久激活"><a href="#4、永久激活" class="headerlink" title="4、永久激活"></a>4、永久激活</h1><p>安装成功后打开新页面会自动弹出这个界面，提示永久激活！</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly90YWNvdHVlc2RheXl5Lm9zcy1jbi1zaGVuemhlbi5hbGl5dW5jcy5jb20vdW1nL2ltYWdlLTIwMjAwNzAyMjI1OTUzMTAyLnBuZw?x-oss-process=image/format,png" alt="image-20200702225953102"></p><p>点击永久免费激活；</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly90YWNvdHVlc2RheXl5Lm9zcy1jbi1zaGVuemhlbi5hbGl5dW5jcy5jb20vdW1nL2ltYWdlLTIwMjAwNzAyMjMwMDQwNDY1LnBuZw?x-oss-process=image/format,png" alt="image-20200702230040465"></p><p>前往选项页面设置；</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly90YWNvdHVlc2RheXl5Lm9zcy1jbi1zaGVuemhlbi5hbGl5dW5jcy5jb20vdW1nL2ltYWdlLTIwMjAwNzAyMjMwMTAwNzkyLnBuZw?x-oss-process=image/format,png" alt="image-20200702230100792"></p><p>点击自动打开主页，随便选一个即可；</p><p>然后重启浏览器，就会以你刚刚设置的为主页，并且有以下提示；</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly90YWNvdHVlc2RheXl5Lm9zcy1jbi1zaGVuemhlbi5hbGl5dW5jcy5jb20vdW1nL2ltYWdlLTIwMjAwNzAyMjMwMTUxNjcxLnBuZw?x-oss-process=image/format,png" alt="image-20200702230151671"></p><p>不要停用就行了！</p><h1 id="Notice"><a href="#Notice" class="headerlink" title="Notice"></a>Notice</h1><p>这个文件夹不可以删除！删除了扩展程序就没了！<br>如果觉得放桌面碍眼，就放你自己指定的文件夹，然后重新添加扩展一遍就行了！</p>]]></content>
    
    <summary type="html">
    
      下载并加载Google访问助手
    
    </summary>
    
    
      <category term="软件&amp;&amp;工具" scheme="http://Luweir.github.io/categories/%E8%BD%AF%E4%BB%B6-%E5%B7%A5%E5%85%B7/"/>
    
    
  </entry>
  
  <entry>
    <title>明天冲乐高机器人面试</title>
    <link href="http://luweir.github.io/2020/07/03/%E6%98%8E%E5%A4%A9%E5%86%B2%E4%B9%90%E9%AB%98%E6%9C%BA%E5%99%A8%E4%BA%BA%E9%9D%A2%E8%AF%95/"/>
    <id>http://luweir.github.io/2020/07/03/%E6%98%8E%E5%A4%A9%E5%86%B2%E4%B9%90%E9%AB%98%E6%9C%BA%E5%99%A8%E4%BA%BA%E9%9D%A2%E8%AF%95/</id>
    <published>2020-07-03T15:04:00.000Z</published>
    <updated>2020-11-06T16:12:00.894Z</updated>
    
    <content type="html"><![CDATA[<p>​    Boss直聘的信息还是比智联的靠谱，明天上午10：30去福中福应聘乐高机器人编程老师，人生第一次面试！<a id="more"></a>哈哈哈哈！可能也没多正规，也不一定会看简历，反正就上吧，就要求C++和python嘛，也看看机器人是怎么玩的；</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;​    Boss直聘的信息还是比智联的靠谱，明天上午10：30去福中福应聘乐高机器人编程老师，人生第一次面试！
    
    </summary>
    
    
      <category term="个人" scheme="http://Luweir.github.io/categories/%E4%B8%AA%E4%BA%BA/"/>
    
    
      <category term="Feeling" scheme="http://Luweir.github.io/tags/Feeling/"/>
    
  </entry>
  
  <entry>
    <title>Back from JiangSu</title>
    <link href="http://luweir.github.io/2020/07/02/Back%20from%20JiangSu/"/>
    <id>http://luweir.github.io/2020/07/02/Back%20from%20JiangSu/</id>
    <published>2020-07-02T15:15:02.000Z</published>
    <updated>2020-11-06T16:11:11.953Z</updated>
    
    <content type="html"><![CDATA[<p>​    今天从江苏回益阳，挺累的；一路上睡了很久，也思考了很久；大概就是想些最近的事吧；<a id="more"></a>先是人工智能的那个竞赛，我们组是在线试衣系统，目前在攻克生成1：1线上模型的解决方案；然后就是华为杯数学建模的比赛，暂时处于培训阶段，准备先把这些资料弄熟吧，跟着培训的进度，有人指点总有好处；然后就是自己又想在Github上找些项目做，在深度学习方向有所进展，读研也要跟着导师走这条路的；最后还想自己赚钱，先赚小几千跟YLL出去旅个游吧，不求经济独立，只求有些收入；</p><p>​    事是有点多奥，还有驾照的事，十来号就要考科三了，这几天得抓紧练，一次过了啥都好说！慢慢来吧，事多急也没用，反而容易啥都干不好；</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;​    今天从江苏回益阳，挺累的；一路上睡了很久，也思考了很久；大概就是想些最近的事吧；
    
    </summary>
    
    
      <category term="个人" scheme="http://Luweir.github.io/categories/%E4%B8%AA%E4%BA%BA/"/>
    
    
      <category term="Feeling" scheme="http://Luweir.github.io/tags/Feeling/"/>
    
  </entry>
  
  <entry>
    <title>位运算的巧妙之处</title>
    <link href="http://luweir.github.io/2020/06/30/%E4%BD%8D%E8%BF%90%E7%AE%97%E7%9A%84%E5%B7%A7%E5%A6%99%E4%B9%8B%E5%A4%84/"/>
    <id>http://luweir.github.io/2020/06/30/%E4%BD%8D%E8%BF%90%E7%AE%97%E7%9A%84%E5%B7%A7%E5%A6%99%E4%B9%8B%E5%A4%84/</id>
    <published>2020-06-30T05:59:59.000Z</published>
    <updated>2020-11-06T16:04:11.674Z</updated>
    
    <content type="html"><![CDATA[<h1 id="位运算的巧妙之处"><a href="#位运算的巧妙之处" class="headerlink" title="位运算的巧妙之处"></a>位运算的巧妙之处</h1><p>算法中，位运算可以巧妙运用在一下几个方面：</p><p>1、判断奇偶数  =&gt;  x&amp;1</p><p>2、判断数x中第k ( 从右至左 ) 位是1还是0  </p><p>法1：<code>( x &gt;&gt; ( k - 1 ) ) &amp; 1</code></p><p><img src="https://tacotuesdayyy.oss-cn-shenzhen.aliyuncs.com/umg/aHR0cHM6Ly90YWNvdHVlc2RheXl5Lm9zcy1jbi1zaGVuemhlbi5hbGl5dW5jcy5jb20vdW1nLzIwMjAwNTE4MjEyNDI0LnBuZw" alt="img"></p><p>法2：<code>x &amp; ( 1 &lt;&lt; ( k - 1 ) )</code></p><p>3、交换两个整数变量 a , b 的值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = a ^ b;</span><br><span class="line">b = b ^ a;</span><br><span class="line">a = a ^ b;</span><br></pre></td></tr></table></figure><p>这里为什么能这样做，在后面的异或运算中会说明；</p><p>4、不用判断语句，求整数绝对值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> (value ^ (value &gt;&gt; <span class="number">31</span>))-(value &gt;&gt;<span class="number">31</span>)</span><br></pre></td></tr></table></figure><p>同样在异或运算中说明；</p><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><h3 id="二进制中1的个数"><a href="#二进制中1的个数" class="headerlink" title="二进制中1的个数"></a>二进制中1的个数</h3><p><strong>描述</strong>：实现一个函数，输入一个正整数，输出该数二进制表示中1的个数。</p><p>例：9的二进制表示为1001，有2位是1；</p><p><strong>思路</strong>：循环运用判断x的第k位是否为1的方法；</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly90YWNvdHVlc2RheXl5Lm9zcy1jbi1zaGVuemhlbi5hbGl5dW5jcy5jb20vdW1nL0NBQ0E3QjlEOTBFNEI3MEFFMUE0RTE1RUI2RkY4RENCLnBuZw?x-oss-process=image/format,png" alt=""></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(value)</span><br><span class="line">&#123;</span><br><span class="line">count += value &amp; <span class="number">1</span>;</span><br><span class="line">value = value &gt;&gt; <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> count;</span><br></pre></td></tr></table></figure><p>方法二：</p><p>&amp;运算有这样一个性质：a = ( a - 1 ) &amp; a ； 这样a就能<strong>消除最低位的一个1</strong>；</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly90YWNvdHVlc2RheXl5Lm9zcy1jbi1zaGVuemhlbi5hbGl5dW5jcy5jb20vdW1nL0UwOTA3MzlDMkFEQzIwN0Q2OTEzMTBDRUZBMDQ0NzM5LnBuZw?x-oss-process=image/format,png" alt=""></p><p>思路：利用这一性质，我们可以每次将value-1，然后与自己&amp;，能做多少次这样的操作就说明有多少个1；</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(value)</span><br><span class="line">&#123;</span><br><span class="line">value = (value - <span class="number">1</span>) &amp; value;</span><br><span class="line">count++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> count;</span><br></pre></td></tr></table></figure><h1 id="异或运算的巧妙之处"><a href="#异或运算的巧妙之处" class="headerlink" title="异或运算的巧妙之处"></a>异或运算的巧妙之处</h1><h2 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h2><p>异或又称不进位加法，两个数相异或，对应位相同则为0，不同则为1；</p><p>具有以下性质：</p><p>1、a ^ a = 0；</p><p>2、0 ^ a = a；</p><p>3、异或具有交换律和结合律</p><pre><code>b ^ c = c ^ b；a ^ b ^ c = a ^ ( b ^ c) = ( a ^ b ) ^ c；</code></pre><p>4、( -1 ) ^ a =！a;</p><h2 id="应用-1"><a href="#应用-1" class="headerlink" title="应用"></a>应用</h2><h3 id="交换两个变量的值"><a href="#交换两个变量的值" class="headerlink" title="交换两个变量的值"></a>交换两个变量的值</h3><p>交换变量a,b的值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = a ^ b;</span><br><span class="line">b = b ^ a;</span><br><span class="line">a = a ^ b;</span><br></pre></td></tr></table></figure><p>利用异或运算的交换律和结合律，可以得到如下：</p><p>1、a = a ^ b;</p><p>2、b = b ^ a;</p><p>把1式代入2式中，此时 b = b ^ ( a ^ b ) ，则 b = b ^ b ^ a = a;</p><p>3、a = a ^ b;</p><p>将1式和 b = a 代入3式，则 a = a ^ b ^ a = b;</p><h3 id="不用判断语句，求整数绝对值"><a href="#不用判断语句，求整数绝对值" class="headerlink" title="不用判断语句，求整数绝对值"></a>不用判断语句，求整数绝对值</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> (value ^ (value &gt;&gt; <span class="number">31</span>))-(value &gt;&gt;<span class="number">31</span>)</span><br></pre></td></tr></table></figure><p>1、若value为正数，则value二进制表示中最高位一定为0，那么 value &gt;&gt; 31 =0;</p><p>value ^ (value &gt;&gt; 31) = value ^ 0 = value;</p><p>value - (value &gt;&gt; 31) = value - 0 = value;</p><p>即正数的绝对值仍是自身；</p><p>2、若value为负数，则value二进制表示中最高位一定为1，那么 value &gt;&gt; 31 = 111…1 ,一共32个1，即-1；</p><p>value ^ (value &gt;&gt; 31) = ! value;</p><p>而负数以补码形式存放，==补码等于绝对值的原码取反+1==；</p><p>那么这里 ! value - (value &gt;&gt; 31) =&gt; ! value +1 即得到的是value的绝对值；</p><p>如果理解有困难，可以看这个例子：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly90YWNvdHVlc2RheXl5Lm9zcy1jbi1zaGVuemhlbi5hbGl5dW5jcy5jb20vdW1nLzA2N0M4MUQ0RTkzRTQwMDY1REZEODU4M0VGOTYxQkVBLnBuZw?x-oss-process=image/format,png" alt=""></p><h3 id="如何找唯一成对的数？"><a href="#如何找唯一成对的数？" class="headerlink" title="如何找唯一成对的数？"></a>如何找唯一成对的数？</h3><p><strong>问题描述</strong>：1-1000这1000个数放在含有1001个元素的数组中，只有唯一的一个元素值重复，其它均只出现一次。每个数组元素只能访问一次，在不用辅助存储空间的前提下，设计一个算法，将它找出来；</p><p><strong>思路</strong>：根据异或性质1： a ^ a = 0；可以用来==去重==；</p><p>令T = 1 ^ 2 ^ 3 ^….. ^ 1000 ；</p><p>那么遍历数组的同时将当前数字与 T 异或，在数组中只出现一次的数字会与 T 中的该数字相抵消，从而去重；最终会剩下重复的那个元素，因为它在数组和T中一共出现3次；</p><p>举一个只有11个数的例子：         重复的元素在任意位置出现都是可以找出来的；</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly90YWNvdHVlc2RheXl5Lm9zcy1jbi1zaGVuemhlbi5hbGl5dW5jcy5jb20vdW1nLzA0NDlCNzNDOTc1QzE5MkE1OUIzREU1OTBEQzAyODNDLnBuZw?x-oss-process=image/format,png" alt=""></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> T=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">1000</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">T=T^i;      </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">1000</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">T=T^A[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> T;</span><br></pre></td></tr></table></figure><p>如有错误，感谢指正！</p>]]></content>
    
    <summary type="html">
    
      深入了解位运算并使用它解决问题
    
    </summary>
    
    
      <category term="算法" scheme="http://Luweir.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="Algorithm" scheme="http://Luweir.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>十大经典排序算法C++实现及总结</title>
    <link href="http://luweir.github.io/2020/06/30/%E5%8D%81%E5%A4%A7%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95C-%E5%AE%9E%E7%8E%B0%E5%8F%8A%E6%80%BB%E7%BB%93/"/>
    <id>http://luweir.github.io/2020/06/30/%E5%8D%81%E5%A4%A7%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95C-%E5%AE%9E%E7%8E%B0%E5%8F%8A%E6%80%BB%E7%BB%93/</id>
    <published>2020-06-30T05:58:23.000Z</published>
    <updated>2020-11-06T16:13:18.757Z</updated>
    
    <content type="html"><![CDATA[<h1 id="算法性能总结"><a href="#算法性能总结" class="headerlink" title="算法性能总结"></a>算法性能总结</h1><p><img src="https://img-blog.csdnimg.cn/20200510135640764.jpeg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3d5bGwxOTk4MDgxMg==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h1 id="1、冒泡排序"><a href="#1、冒泡排序" class="headerlink" title="1、冒泡排序"></a>1、冒泡排序</h1><p><img src="https://img-blog.csdnimg.cn/20200510140633159.gif#pic_center" alt="在这里插入图片描述"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1、Bubble Sort 冒泡排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (length &lt; <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length - <span class="number">1</span>; i++) <span class="comment">//需length-1趟排序确定后length-1个数，剩下第一个数不用排序；</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; length - <span class="number">1</span> - i; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[j + <span class="number">1</span>] &lt; a[j])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> temp = a[j + <span class="number">1</span>];</span><br><span class="line">                a[j + <span class="number">1</span>] = a[j];</span><br><span class="line">                a[j] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="2、选择排序"><a href="#2、选择排序" class="headerlink" title="2、选择排序"></a>2、选择排序</h1><p><img src="https://img-blog.csdnimg.cn/20200510140552757.gif#pic_center" alt="在这里插入图片描述"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//2、Select Sort 选择排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">selectSort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (length &lt; <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> minIndex = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; length; j++) <span class="comment">//已确定a[0]~a[i-1],从i-1开始查找最小的数，然后与a[i]交换位置；</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[j] &lt; a[minIndex])</span><br><span class="line">                minIndex = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> temp = a[i];</span><br><span class="line">        a[i] = a[minIndex];</span><br><span class="line">        a[minIndex] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="3、插入排序"><a href="#3、插入排序" class="headerlink" title="3、插入排序"></a>3、插入排序</h1><p><img src="https://img-blog.csdnimg.cn/20200510140706474.jpg#pic_center" alt="在这里插入图片描述"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//3、Insert Sort 插入排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertSort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (length &lt; <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; length; i++) <span class="comment">//现在进行插入的是a[i]</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> cur = a[i];</span><br><span class="line">        <span class="keyword">int</span> j = i;</span><br><span class="line">        <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; a[j - <span class="number">1</span>] &gt; cur) <span class="comment">//如果前面的数比cur大，说明cur要插在它们前面，即将它们后移一个位置；</span></span><br><span class="line">        &#123;</span><br><span class="line">            a[j] = a[j - <span class="number">1</span>];</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        a[j] = cur;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="4、希尔排序"><a href="#4、希尔排序" class="headerlink" title="4、希尔排序"></a>4、希尔排序</h1><p><img src="https://img-blog.csdnimg.cn/20200510141025753.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3d5bGwxOTk4MDgxMg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//4、Shell Sort 希尔排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shellSort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (length &lt; <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> gap = length / <span class="number">2</span>; <span class="comment">//整个数组分为gap个组，即每隔 gap-1 个位置的元素为一组</span></span><br><span class="line">    <span class="keyword">while</span> (gap &gt; <span class="number">0</span>)       <span class="comment">//最终整个数组分为一组 即所有元素为一组；</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = gap; i &lt; length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> cur = a[i];</span><br><span class="line">            <span class="keyword">int</span> preIndex = i - gap;</span><br><span class="line">            <span class="keyword">while</span> (preIndex &gt;= <span class="number">0</span> &amp;&amp; a[preIndex] &gt; cur) <span class="comment">//对每一组元素进行插入排序</span></span><br><span class="line">            &#123;</span><br><span class="line">                a[i] = a[preIndex];</span><br><span class="line">                preIndex -= gap;</span><br><span class="line">            &#125;</span><br><span class="line">            a[preIndex + gap] = cur;</span><br><span class="line">        &#125;</span><br><span class="line">        gap /= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="5、归并排序"><a href="#5、归并排序" class="headerlink" title="5、归并排序"></a>5、归并排序</h1><p><img src="https://img-blog.csdnimg.cn/20200510141619255.jpg#pic_center" alt="在这里插入图片描述"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//5、Merge Sort 归并排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> left, <span class="keyword">int</span> mid, <span class="keyword">int</span> right)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> <span class="comment">//  left需要排序数组 a[] 的左端下标，right为右端下标</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> length = right - left + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (length &lt; <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> mid = (right + left) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    mergeSort(a, <span class="number">0</span>, mid);</span><br><span class="line">    mergeSort(a, mid + <span class="number">1</span>, right);</span><br><span class="line">    merge(a, left, mid, right); <span class="comment">//调用merge函数 将二者合并</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> left, <span class="keyword">int</span> mid, <span class="keyword">int</span> right)</span> <span class="comment">//将数组a 的两个子数组a[left] ~ a[mid] 与 a[mid+1] ~ a[right] 合并</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = right - left + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; temp;</span><br><span class="line">    <span class="keyword">int</span> i = left, j = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; i &lt;= mid &amp;&amp; j &lt;= right;)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[i] &lt; a[j])</span><br><span class="line">        &#123;</span><br><span class="line">            temp.push_back(a[i]);</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            temp.push_back(a[j]);</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid)</span><br><span class="line">        temp.push_back(a[i++]); <span class="comment">//此时必有一个子数组没有走完 需要把剩下的元素全部放进vector</span></span><br><span class="line">    <span class="keyword">while</span> (j &lt;= right)</span><br><span class="line">        temp.push_back(a[j++]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = left, k = <span class="number">0</span>; i &lt;= right; i++) <span class="comment">//把vector中已排完序的元素存入数组a[left]~a[right]</span></span><br><span class="line">    &#123;</span><br><span class="line">        a[i] = temp[k++];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="6、快速排序"><a href="#6、快速排序" class="headerlink" title="6、快速排序"></a>6、快速排序</h1><p><img src="https://img-blog.csdnimg.cn/2020051014204349.gif#pic_center" alt="在这里插入图片描述"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//6、Quick Sort 快速排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left &gt;= right)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> key = a[left]; <span class="comment">//以第一个数为基数进行快排；</span></span><br><span class="line">    <span class="keyword">int</span> pointL = left, pointR = right;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (pointL &lt; pointR)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//一定要先动右指针，否则右指针所指向的元素无处存放</span></span><br><span class="line">        <span class="keyword">while</span> (pointR &gt; pointL &amp;&amp; a[pointR] &gt;= key) <span class="comment">//若右指针指向的元素大于key 则右指针左移，直到右指针指向的元素小于key 或者 左右指针坐标相同</span></span><br><span class="line">            pointR--;</span><br><span class="line">        a[pointL] = a[pointR]; <span class="comment">//把这个小于key的元素放到key的左边，即左指针指向的位置</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (pointR &gt; pointL &amp;&amp; a[pointL] &lt;= key) <span class="comment">//若左指针指向的元素小于key 则左指针右移，直到左指针指向的元素大于key 或者 左右指针坐标相同</span></span><br><span class="line">            pointL++;</span><br><span class="line">        a[pointR] = a[pointL]; <span class="comment">//把这个大于key的元素放到key的右边，即右指针指向的位置</span></span><br><span class="line">    &#125;</span><br><span class="line">    a[pointR] = key; <span class="comment">//此时左右指针指向同一位置，这个位置就是key应该放的位置</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//对key两边的元素同样使用快排</span></span><br><span class="line">    quickSort(a, left, pointR - <span class="number">1</span>);</span><br><span class="line">    quickSort(a, pointR + <span class="number">1</span>, right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="7、计数排序"><a href="#7、计数排序" class="headerlink" title="7、计数排序"></a>7、计数排序</h1><p><img src="https://img-blog.csdnimg.cn/20200510142135552.gif#pic_center" alt="在这里插入图片描述"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//7、Counting Sort 计数排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">countingSort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (length &lt; <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> min = a[<span class="number">0</span>], max = a[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> bios; <span class="comment">//偏移量</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) <span class="comment">//找最大最小值</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[i] &lt; min)</span><br><span class="line">            min = a[i];</span><br><span class="line">        <span class="keyword">if</span> (a[i] &gt; max)</span><br><span class="line">            max = a[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bios = <span class="number">0</span> - min;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">temp</span><span class="params">(max - min + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) <span class="comment">//把出现了的元素作为temp的下标 并置1；</span></span><br><span class="line">    &#123;</span><br><span class="line">        temp[a[i] + bios]++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; max - min + <span class="number">1</span>; i++) <span class="comment">//顺序扫描以便vector即可</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (temp[i])</span><br><span class="line">        &#123;</span><br><span class="line">            a[index++] = i - bios;</span><br><span class="line">            temp[i]--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="8、桶排序"><a href="#8、桶排序" class="headerlink" title="8、桶排序"></a>8、桶排序</h1><p><img src="https://img-blog.csdnimg.cn/20200510142409661.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3d5bGwxOTk4MDgxMg==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//8、Bucket Sort 桶排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bucketSort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (length &lt; <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> min = a[<span class="number">0</span>], max = a[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[i] &lt; min)</span><br><span class="line">            min = a[i];</span><br><span class="line">        <span class="keyword">if</span> (a[i] &gt; max)</span><br><span class="line">            max = a[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> buckNum = (max - min) / length + <span class="number">1</span>; <span class="comment">//桶的数量</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; bucketArr;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; buckNum; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; temp;</span><br><span class="line">        bucketArr.push_back(temp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//每个元素入桶</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> num = (a[i] - min) / length;</span><br><span class="line">        bucketArr[num].push_back(a[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对每个桶排序 并且排序完后赋值</span></span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bucketArr.size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (bucketArr[i].size())</span><br><span class="line">        &#123;</span><br><span class="line">            sort(bucketArr[i].begin(), bucketArr[i].end()); <span class="comment">//快排</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; bucketArr[i].size(); j++)</span><br><span class="line">            &#123;</span><br><span class="line">                a[index++] = bucketArr[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="9、基数排序"><a href="#9、基数排序" class="headerlink" title="9、基数排序"></a>9、基数排序</h1><p><img src="https://img-blog.csdnimg.cn/20200510142523884.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3d5bGwxOTk4MDgxMg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//9、Base Sort 基数排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">baseSort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> length)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//得到最大位数；</span></span><br><span class="line">    <span class="keyword">int</span> max = a[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> d = <span class="number">0</span>;<span class="comment">//最大位数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[i] &gt; max)</span><br><span class="line">            max = a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (max)</span><br><span class="line">    &#123;</span><br><span class="line">        max /= <span class="number">10</span>;</span><br><span class="line">        d++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> factor = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= d; i++) <span class="comment">//从个位数排到d位数</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; bucket[<span class="number">10</span>]; <span class="comment">//初始化十个桶</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = (a[i] / factor) % <span class="number">10</span>; <span class="comment">//得到a[i]的now_d位数，并放入对应桶中</span></span><br><span class="line">            bucket[temp].push_back(a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) <span class="comment">//遍历十个桶，按从小到大顺序放入原数组</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> size = bucket[i].size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; size; k++)</span><br><span class="line">            &#123;</span><br><span class="line">                a[j++] = bucket[i][k];</span><br><span class="line">            &#125;</span><br><span class="line">            bucket[i].clear(); <span class="comment">//桶置空</span></span><br><span class="line">        &#125;</span><br><span class="line">        factor *= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="10、堆排序"><a href="#10、堆排序" class="headerlink" title="10、堆排序"></a>10、堆排序</h1><p><img src="https://img-blog.csdnimg.cn/20200510142536785.gif#pic_center" alt="在这里插入图片描述"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//10、Heap Sort 堆排序   大顶堆做出来顺序，小顶堆做出来逆序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fixDown</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> i, <span class="keyword">int</span> length)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//先对 a 堆化</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = length / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) </span><br><span class="line">    &#123;</span><br><span class="line">        fixDown(a, i, length); <span class="comment">//把i当前小顶堆的根节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 完成后 此时a已经是合法的小顶堆</span></span><br><span class="line">    <span class="comment">//调整堆结构</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x = length - <span class="number">1</span>; x &gt; <span class="number">0</span>; x--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//把堆顶元素(0号元素)和末尾元素对调；</span></span><br><span class="line">        swap(a, <span class="number">0</span>, x);</span><br><span class="line">        <span class="comment">//缩小堆的范围，对堆顶元素进行向下调整；</span></span><br><span class="line">        fixDown(a, <span class="number">0</span>, x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fixDown</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> i, <span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//找到左右子孩子</span></span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">2</span> * i + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> right = <span class="number">2</span> * i + <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> min = left;     <span class="comment">//min指向左右孩子中较小的那个</span></span><br><span class="line">    <span class="keyword">if</span> (left &gt;= length) <span class="comment">//若左孩子越界则右孩子必越界</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (right &lt; length &amp;&amp; a[right] &lt; a[left]) <span class="comment">//右孩子未越界并且右孩子值比左孩子小</span></span><br><span class="line">        min = right;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果a[i]比这两个孩子的值都要小，则不用调整；</span></span><br><span class="line">    <span class="keyword">if</span> (a[i] &lt; a[min])</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//否则，其值和a[i]交换；</span></span><br><span class="line">    swap(a, i, min);</span><br><span class="line">    <span class="comment">//小孩子那个位置的值发生变化，i变更为小孩子的那个位置，于是递归调整；</span></span><br><span class="line">    fixDown(a, min, length);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = a[i];</span><br><span class="line">    a[i] = a[j];</span><br><span class="line">    a[j] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1、Bubble Sort 冒泡排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> length)</span></span>;</span><br><span class="line"><span class="comment">//2、Select Sort 选择排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">selectSort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> length)</span></span>;</span><br><span class="line"><span class="comment">//3、Insert Sort 插入排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertSort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> length)</span></span>;</span><br><span class="line"><span class="comment">//4、Shell Sort 希尔排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shellSort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> length)</span></span>;</span><br><span class="line"><span class="comment">//5、Merge Sort 归并排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> left, <span class="keyword">int</span> mid, <span class="keyword">int</span> right)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>;</span><br><span class="line"><span class="comment">//6、Quick Sort 快速排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>;</span><br><span class="line"><span class="comment">//7、Counting Sort 计数排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">countingSort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> length)</span></span>;</span><br><span class="line"><span class="comment">//8、Bucket Sort 桶排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bucketSort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> length)</span></span>;</span><br><span class="line"><span class="comment">//9、Base Sort 基数排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">baseSort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> length)</span></span>;</span><br><span class="line"><span class="comment">//10、Heap Sort 堆排序   大顶堆做出来顺序，小顶堆做出来逆序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fixDown</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> i, <span class="keyword">int</span> length)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">8</span>] = &#123;<span class="number">3</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">10</span>&#125;;</span><br><span class="line">    <span class="comment">// bubbleSort(a, 8);</span></span><br><span class="line">    <span class="comment">// selectSort(a,8);</span></span><br><span class="line">    <span class="comment">// insertSort(a, 8);</span></span><br><span class="line">    <span class="comment">// shellSort(a, 8);</span></span><br><span class="line">    <span class="comment">// mergeSort(a, 0, 7);</span></span><br><span class="line">    <span class="comment">// quickSort(a, 0, 7);</span></span><br><span class="line">    <span class="comment">// countingSort(a, 8);</span></span><br><span class="line">    <span class="comment">// bucketSort(a, 8);</span></span><br><span class="line">    <span class="comment">// baseSort(a, 8);</span></span><br><span class="line">    heapSort(a, <span class="number">8</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; a[i] &lt;&lt; <span class="string">' '</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如有错误，欢迎评论指正，谢谢！</p>]]></content>
    
    <summary type="html">
    
      回顾排序算法并用C++写出
    
    </summary>
    
    
      <category term="算法" scheme="http://Luweir.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="Algorithm" scheme="http://Luweir.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>多维数组和矩阵</title>
    <link href="http://luweir.github.io/2020/06/30/%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84%E5%92%8C%E7%9F%A9%E9%98%B5/"/>
    <id>http://luweir.github.io/2020/06/30/%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84%E5%92%8C%E7%9F%A9%E9%98%B5/</id>
    <published>2020-06-30T05:56:53.000Z</published>
    <updated>2020-11-06T16:03:34.854Z</updated>
    
    <content type="html"><![CDATA[<h1 id="T-1：顺时针打印二维数组"><a href="#T-1：顺时针打印二维数组" class="headerlink" title="T 1：顺时针打印二维数组"></a>T 1：顺时针打印二维数组</h1><p>这个问题看起来很容易，逻辑清晰，但实现起来还是复杂些，要考虑到不能重复打印，超出边界；</p><p><img src="https://tacotuesdayyy.oss-cn-shenzhen.aliyuncs.com/umg/6D9767219FAE9AF7C2366339F14CE90D.png" alt="img"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printMatrix</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> leftuprow = <span class="number">0</span>, leftupcol = <span class="number">0</span>, rightdownrow = a.size()<span class="number">-1</span>, rightdowncol = a[<span class="number">0</span>].size()<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">while</span> (leftuprow &lt;= rightdownrow &amp;&amp; leftupcol &lt;= rightdowncol)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> r = leftuprow;</span><br><span class="line"><span class="keyword">int</span> c = leftupcol;</span><br><span class="line"><span class="keyword">while</span> (c &lt;=rightdowncol)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a[r][c++]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line">c = rightdowncol;</span><br><span class="line">r = leftuprow+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (r &lt;= rightdownrow)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a[r++][c] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line">r = rightdownrow;</span><br><span class="line">c = rightdowncol - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (c &gt;= leftupcol)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a[r][c--]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line">c = leftupcol;</span><br><span class="line">r = rightdownrow - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (r &gt; leftuprow)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a[r--][c] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line">leftupcol++;</span><br><span class="line">leftuprow++;</span><br><span class="line">rightdowncol--;</span><br><span class="line">rightdownrow--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; test;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">12</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; temp;</span><br><span class="line"><span class="keyword">while</span> (i%<span class="number">4</span>)</span><br><span class="line">&#123;</span><br><span class="line">temp.push_back(i++);</span><br><span class="line">&#125;</span><br><span class="line">temp.push_back(i);</span><br><span class="line">test.push_back(temp);</span><br><span class="line">&#125;</span><br><span class="line">printMatrix(test);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="T-2：将0所在的行列清零"><a href="#T-2：将0所在的行列清零" class="headerlink" title="T 2：将0所在的行列清零"></a>T 2：将0所在的行列清零</h1><p> 如果矩阵中某个元素为0，则将其所在行和列清零；</p><p><img src="https://tacotuesdayyy.oss-cn-shenzhen.aliyuncs.com/umg/36A2FA5854D74B2030A76CABEBA1C05E.png" alt="img"></p><p>可能会想到，我一边遍历矩阵，遇到0就将它所在行列全部清0；</p><p>但这样存在一个问题：如果某一行有多个0，遇到第一个0，会将本行和该列清0，那么循环遍历下去，这一行剩下的都是0，会将这些本不该清0的列都清0；</p><p>思路：把每个值为0的位置标记，最后统一对它们所在的行和列清0；</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setZero</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; result;</span><br><span class="line"><span class="keyword">int</span> lenRow=a.size(),lenCol=a[<span class="number">0</span>].size();</span><br><span class="line">    </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;lenRow;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;lenCol;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(a[i][j]==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; temp;</span><br><span class="line">temp.push_back(i);</span><br><span class="line">temp.push_back(j);</span><br><span class="line">result.push_back(temp);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> r:result)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> row=r[<span class="number">0</span>],col=r[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;lenCol;i++)</span><br><span class="line">&#123;</span><br><span class="line">a[i][col]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;lenRow;i++)</span><br><span class="line">&#123;</span><br><span class="line">a[row][i]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; test;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">16</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; temp;</span><br><span class="line"><span class="keyword">while</span> (i%<span class="number">4</span>)</span><br><span class="line">&#123;</span><br><span class="line">temp.push_back(i++);</span><br><span class="line">&#125;</span><br><span class="line">temp.push_back(i);</span><br><span class="line">test.push_back(temp);</span><br><span class="line">&#125;</span><br><span class="line">test[<span class="number">1</span>][<span class="number">2</span>]=<span class="number">0</span>;</span><br><span class="line">test[<span class="number">2</span>][<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">setZero(test);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> a:test)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> aa:a)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;aa&lt;&lt;<span class="string">' '</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="T-3：Z字形打印"><a href="#T-3：Z字形打印" class="headerlink" title="T 3：Z字形打印"></a>T 3：Z字形打印</h1><p>  <img src="https://tacotuesdayyy.oss-cn-shenzhen.aliyuncs.com/umg/2C048FA071C38FA6CA1CDE0A01B7E73D.png" alt="img"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Z</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> r = <span class="number">0</span>, m = a.size();<span class="comment">//m=最大行数</span></span><br><span class="line"><span class="keyword">int</span> c = <span class="number">0</span>, n = a[<span class="number">0</span>].size();<span class="comment">//n=最大列数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> dir = <span class="literal">true</span>; <span class="comment">//控制方向，true为向上，false为向下</span></span><br><span class="line"><span class="keyword">while</span> (r &lt; m &amp;&amp; c &lt; n)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//从左下到右上，走上坡</span></span><br><span class="line"><span class="keyword">if</span> (dir)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a[r][c] &lt;&lt; <span class="string">' '</span>;</span><br><span class="line"><span class="keyword">if</span> (r == <span class="number">0</span> &amp;&amp; c &lt; n - <span class="number">1</span>) <span class="comment">//到第一行，但未到列边界，只能往右走</span></span><br><span class="line">&#123;</span><br><span class="line">dir = !dir;</span><br><span class="line">c++;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (r &lt; m - <span class="number">1</span> &amp;&amp; c == n - <span class="number">1</span>) <span class="comment">//到最后一列，未到最后一行，只能向下走</span></span><br><span class="line">&#123;</span><br><span class="line">dir = !dir;</span><br><span class="line">r++;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">r--;</span><br><span class="line">c++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="comment">//相反，走下坡</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a[r][c] &lt;&lt; <span class="string">' '</span>;</span><br><span class="line"><span class="keyword">if</span> (c == <span class="number">0</span> &amp;&amp; r &lt; m - <span class="number">1</span>) <span class="comment">//到第一列，未到最后一行，只能往下走</span></span><br><span class="line">&#123;</span><br><span class="line">dir = !dir;</span><br><span class="line">r++;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (r == m - <span class="number">1</span> &amp;&amp; c &lt; n - <span class="number">1</span>) <span class="comment">//到最后一行，未到最后一列，只能向右走</span></span><br><span class="line">&#123;</span><br><span class="line">dir = !dir;</span><br><span class="line">c++;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">r++;</span><br><span class="line">c--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="T-4：子数组的最大累加和"><a href="#T-4：子数组的最大累加和" class="headerlink" title="T 4：子数组的最大累加和"></a>T 4：子数组的最大累加和</h1><p>给定一个数组，返回子数组的最大累加和；</p><p>如 a = {1,-2,3,5,-2,6,-1};所有的子数组中[3,5,-2,6]可以累加出最大的和12；</p><p><strong>思路：若累加到当前数的和sum为负，那么比较sum和max，若sum比max大，则更新max，并中断此次累加操作（因为无论下个数next是正是负，sum+next都比next小），从下一个数开始累加；</strong></p><p><strong>若加到当前数的和sum为正，则继续累加下去，每次累加比较和max的大小；</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = nums.size();</span><br><span class="line">    <span class="keyword">if</span> (len == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>, maxSum = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        sum += nums[i];</span><br><span class="line">        <span class="keyword">if</span> (sum &gt; maxSum)</span><br><span class="line">            maxSum = sum;</span><br><span class="line">        <span class="keyword">if</span> (sum &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            sum = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxSum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>详情见<a href="https://blog.csdn.net/wyll19980812/article/details/105899832" target="_blank" rel="noopener">Leetcode第53题：最大子序和</a>；</p><h1 id="T-5：矩阵的乘法"><a href="#T-5：矩阵的乘法" class="headerlink" title="T 5：矩阵的乘法"></a>T 5：矩阵的乘法</h1><p><img src="https://tacotuesdayyy.oss-cn-shenzhen.aliyuncs.com/umg/image-20200607120125129.png" alt="image-20200607120125129"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">mutMatrix</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; m1, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; m2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n = m1.size();  <span class="comment">//矩阵1的行数</span></span><br><span class="line"><span class="keyword">int</span> m = m1[<span class="number">0</span>].size(); <span class="comment">//矩阵1的列数,矩阵2的行数肯定和矩阵1的列数相同</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> p = m2[<span class="number">0</span>].size(); <span class="comment">//矩阵2的列数</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; result;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; temp;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; p; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; m; k++)</span><br><span class="line">&#123;</span><br><span class="line">sum += m1[i][k] * m2[k][j];</span><br><span class="line">&#125;</span><br><span class="line">temp.push_back(sum);</span><br><span class="line">&#125;</span><br><span class="line">result.push_back(temp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      学习多维数组、矩阵并解决相关问题；
    
    </summary>
    
    
      <category term="算法" scheme="http://Luweir.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="Algorithm" scheme="http://Luweir.github.io/tags/Algorithm/"/>
    
  </entry>
  
</feed>
