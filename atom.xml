<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Luweir&#39;Blog</title>
  
  <subtitle>一旦你知道失败是什么感觉，就会决心追逐成功！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://luweir.github.io/"/>
  <updated>2020-07-17T18:15:07.710Z</updated>
  <id>http://luweir.github.io/</id>
  
  <author>
    <name>Mr.L</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>数学建模培训之现代优化算法作业</title>
    <link href="http://luweir.github.io/2020/07/18/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E5%9F%B9%E8%AE%AD%E7%8E%B0%E4%BB%A3%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95%E4%BD%9C%E4%B8%9A/"/>
    <id>http://luweir.github.io/2020/07/18/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E5%9F%B9%E8%AE%AD%E7%8E%B0%E4%BB%A3%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95%E4%BD%9C%E4%B8%9A/</id>
    <published>2020-07-17T18:15:00.000Z</published>
    <updated>2020-07-17T18:15:07.710Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>分别用<strong>随机游走</strong>、<strong>粒子群算法</strong>对下面的函数求最小值,请用Word或PDF文档给出实现代码( Matlab、Python均可 ) , 并用表格汇总各算法的参数值,寻优所需时间,最优值和最优值坐标。Z =100(x^2^-y)^2^+(x-1)^2^，-2.048&lt;= x, y&lt;= 2.048；</p><h1 id="问题求解"><a href="#问题求解" class="headerlink" title="问题求解"></a>问题求解</h1><h2 id="1、随机游走算法-RandomWalk"><a href="#1、随机游走算法-RandomWalk" class="headerlink" title="1、随机游走算法 RandomWalk"></a>1、随机游走算法 RandomWalk</h2><p><strong>算法原理</strong>：</p><p>​    每次随机选择一个当前解的邻近点进行比较,如果优于当前解,则将该点作为新的中心。如果连续n次都找不到更优的值，则认为最优解就在以当前<br>最优解为中心,当前步长为半径的D维球内(如果是三维,则刚好是空间中的球体)。如果此时步长已经小于阈值,则结束算法;否则,令步长减半，开始新一轮游走。</p><p>贴上代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># 使用随机游走算法求解函数极值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> __future__  <span class="keyword">import</span> print_function</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">N = <span class="number">3000</span> <span class="comment"># 迭代次数 N=100</span></span><br><span class="line">step = <span class="number">5</span> <span class="comment"># 初始步长 λ=5</span></span><br><span class="line">epsilon = <span class="number">0.00001</span> <span class="comment"># 精度达到10^(-5)</span></span><br><span class="line">variables = <span class="number">2</span> <span class="comment"># 变量数目为2</span></span><br><span class="line">x = [<span class="number">-2</span>,<span class="number">2</span>] <span class="comment"># 初始点坐标[-2,2]</span></span><br><span class="line">walk_num = <span class="number">1</span> <span class="comment"># 初始化随机游走次数</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出参数</span></span><br><span class="line">print(<span class="string">"迭代次数:"</span>,N)</span><br><span class="line">print(<span class="string">"初始步长:"</span>,step)</span><br><span class="line">print(<span class="string">"epsilon:"</span>,epsilon)</span><br><span class="line">print(<span class="string">"变量数目:"</span>,variables)</span><br><span class="line">print(<span class="string">"初始点坐标:"</span>,x)</span><br><span class="line"><span class="comment"># 定义目标函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">function</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> abs(x[<span class="number">0</span>])&lt;=<span class="number">2.048</span> <span class="keyword">and</span> abs(x[<span class="number">1</span>])&lt;=<span class="number">2.048</span>:</span><br><span class="line">        f = <span class="number">100</span>*(x[<span class="number">0</span>]**<span class="number">2</span>-x[<span class="number">1</span>])**<span class="number">2</span> + (x[<span class="number">0</span>]<span class="number">-1</span>)**<span class="number">2</span></span><br><span class="line">        <span class="keyword">return</span> f</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">100000</span> <span class="comment"># 取得某个不可能为最优解的值 </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 开始随机游走</span></span><br><span class="line">start=time.process_time() <span class="comment">#记录开始时间</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(step &gt; epsilon):</span><br><span class="line">    k = <span class="number">1</span> <span class="comment"># 初始化计数器</span></span><br><span class="line">    <span class="keyword">while</span>(k &lt; N):</span><br><span class="line">        u = [random.uniform(<span class="number">-1</span>,<span class="number">1</span>) <span class="keyword">for</span> i <span class="keyword">in</span> range(variables)] <span class="comment"># 随机向量</span></span><br><span class="line">        <span class="comment"># u1 为标准化之后的随机向量</span></span><br><span class="line">        u1 = [u[i]/math.sqrt(sum([u[i]**<span class="number">2</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(variables)])) <span class="keyword">for</span> i <span class="keyword">in</span> range(variables)]</span><br><span class="line">        x1 = [x[i] + step*u1[i] <span class="keyword">for</span> i <span class="keyword">in</span> range(variables)]</span><br><span class="line">        <span class="keyword">if</span>(function(x1) &lt; function(x)): <span class="comment"># 如果找到了更优点</span></span><br><span class="line">            k = <span class="number">1</span></span><br><span class="line">            x = x1</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            k += <span class="number">1</span></span><br><span class="line">    step = step/<span class="number">2</span></span><br><span class="line">    print(<span class="string">"第%d次随机游走完成。"</span> % walk_num)</span><br><span class="line">    walk_num += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">end=time.process_time() <span class="comment">#记录结束时间</span></span><br><span class="line">print(<span class="string">"耗时 (s): "</span>, end-start)</span><br><span class="line">print(<span class="string">"随机游走次数:"</span>,walk_num<span class="number">-1</span>)</span><br><span class="line">print(<span class="string">"最终最优点:"</span>,x)</span><br><span class="line">print(<span class="string">"最终最优值:"</span>,function(x))</span><br></pre></td></tr></table></figure><p>结果如下图所示：</p><p><img src="https://tacotuesdayyy.oss-cn-shenzhen.aliyuncs.com/umg/image-20200716224814889.png" alt="image-20200716224814889"></p><h2 id="2、粒子群算法-PSO"><a href="#2、粒子群算法-PSO" class="headerlink" title="2、粒子群算法 PSO"></a>2、粒子群算法 PSO</h2><p><strong>算法原理</strong>：</p><p>​    粒子群算法用粒子来模拟鸟群中的鸟,即用粒子代表问题的可能解,每个粒子在搜索空间中单独的搜寻最优解,通过粒子个体的简单行为和群体内的信息交互,实现了问题求解的智能性。粒子具有两个属性:速度和位置。速度代表移动的快慢,位置代表移动的方向。每个粒子每次搜索得到的最优解,记为当前粒子的个体极值。然后将此个体极值与整个粒子群里的其他粒子共享,找出最优的个体极值,作为整个粒子群的当前全局最优解。所有粒子根据自己的个体极值和整个粒子群共享的当前全局最优解来不断调整自己的速度和位置。</p><p>贴上代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Plot particle history as animation</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> sko.PSO <span class="keyword">import</span> PSO</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">demo_func</span><span class="params">(p)</span>:</span></span><br><span class="line">    x, y = p</span><br><span class="line">    <span class="keyword">return</span> <span class="number">100</span> * ((x ** <span class="number">2</span> - y) ** <span class="number">2</span>) + (x - <span class="number">1</span>) ** <span class="number">2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">lbs=[<span class="number">-2.048</span>, <span class="number">-2.048</span>]</span><br><span class="line">ubs=[<span class="number">2.048</span>, <span class="number">2.048</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">pso = PSO(func=demo_func, dim=<span class="number">2</span>, pop=<span class="number">40</span>, max_iter=<span class="number">300</span>, lb=lbs, ub=ubs, w=<span class="number">0.8</span>, c1=<span class="number">0.5</span>, c2=<span class="number">0.5</span>)</span><br><span class="line"><span class="comment"># 搜索空间维数: dim=2</span></span><br><span class="line"><span class="comment"># 初始群体的个体数量: pop=40</span></span><br><span class="line"><span class="comment"># 最大迭代次数: max_iter=300</span></span><br><span class="line"><span class="comment"># x,y的下限分别为 lbs=[-2.048, -2.048]</span></span><br><span class="line"><span class="comment"># x,y的上限分别为 ubs=[2.048, 2.048]</span></span><br><span class="line"><span class="comment"># 惯性权重: w=0.8 越大越有利于全局最优</span></span><br><span class="line"><span class="comment"># 社会经验和自身经验对半分: c1=0.5,c2=0.5</span></span><br><span class="line">pso.record_mode = <span class="literal">True</span> <span class="comment">#记录模式</span></span><br><span class="line"></span><br><span class="line">start=time.process_time()</span><br><span class="line">pso.run()</span><br><span class="line">end=time.process_time()</span><br><span class="line">print(<span class="string">'best_x is '</span>, pso.gbest_x, <span class="string">'\n best_z is'</span>, pso.gbest_y)</span><br><span class="line">print(<span class="string">"运行耗时：(s) "</span>,end-start)</span><br></pre></td></tr></table></figure><p>结果如下图所示：</p><p><img src="https://tacotuesdayyy.oss-cn-shenzhen.aliyuncs.com/umg/image-20200717000646084.png" alt="image-20200717000646084"></p><p>当max_iter最大迭代次数仅为100时，得到的结果精度达不到这么高，如图所示：</p><p><img src="https://tacotuesdayyy.oss-cn-shenzhen.aliyuncs.com/umg/image-20200717000728261.png" alt="image-20200717000728261"></p><h1 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h1><p>分别用<strong>模拟退火或蚁群算法(二选一)和遗传算法</strong>对给定坐标的<strong>TSP问题</strong>进行求解,请用Word或PDF文档给出实现代码(Matlab、Python均可) , 并用表格汇总各算法的参数值,寻优所需时间,最短路径及距离。</p><p>部分数据如下图所示：</p><p><img src="https://tacotuesdayyy.oss-cn-shenzhen.aliyuncs.com/umg/image-20200717080331585.png" alt="image-20200717080331585"></p><h1 id="问题求解-1"><a href="#问题求解-1" class="headerlink" title="问题求解"></a>问题求解</h1><p>首先对数据进行处理，即删除第一列，将其保存为新的文件；</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="comment"># 从指定文件夹中读取数据，非使用第一行的数据为列名，以' '为分隔符</span></span><br><span class="line">data1=pd.read_csv(<span class="string">r'F:\Users\Administrator\Desktop\建模培训\7.12第8天 现代优化算法\作业\作业2数据.txt'</span>,header=<span class="literal">None</span>,delimiter=<span class="string">' '</span>)</span><br><span class="line"><span class="comment"># 将数据的保存至数据4.txt，其索引、列名皆不保存，默认以','为分隔符</span></span><br><span class="line">df.to_csv(<span class="string">r'F:\Users\Administrator\Desktop\建模培训\7.12第8天 现代优化算法\作业\数据4.txt'</span>,index=<span class="literal">False</span>,header=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure><p>部分数据如图所示：</p><p><img src="https://tacotuesdayyy.oss-cn-shenzhen.aliyuncs.com/umg/image-20200717235635799.png" alt="image-20200717235635799"></p><h2 id="1、遗传算法-GA"><a href="#1、遗传算法-GA" class="headerlink" title="1、遗传算法 GA"></a>1、遗传算法 GA</h2><p><strong>算法原理</strong>：</p><p>​    遗传算法是一种基于自然选择、 生物进化过程来求解问题的方法。在每一步中,算法随机地从当前种群( Population )中选择若千个体(Individual )作为父辈,并且使用它们产生下一-代的子孙种群。在连续若干代之后,种群朝着优化解的方向进化。遗传算法可求解各种优化问题,如:目标函数不连续、不可微、随机或高度非线性。</p><p><strong>算法特点</strong>：<br>1、直接对结构对象进行操作,不存在求导和函数连续性的限定;<br>2、具有内在的隐并行性和更好的全局寻优能力;<br>3、概率化的寻优方法,自适应地调整搜索方向；</p><p><strong>一般步骤</strong>：<br>1.随机产生初始候选种群。<br>2.计算候选种群中所有个体的适应度。若符合结束条件,则输出最佳个体及最优解,结束进化。不符合,则步骤3<br>3.在候选种群中进行个体选择,适应度高的个体高概率被选为父母个体,适应度低的个体被淘汰。<br>4.用父母的染色体进行交叉,生成新个体。<br>5.对子代染色体进行变异,生成新个体。<br>6.将新个体加入候选种群中,返回步骤2。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> scipy <span class="keyword">import</span> spatial</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取数据</span></span><br><span class="line">points_coordinate =np.loadtxt(<span class="string">'数据4.txt'</span>,delimiter=<span class="string">","</span>)</span><br><span class="line"><span class="comment"># 一共有num_points个点</span></span><br><span class="line">num_points = points_coordinate.shape[<span class="number">0</span>]</span><br><span class="line"><span class="comment"># 得到任意两个点之间的距离</span></span><br><span class="line">distance_matrix = spatial.distance.cdist(points_coordinate, points_coordinate, metric=<span class="string">'euclidean'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cal_total_distance</span><span class="params">(routine)</span>:</span></span><br><span class="line">    num_points, = routine.shape</span><br><span class="line">    <span class="keyword">return</span> sum([distance_matrix[routine[i % num_points], routine[(i + <span class="number">1</span>) % num_points]] <span class="keyword">for</span> i <span class="keyword">in</span> range(num_points)])</span><br><span class="line"></span><br><span class="line"><span class="comment"># do GA</span></span><br><span class="line"><span class="keyword">from</span> sko.GA <span class="keyword">import</span> GA_TSP</span><br><span class="line">ga_tsp = GA_TSP(func=cal_total_distance, n_dim=num_points, size_pop=<span class="number">80</span>, max_iter=<span class="number">3000</span>, prob_mut=<span class="number">0.1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行并计算耗时</span></span><br><span class="line">start=time.process_time()</span><br><span class="line">best_points, best_distance = ga_tsp.run()</span><br><span class="line">end=time.process_time()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进行输出</span></span><br><span class="line">print(<span class="string">"运行耗时: (s)"</span>,end-start)</span><br><span class="line">print(best_distance)</span><br></pre></td></tr></table></figure><p>可视化图形所下所示：</p><p><img src="https://tacotuesdayyy.oss-cn-shenzhen.aliyuncs.com/umg/image-20200718014056308.png" alt="image-20200718014056308"></p><p>运行耗时、最短路径以及最短距离如图所示：</p><p><img src="https://tacotuesdayyy.oss-cn-shenzhen.aliyuncs.com/umg/image-20200718020250167.png" alt="image-20200718020250167"></p><h2 id="2、模拟退火算法-SA"><a href="#2、模拟退火算法-SA" class="headerlink" title="2、模拟退火算法 SA"></a>2、模拟退火算法 SA</h2><p>​        模拟退火算法SA出发点是基于物理中固体物质的退火过程与一般组合优化问题之间的相似性；</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> scipy <span class="keyword">import</span> spatial</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取数据集</span></span><br><span class="line">file_name = sys.argv[<span class="number">1</span>] <span class="keyword">if</span> len(sys.argv) &gt; <span class="number">1</span> <span class="keyword">else</span> <span class="string">'数据4.txt'</span></span><br><span class="line">points_coordinate = np.loadtxt(file_name, delimiter=<span class="string">','</span>)</span><br><span class="line"><span class="comment"># 一共有num_points个点</span></span><br><span class="line">num_points = points_coordinate.shape[<span class="number">0</span>]</span><br><span class="line"><span class="comment"># 得到任意两个点之间的距离</span></span><br><span class="line">distance_matrix = spatial.distance.cdist(points_coordinate, points_coordinate, metric=<span class="string">'euclidean'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cal_total_distance</span><span class="params">(routine)</span>:</span></span><br><span class="line">    num_points, = routine.shape</span><br><span class="line">    <span class="keyword">return</span> sum([distance_matrix[routine[i % num_points], routine[(i + <span class="number">1</span>) % num_points]] <span class="keyword">for</span> i <span class="keyword">in</span> range(num_points)])</span><br><span class="line"></span><br><span class="line"><span class="comment"># do SA</span></span><br><span class="line"><span class="keyword">from</span> sko.SA <span class="keyword">import</span> SA_TSP</span><br><span class="line">sa_tsp = SA_TSP(func=cal_total_distance, x0=range(num_points), T_max=<span class="number">100</span>, T_min=<span class="number">1</span>, L=<span class="number">5</span> * num_points)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行并计算耗时</span></span><br><span class="line">start=time.process_time()</span><br><span class="line">best_points, best_distance = sa_tsp.run()</span><br><span class="line">end=time.process_time()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进行输出</span></span><br><span class="line">print(<span class="string">"运行耗时: (s)"</span>,end-start)</span><br><span class="line">print(best_points, best_distance, cal_total_distance(best_points))</span><br></pre></td></tr></table></figure><p>可视化图形如下所示：</p><p><img src="https://tacotuesdayyy.oss-cn-shenzhen.aliyuncs.com/umg/image-20200718014330364.png" alt="image-20200718014330364"></p><p><img src="https://tacotuesdayyy.oss-cn-shenzhen.aliyuncs.com/umg/image-20200718014340636.png" alt="image-20200718014340636"></p><p>运行耗时、最佳路径以及最短距离如下所示：</p><p><img src="https://tacotuesdayyy.oss-cn-shenzhen.aliyuncs.com/umg/image-20200718014633486.png" alt="image-20200718014633486"></p>]]></content>
    
    <summary type="html">
    
      记录求解现代优化算法作业的步骤
    
    </summary>
    
    
      <category term="Math Models" scheme="http://Luweir.github.io/categories/Math-Models/"/>
    
    
      <category term="数学建模" scheme="http://Luweir.github.io/tags/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/"/>
    
      <category term="优化算法" scheme="http://Luweir.github.io/tags/%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>建模培训之回归分析作业</title>
    <link href="http://luweir.github.io/2020/07/15/%E5%9B%9E%E5%BD%92%E5%88%86%E6%9E%90%E4%BD%9C%E4%B8%9A/"/>
    <id>http://luweir.github.io/2020/07/15/%E5%9B%9E%E5%BD%92%E5%88%86%E6%9E%90%E4%BD%9C%E4%B8%9A/</id>
    <published>2020-07-15T14:58:00.000Z</published>
    <updated>2020-07-15T15:01:51.074Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>​        数据文件是1995-2018年的中国有关粮食种植方面的数据,我们认为播种面积(千公顷) (y)可能受以下六个因素影响,分别为产量(万吨)(x1),农业劳动力人口(万人) (x2),农民受教育程度(年) (x3)， 全国.小麦进口额(万吨) (x4), 城乡收入差距(x5),家庭负担(元/人)(x6), .请分别用<strong>经典最小二乘回归、主成分回归以及偏最小二乘回归</strong>三种方法进行分析并给出合理解释。</p><p><img src="https://tacotuesdayyy.oss-cn-shenzhen.aliyuncs.com/umg/image-20200715001040735.png" alt="粮食数据"></p><h1 id="问题求解"><a href="#问题求解" class="headerlink" title="问题求解"></a>问题求解</h1><h2 id="1、使用最小二乘回归分析"><a href="#1、使用最小二乘回归分析" class="headerlink" title="1、使用最小二乘回归分析"></a>1、使用最小二乘回归分析</h2><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">xdata=xlsread(<span class="string">'粮食数据1.xlsx'</span>);</span><br><span class="line">x=xdata(:,<span class="number">3</span>:<span class="keyword">end</span>);<span class="comment">%自变量6个</span></span><br><span class="line">y=xdata(:,<span class="number">2</span>);<span class="comment">%因变量1个</span></span><br><span class="line">reglm(y,x);</span><br></pre></td></tr></table></figure><p>得到以下结果：</p><p><img src="https://tacotuesdayyy.oss-cn-shenzhen.aliyuncs.com/umg/image-20200714222851951.png" alt="image-20200714222851951"></p><p>由分析表中可以看出，存在多重线性关系，比如x1，x2，x4的p值就大于0.05，其对因变量的影响较小，接下来应该消除多重线性关系；</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">inmodel=<span class="number">1</span>:<span class="number">6</span>;</span><br><span class="line">stepwise(x,y,inmodel)</span><br></pre></td></tr></table></figure><p>消除之前是这样的：</p><p><img src="https://tacotuesdayyy.oss-cn-shenzhen.aliyuncs.com/umg/image-20200714223227698.png" alt="image-20200714223227698"></p><p>把<strong>p值最大的变量X4</strong>移除之后：</p><p><img src="https://tacotuesdayyy.oss-cn-shenzhen.aliyuncs.com/umg/image-20200714223419622.png" alt="image-20200714223419622"></p><p>我们可以看到剩下的<strong>自变量P值皆小于0.05</strong>，符合要求；</p><p>并且调整后的<strong>拟合度达到0.955</strong>，即此方程解释的信息超过95%，并且<strong>整体P值远小于0.05</strong>，通过显著性检验，达到要求；</p><p>所以我们可以得到使用最小二乘回归分析后的方程：<br>$$<br>y=2406.2-0.234144X1-0.427047X2+553.76X3-272.711X5-0.107136X6<br>$$<br>从方程式中可以看出，粮食播种面积由农民受教育程度以及城乡收入差距影响；（不知道怎么分析啊  😂😂😂）</p><h2 id="2、使用主成分回归分析"><a href="#2、使用主成分回归分析" class="headerlink" title="2、使用主成分回归分析"></a>2、使用主成分回归分析</h2><p><strong>步骤1：对自变量进行主成分分析</strong></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">xdata=xlsread(<span class="string">'粮食数据1.xlsx'</span>);</span><br><span class="line">x=xdata(:,<span class="number">3</span>:<span class="keyword">end</span>);<span class="comment">%自变量6个</span></span><br><span class="line">y=xdata(:,<span class="number">2</span>);<span class="comment">%因变量1个</span></span><br><span class="line">xz=zscore(x); <span class="comment">%数据标准化</span></span><br><span class="line">[coeff, score, latent, tsquare, explained]=pca (xz) <span class="comment">%由观测数据矩阵作分析</span></span><br></pre></td></tr></table></figure><p>得到的 coeff 系数矩阵如图所示：</p><p><img src="https://tacotuesdayyy.oss-cn-shenzhen.aliyuncs.com/umg/image-20200714232054645.png" alt="image-20200714232054645"></p><p><strong>步骤2：因变量对主成分变量进行回归</strong></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">z1=score(:,<span class="number">1</span>:<span class="number">6</span>);</span><br><span class="line">reglm(y,z1)</span><br></pre></td></tr></table></figure><p><img src="https://tacotuesdayyy.oss-cn-shenzhen.aliyuncs.com/umg/image-20200714232505482.png" alt="image-20200714232505482"></p><p>可以看出X2，X3，X5，X6对因变量的影响较小，剔除后：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">z1=scorez(:,[<span class="number">1</span> <span class="number">4</span>]);<span class="comment">%发现第2,3,5,6个主成分得分量对因变量影响不显著（p&gt;0.05）,因而删除它！</span></span><br><span class="line">reglm(y,z1)</span><br></pre></td></tr></table></figure><p><img src="https://tacotuesdayyy.oss-cn-shenzhen.aliyuncs.com/umg/image-20200714235654248.png" alt="image-20200714235654248"></p><p>拟合度达到0.94以上，各参数P值均小于0.05，符合要求；</p><p>注意这里的X1，X2指Z1和Z4，需要步骤3的操作将Z转换为X；</p><p><strong>步骤3：因变量对原始变量进行回归</strong></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%计算因变量对原始自变量的回归方程系数</span></span><br><span class="line">xn=zscore(x);</span><br><span class="line">yn=zscore(y);</span><br><span class="line">d=xn*coeff;</span><br><span class="line">st=coeff(:,[<span class="number">1</span> <span class="number">4</span>])*(d(:,[<span class="number">1</span> <span class="number">4</span>])\yn);</span><br><span class="line">st2=[<span class="built_in">mean</span>(y)-std(y)*<span class="built_in">mean</span>(x)./std(x)*st,std(y)*st'./std(x)];</span><br></pre></td></tr></table></figure><p>结果如图所示：</p><p><img src="https://tacotuesdayyy.oss-cn-shenzhen.aliyuncs.com/umg/image-20200715000500316.png" alt="image-20200715000500316"></p><p>即方程为：<br>$$<br>y=7482.6+0.1X1-1.1X2+54.2X3-0.1X4-27.5X5<br>$$<br>贴上完整Matlab代码：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">xdata=xlsread(<span class="string">'粮食数据1.xlsx'</span>);</span><br><span class="line">x=xdata(:,<span class="number">3</span>:<span class="keyword">end</span>);<span class="comment">%自变量6个</span></span><br><span class="line">y=xdata(:,<span class="number">2</span>);<span class="comment">%因变量1个</span></span><br><span class="line">xz=zscore(x);</span><br><span class="line">[coeff, score, latent, tsquare, explained]=pca (xz)</span><br><span class="line">z1=score(:,[<span class="number">1</span>:<span class="number">6</span>]);</span><br><span class="line">reglm(y,z1)</span><br><span class="line">z1=score(:,[<span class="number">1</span> <span class="number">4</span>]);</span><br><span class="line">reglm(y,z1)</span><br><span class="line"></span><br><span class="line"><span class="comment">%计算因变量对原始自变量的回归方程系数</span></span><br><span class="line">xn=zscore(x);</span><br><span class="line">yn=zscore(y);</span><br><span class="line">d=xn*coeff;</span><br><span class="line">st=coeff(:,[<span class="number">1</span> <span class="number">4</span>])*(d(:,[<span class="number">1</span> <span class="number">4</span>])\yn);</span><br><span class="line">st2=[<span class="built_in">mean</span>(y)-std(y)*<span class="built_in">mean</span>(x)./std(x)*st,std(y)*st'./std(x)];</span><br></pre></td></tr></table></figure><p>分析：xxxxxxxxx</p><h2 id="3、偏最小二乘回归分析"><a href="#3、偏最小二乘回归分析" class="headerlink" title="3、偏最小二乘回归分析"></a>3、偏最小二乘回归分析</h2><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">xdata=xlsread(<span class="string">'粮食数据1.xlsx'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">%只有一个因变量</span></span><br><span class="line">mu=<span class="built_in">mean</span>(xdata(:,<span class="number">2</span>:<span class="number">8</span>));sig=std(xdata(:,<span class="number">2</span>:<span class="number">8</span>)); <span class="comment">%求均值和标准差</span></span><br><span class="line">ab=zscore(xdata(:,<span class="number">2</span>:<span class="number">8</span>));<span class="comment">%数据标准化</span></span><br><span class="line">a=ab(:,<span class="number">2</span>:<span class="number">7</span>);b1=ab(:,<span class="number">1</span>);</span><br><span class="line">[XL,YL,XS,YS,BETA,PCTVAR,MSE]=plsregress(a,b1,<span class="number">6</span>,<span class="string">'cv'</span>,<span class="number">10</span>);<span class="comment">%观测整体所有成分对的情况，用10折(把样本分成十份，每次用9份建模，最后一份来检验)交叉验证</span></span><br></pre></td></tr></table></figure><p><img src="https://tacotuesdayyy.oss-cn-shenzhen.aliyuncs.com/umg/image-20200715211152634.png" alt="image-20200715211152634"></p><p><img src="https://tacotuesdayyy.oss-cn-shenzhen.aliyuncs.com/umg/image-20200715211218030.png" alt="image-20200715211218030"></p><p><img src="https://tacotuesdayyy.oss-cn-shenzhen.aliyuncs.com/umg/image-20200715211229324.png" alt="image-20200715211229324"></p><p><strong>BETA为标准化系数矩阵</strong>，常数项为0，如下图所示：</p><p><img src="https://tacotuesdayyy.oss-cn-shenzhen.aliyuncs.com/umg/image-20200715211257426.png" alt="image-20200715211257426"></p><p><strong>PCTVAR为信息贡献率</strong>，如下图所示：</p><p><img src="https://tacotuesdayyy.oss-cn-shenzhen.aliyuncs.com/umg/image-20200715211403066.png" alt="image-20200715211403066"></p><p>第一个成分可以解释自变量组的63%的信息量，可以解释因变量的93%的信息量；</p><p>可以发现越后面的成分，信息的贡献量越低；</p><p>可以做累计和，即为这些成分的总的贡献率；</p><p><strong>MSE为用n个成分时的均方根误差</strong>，如下图所示：</p><p><img src="https://tacotuesdayyy.oss-cn-shenzhen.aliyuncs.com/umg/image-20200715212055655.png" alt="image-20200715212055655"></p><p>可以发现，用0个成分时，自变量的均方根误差为6.5959，因变量的均方根误差为1.1033；</p><p>用1个成分时，自变量的均方根误差为2.9808，因变量的均方根误差为0.0784；</p><p>用2个成分时，自变量的均方根误差为1.2281，因变量的均方根误差为0.1001；</p><p>到了用5、6个成分时，可以发现因变量的均方根误差明显必用4个成分时的大，说明这两个成分时噪声、无用信息，<strong>成分的选取最多4个</strong>；</p><p>随后对这4个成分再次进行分析：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">contr=cumsum(PCTVAR,<span class="number">2</span>); <span class="comment">%六个成分的累计贡献率</span></span><br><span class="line">ncomp=<span class="number">4</span>;<span class="comment">%根据整体情况，选择成分</span></span><br><span class="line">[XL,YL,XS,YS,BETA,PCTVAR,MSE,stats]=plsregress(a,b1,<span class="number">4</span>,<span class="string">'cv'</span>,<span class="number">10</span>)</span><br><span class="line">contr=cumsum(PCTVAR,<span class="number">2</span>) <span class="comment">% 4个成分的累计贡献率</span></span><br></pre></td></tr></table></figure><p>4个成分的累计贡献率如下图所示：</p><p><img src="https://tacotuesdayyy.oss-cn-shenzhen.aliyuncs.com/umg/image-20200715213617179.png" alt="image-20200715213617179"></p><p>即用4个成分可以提取自变量组99.6%的信息量，可以提取因变量95.7%的信息量；</p><p>标准化系数矩阵BETA如下图所示：</p><p><img src="https://tacotuesdayyy.oss-cn-shenzhen.aliyuncs.com/umg/image-20200715213746900.png" alt="image-20200715213746900"></p><p>最后我们通过计算得到原始变量的回归方程：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">n=<span class="built_in">size</span>(a,<span class="number">2</span>);m=<span class="built_in">size</span>(b1,<span class="number">2</span>);<span class="comment">%n是自变量的个数,m是因变量的个数</span></span><br><span class="line">BETA2(<span class="number">1</span>,:)=mu(n+<span class="number">1</span>:<span class="keyword">end</span>)-mu(<span class="number">1</span>:n)./sig(<span class="number">1</span>:n)*BETA(<span class="number">2</span>:<span class="keyword">end</span>,:).*sig(n+<span class="number">1</span>:<span class="keyword">end</span>);<span class="comment">%原始数据回归方程的常数项</span></span><br><span class="line">BETA2(<span class="number">2</span>:n+<span class="number">1</span>,:)=(<span class="number">1.</span>/sig(<span class="number">1</span>:n))'*sig(n+<span class="number">1</span>:<span class="keyword">end</span>).*BETA(<span class="number">2</span>:<span class="keyword">end</span>,:)<span class="comment">%计算原始自变量x</span></span><br></pre></td></tr></table></figure><p><img src="https://tacotuesdayyy.oss-cn-shenzhen.aliyuncs.com/umg/image-20200715225446109.png" alt="image-20200715225446109"></p><p>即原始变量的回归方程为：<br>$$<br>y=6854.9+0.1909X1-0.9898X2+96.2804X3-0.1486X4-43.3423X5-0.0285X6<br>$$</p><p><img src="https://tacotuesdayyy.oss-cn-shenzhen.aliyuncs.com/umg/image-20200715220103998.png" alt="image-20200715220103998"></p><p>贴上代码：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">xdata=xlsread(<span class="string">'粮食数据1.xlsx'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">%只有一个因变量</span></span><br><span class="line">mu=<span class="built_in">mean</span>(xdata(:,<span class="number">2</span>:<span class="number">8</span>));sig=std(xdata(:,<span class="number">2</span>:<span class="number">8</span>)); <span class="comment">%求均值和标准差</span></span><br><span class="line">ab=zscore(xdata(:,<span class="number">2</span>:<span class="number">8</span>));<span class="comment">%数据标准化</span></span><br><span class="line">a=ab(:,<span class="number">2</span>:<span class="number">7</span>);b1=ab(:,<span class="number">1</span>); </span><br><span class="line">[XL,YL,XS,YS,BETA,PCTVAR,MSE,stats]=plsregress(a,b1,<span class="number">6</span>,<span class="string">'cv'</span>,<span class="number">10</span>);<span class="comment">%观测整体所有成分对的情况，用10折(把样本分成十份，每次用9份建模，最后一份来检验)交叉验证</span></span><br><span class="line"></span><br><span class="line">contr=cumsum(PCTVAR,<span class="number">2</span>);</span><br><span class="line">ncomp=<span class="number">4</span>;<span class="comment">%根据整体情况，选择成分</span></span><br><span class="line">[XL,YL,XS,YS,BETA,PCTVAR,MSE,stats]=plsregress(a,b1,ncomp,<span class="string">'cv'</span>,<span class="number">10</span>)</span><br><span class="line">contr=cumsum(PCTVAR,<span class="number">2</span>) <span class="comment">%求累计贡献率</span></span><br><span class="line"></span><br><span class="line">n=<span class="built_in">size</span>(a,<span class="number">2</span>);m=<span class="built_in">size</span>(b1,<span class="number">2</span>);<span class="comment">%n是自变量的个数,6个,m是因变量的个数,1个</span></span><br><span class="line">BETA2(<span class="number">1</span>,:)=mu(<span class="number">1</span>)-mu(<span class="number">2</span>:n+<span class="number">1</span>)./sig(<span class="number">2</span>:n+<span class="number">1</span>)*BETA(<span class="number">2</span>:<span class="keyword">end</span>,:).*sig(<span class="number">1</span>);<span class="comment">%原始数据回归方程的常数项</span></span><br><span class="line">BETA2(<span class="number">2</span>:n+<span class="number">1</span>,:)=(<span class="number">1.</span>/sig(<span class="number">2</span>:n+<span class="number">1</span>))'*sig(<span class="number">1</span>).*BETA(<span class="number">2</span>:<span class="keyword">end</span>,:)<span class="comment">%计算原始自变量x</span></span><br></pre></td></tr></table></figure><p>分析：xxxxxx</p>]]></content>
    
    <summary type="html">
    
      记录求解数学建模培训之回归分析作业的解题过程
    
    </summary>
    
    
      <category term="Math Models" scheme="http://Luweir.github.io/categories/Math-Models/"/>
    
    
      <category term="数学建模" scheme="http://Luweir.github.io/tags/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/"/>
    
  </entry>
  
  <entry>
    <title>数学建模培训学习笔记</title>
    <link href="http://luweir.github.io/2020/07/13/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E5%9F%B9%E8%AE%AD%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://luweir.github.io/2020/07/13/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E5%9F%B9%E8%AE%AD%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2020-07-13T04:32:00.000Z</published>
    <updated>2020-07-13T10:48:15.822Z</updated>
    
    <content type="html"><![CDATA[<h1 id="2020-7-5学习笔记–Python使用"><a href="#2020-7-5学习笔记–Python使用" class="headerlink" title="2020.7.5学习笔记–Python使用"></a>2020.7.5学习笔记–Python使用</h1><p>Python 语言具有通用性、高效性、跨平台移植性和安全性，广泛应用于科学计算、自然语言处理、图形图像处理、游戏开发、Web 应用等方面，在全球范围内拥有众多开发者专业社群。</p><p>安装python后使用pip进行库的安装；</p><p>常见的库有：</p><p><img src="https://tacotuesdayyy.oss-cn-shenzhen.aliyuncs.com/umg/image-20200710154400856.png" alt="image-20200710154400856"></p><p>建模里面要用到的库大概有：Numpy、Scipy、Pandas、Matplotlib、Networkx、cvxpy、Tensorflow等等</p><p>Anaconda中的jupyterNotebook同样也能实现很好的展示；</p><p>后面大概介绍了python的语法；</p><p>SciPy 是在 NumPy 库的基础上增加了众多的数学、科学以及工程计算中常用函数的库。SciPy 库依赖于 NumPy，提供了便捷且快速的 维数组操作。SciPy 库与 NumPy 数组一起工作，提供了许多友好和高效的处理方法，它包括了统计、优化、线性代数模块、傅里叶变换、信号、图像处理和常微分方程的求解等，功能十分强大。</p><p>Scipy还能用的积分计算模式；</p><p>使用 pylab 或 pyplot 绘图的一般过程为：首先读入数据，然后根据实际需要绘制折线图、散点图、柱状图、雷达图或三维曲线和曲面，接下来设置轴和图形属性，最后显示或保存绘图结果。</p><h1 id="2020-7-6学习笔记–线性模型"><a href="#2020-7-6学习笔记–线性模型" class="headerlink" title="2020.7.6学习笔记–线性模型"></a>2020.7.6学习笔记–线性模型</h1><p>今天开始接触了线性代数的模型和整数规划模型，有点偏数学概念了，比较难以消化；</p><p><strong>数学规划是运筹学的一个重要分支</strong>，而线性规划又是数学规划中的一部分主要内容。</p><p>整个步骤大致分为：</p><p>1、问题分析；</p><p>2、模型假设；</p><p>3、符号说明；</p><p>4、模型建立；</p><p>5、模型的求解与分析</p><p>6、可行解、可行域；</p><p>7、灵敏度分析；</p><p>通过几个案例很好的阐述了这样一个过程，比如4-5使用python软件计算6个产地8个销地的最小运费问题；</p><p>从决策变量的取值范围来看，整数规划通常可以分为以下几种类型：</p><p>1、纯整数规划；</p><p>2、混合整数规划；</p><p>3、0-1整数规划：主要用于<strong>指派问题、分配任务问题</strong>；</p><h1 id="2020-7-7学习笔记–非线性模型"><a href="#2020-7-7学习笔记–非线性模型" class="headerlink" title="2020.7.7学习笔记–非线性模型"></a>2020.7.7学习笔记–非线性模型</h1><p>今天主要学习非线性规划和多目标规划模型</p><p>​        ==线性规划==的最优解存在，但最优解只能在可行域的边界上达到（特别是在可行域的顶点上达到），且求出的是全局最优解。但是==非线性规划==却没有这样好的性质，其最优解(如果存在)可能在可行域的任意一点达到，而一般非线性规划算法给出的也只能是局部最优解，不能保证是全局最优解。</p><p>​        非线性规划目前还没有适合各种问题的一般算法，各个算法都有其特定的适用范围； </p><p>​        罚函数法：把约束非线性规划问题转化一系列无约束非线性规划问题求解；</p><p>​        定义在有限凸集上的有限个凸函数的非负线性组合仍为凸函数；</p><p>​        ==solver=‘CVXOPT’==进行优化；</p><p>能用图片表示的就不用表格；</p><p>能用表格描述就不用文字描述；</p><p>必须要做灵敏度分析；</p><p>Markowitz建议风险可以用收益的方差(或标准差)来衡量：方差越大，风险越大；在一定条件下，这种方法来衡量风险是合适的；</p><p>于是，一种股票收益的均值衡量的是这种股票的平均收益状况,而收益的方差衡量的是这种股票收益的波动幅度，方差越大则波动越大，收益越不稳定。两种股票收益的协方差表示的则是它们之间的相关程度:<br>1)协方差为0时两者不相关。<br>2)协方差为正表示两者正相关，协方差越大则正相关性越强(越有可能一赚兼赚，一赔俱赔)</p><h1 id="2020-7-8学习笔记–图论算法"><a href="#2020-7-8学习笔记–图论算法" class="headerlink" title="2020.7.8学习笔记–图论算法"></a>2020.7.8学习笔记–图论算法</h1><p>图论模型是数学建模中常见又重要的一个模型，近几十年来发展的十分活跃，因为图本身的特性，大量的最优化问题都可以抽象成网络模型结构来加以解释、描述和求解。它在建模时，具有直观、易理解、适应性强等特点，已被广泛用于各个领域；</p><p>图重要有以下属性：</p><p>1、顶点 （+ 顶点位置）</p><p>2、边</p><p>3、权值</p><p>在有向图中，从顶点v引出的弧的数目称为v的出度，记为,从顶点v引入的弧的数目称为v的入度；</p><p>对于图的展示，需要用到networkx库的draw函数；</p><p><img src="https://tacotuesdayyy.oss-cn-shenzhen.aliyuncs.com/umg/image-20200710160333279.png" alt="image-20200710160333279"></p><p>图包括很多算法， 用于解决不同类型的问题：</p><p>1、最短路径算法：找出途中两个顶点之间的最短路径，常用于解决很多实际的优化问题；该问题下同样可以使用到整数规划、0-1规划模型来解决问题；</p><p>2、最小生成树：常用破圈法来求生成树</p><p>3、关键路径</p><p>4、Dijkstra算法：</p><p>5、Floyd算法；</p><p>论文写作表述越齐全越好</p><p>出弧入弧问题</p><p>写论文一定要写清楚，有时候评委不看题，论文三分写，七分改；</p><p>论文有闪光点</p><p><strong>管道订购和运输问题</strong></p><p>2000数学建模竞赛问题</p><p>要不不供货，供货就要&gt;500并且&lt;最大数量Si</p><p>15个铺设结点   ；</p><p>1、根据钢管厂生产额能力约束或购买限制</p><p>{0}∪[1000,2000]</p><p>2、配送量==需求量，配送量和小于储备量</p><p>3、</p><p>4、非负约束</p><p>把非线性约束转化为线性约束</p><p><img src="https://tacotuesdayyy.oss-cn-shenzhen.aliyuncs.com/umg/image-20200708111351959.png" alt="image-20200708111351959"></p><p>分支定界</p><p><img src="https://tacotuesdayyy.oss-cn-shenzhen.aliyuncs.com/umg/image-20200708111517144.png" alt="image-20200708111517144"></p><p><img src="https://tacotuesdayyy.oss-cn-shenzhen.aliyuncs.com/umg/image-20200708111814321.png" alt="image-20200708111814321"></p><p><img src="https://tacotuesdayyy.oss-cn-shenzhen.aliyuncs.com/umg/image-20200708111850965.png" alt="image-20200708111850965"></p><p><img src="https://tacotuesdayyy.oss-cn-shenzhen.aliyuncs.com/umg/image-20200708112007295.png" alt="image-20200708112007295"></p><p><img src="https://tacotuesdayyy.oss-cn-shenzhen.aliyuncs.com/umg/image-20200708112122257.png" alt="image-20200708112122257"></p><p><img src="https://tacotuesdayyy.oss-cn-shenzhen.aliyuncs.com/umg/image-20200708112313232.png" alt="image-20200708112313232"></p><p>零阶矩阵结点一个个输入</p><p>python输入比较方便，发现错误很容易修正；</p><p>能打括号的就打括号；</p><p><img src="https://tacotuesdayyy.oss-cn-shenzhen.aliyuncs.com/umg/image-20200708111733509.png" alt="image-20200708111733509"></p><p>数据处理很重要！！！</p><p>现学现卖！！！</p><h1 id="2020-7-9学习笔记–多元统计分析"><a href="#2020-7-9学习笔记–多元统计分析" class="headerlink" title="2020.7.9学习笔记–多元统计分析"></a>2020.7.9学习笔记–多元统计分析</h1><p>今天学的多元统计分析，处理多变量问题，变量多-&gt;处理问题复杂，信息重叠；</p><p>一种“降维”的思维方式，跟信息的相关性也有很大的关系；</p><p>拿一个椭圆，a趋近于无穷大和b趋近于无穷大作比较；</p><p>都是对矩阵的运算，矩阵的迹，矩阵的特征向量等；</p><p>在研究实际问题时，主体成分分析的步骤大概可归纳为：</p><p>1、将原始数据标准化；</p><p>2、建立变量的相关系数矩阵；</p><p>3、求特征向量、特征根；</p><p>4、由累计方差贡献率确定主成分的个数；</p><p>软件主要使用SPSS进行主成分分析，因子分析；</p><p>分析主要跟金融、经济的分析相关，课上的例题消化，代码在计算机上实现；</p><h1 id="2020-7-10学习笔记–回归分析"><a href="#2020-7-10学习笔记–回归分析" class="headerlink" title="2020.7.10学习笔记–回归分析"></a>2020.7.10学习笔记–回归分析</h1><p>今天学的回归分析主要分析事物之间的相关性，得到变量之间的数量变化规律并加以总结反映；</p><p>回归分析主要与线性模型有着很大的联系；</p><p>整个过程大概分以下几部分：<br>1、选择回归模型和回归方程；</p><p>2、回归方程的参数估计和检验；</p><p>3、回归判断</p><p>4、模型验证；</p><p>参数一般用最小二乘法估计；</p><p>多重共线性太强同样导致很多问题：比如回归系数标准误差的估计偏大，造成回归系数置信区间增大，回归系数的准确性和稳定性降低，回归系数检验的结果不显著等；</p><p>经典最小二乘回归，有模型假设，数据未必满足假设，大多数情况下存在多重共线性，需要进行变量选择;</p><p>主成分回归和偏最小二乘回归，不需要考虑多重共线性，不需要进行变量选择，最终是所有变量进入模型。</p><p>当样本量少，变量多且存在多重共线性，且多对多回归时，偏最小二乘回归更有优势。</p><h1 id="2020-7-11学习笔记–论文研读"><a href="#2020-7-11学习笔记–论文研读" class="headerlink" title="2020.7.11学习笔记–论文研读"></a>2020.7.11学习笔记–论文研读</h1><p>如何有收获的研读一篇优秀论文</p><p>取长补短 分工明确  强强联手</p><p>研究生建模论文： 30+页；</p><p>学习数学模型的描述; (目 标，约束条件)<br>学习模型的建立和求解(算法)<br>试着用求得的数据解释实际问题(量变→质变)</p><p>今天主要讲的<strong>资源优化配置</strong>，如何优化现有资源，合理配置，以便更好地服务社会；—-选址问题</p><p>大学校园：教师、宿舍、食堂、体育场……</p><p>社会上：银行网点、快递中心、物流中心、出租车、地铁公交站、基站、学校、医院、110网点、119消防站、商业中心、超市、餐馆、WC、理发店…..</p><p>常用的<strong>数学工具</strong>：</p><p>微积分、微分方程、线性代数、概率统计、图论…..</p><p>0-1规划、多目标规划….</p><p><strong>数学书</strong>：</p><p>高等数学、线性代数、线性规划、概率论与数理统计、图论、运筹学……</p><p><strong>常见算法</strong>：<br>最优化类算法：遗传/拟退火/神经网络<br>规划类算法：线性/整数/多元/二次规划…..<br>图论算法：网络流、二分图、最短路<br>计算机算法：动态规划/回溯搜索/分治/分枝界定…..<br>数据处理算法：数据拟合/参数估计/插值/蒙特卡罗/禁忌搜索/粒子群/聚类/蚁群/层次分析/数值分析/图像处理/网格化/离散化/穷举…..</p><p>熟悉并分类算法，求适用性；</p><p>步骤：</p><p>1、遇到问题；</p><p>2、处理问题；</p><p>3、提炼问题；</p><p>4、解决问题（建模）；</p><p>5、求解问题（算法）；</p><h2 id="从论文中学到什么内容？"><a href="#从论文中学到什么内容？" class="headerlink" title="从论文中学到什么内容？"></a>从论文中学到什么内容？</h2><ol><li><strong>找</strong>：找出文中所建立的数学模型，思考自己队建立新的模型；</li><li><strong>读</strong>：读懂文中模型的求解算法（不唯一），试着用其它算法去求解；</li><li><strong>悟</strong>：找出作者队要回答的问题是否得到了较理想的结果；</li><li><strong>用</strong>：是否能对所得到的结果给出可靠性的分析说明；</li><li><strong>思</strong>：如果让我们自己完成，我们会怎么做？</li></ol><p><strong>110警车配置及巡逻方案</strong></p><p>阅读优秀论文的意义：<br>1、学会重述问题（经得起查重）</p><p>2、如何让论文有闪光灯，在几千个队中脱颖而出</p><p>3、怎么选关键词</p><p>4、好的模型、好的结果、独特的思路、好的算法、好的排版；</p><h1 id="2020-7-12学习笔记–智能算法"><a href="#2020-7-12学习笔记–智能算法" class="headerlink" title="2020.7.12学习笔记–智能算法"></a>2020.7.12学习笔记–智能算法</h1><p>今天主要学的智能算法，对于现代优化算法，可以解决诸多实际问题；</p><p><strong>盲目搜索</strong>：搜索过程中不改变搜索策略，比如：DFS、BFS等等</p><p><strong>启发式搜索</strong>：对搜索过程中的信息进行处理，用来改进搜索策略，找最优化；比如：爬山法、模拟退火、遗传、粒子群、蚁群等；</p><p>贪心算法：以迭代进行寻优；很多启发式算法本质上就是贪心算法+随机算法</p><h2 id="1、爬山法-HC"><a href="#1、爬山法-HC" class="headerlink" title="1、爬山法 HC"></a>1、爬山法 HC</h2><p>​        一种局部择优的贪心搜索算法,其本质上是梯度下降法。该算法每次从当前的节点开始，与周围的邻接点进行比较:若当前节点是最大的,那么返回当前节点作为最大值；若当前节点是较小的,就用最大的邻接点替换当前节点,从而实现不断向山峰的高处攀爬,如此循环往复,直到达到最高点为止；</p><p>​        该算法的主要问题:对初始解(状态)敏感,容易陷入局部最优,即某个节点会比周围任何一个邻接点都大,但这只是局部最优解,并非全局最优解。</p><p><img src="https://tacotuesdayyy.oss-cn-shenzhen.aliyuncs.com/umg/image-20200713110821315.png" alt=""></p><p>起始点的选择非常重要；</p><p>优点：快速收敛于局部最优解；</p><p>缺点：遇到平台无所事从；</p><h2 id="2、随机游走算法-RW"><a href="#2、随机游走算法-RW" class="headerlink" title="2、随机游走算法 RW"></a>2、随机游走算法 RW</h2><p>​    一个操作简单,但是不易陷入局部极小值的方法。是局部搜索算法中最简单的一个,它的基本策略就是每次从当前候选解的邻居中选择一个    更优的进行转移。在二维世界里,如果你一直这样随机游走下去,你还是可能到达你的目的地的,但是如果是三维世界,概率就很低了。维度越高,概率越低；</p><p><strong>起始点</strong>和<strong>步长</strong>对于随机选择算法来说是非常重要！！！</p><p><strong>步长</strong>和<strong>迭代次数</strong>的越大，自然精度越高，所需要的时间也会增加！具体设定要参考特定的应用场所，如果是自动驾驶，要求反应时间很快，那么就不能设大；</p><p>​    基本的随机游走算法对于初始点比较敏感，可以看出 ,当初始点位于最优点附近时,可以很好地达到全局最优点;如果将初始点设置得离最优点较远,则容易陷入局部最优,不一定能达到全局最优点。<br>​    当增大迭代次数以及初始步长之后,函数最终达到了全局最优点。但是迭代次数增加的代价则是运行时间的增加。总得来说，基本的随机游走算法可以很好地达到全局最优点,但是有时会依赖于初始点的选择。</p><p><strong>改进的随机游走算法</strong>：</p><p>不同之处在于第三步：原来是产生一个随机向量u，现在是产生m个随机向量u1，u2….um改进之后随机游走算法的<strong>寻优能力大大提高</strong>，而且对于初始值的依赖程度也降低了；</p><p><strong>python库：scikit-opt库，包含常用现代优化算法</strong></p><h2 id="3、粒子群算法PSO"><a href="#3、粒子群算法PSO" class="headerlink" title="3、粒子群算法PSO"></a>3、粒子群算法PSO</h2><p>群智能算法，通过<strong>模拟鸟群捕食行为</strong>来设计；</p><p>​    假设区域里只有一块食物(即最优解),鸟群的任务是找到这个食物。鸟群在搜寻的过程中相互传递信息,互相告知各自的位置,通过这样的协作，每只 鸟可判断自己找到的是不是最优解,同时也将最优解传递给整个鸟群，最终,整个鸟群都能聚集在食物周围,即找到了最优解；</p><p>​    粒子群算法用粒子来模拟鸟群中的鸟,即用粒子代表问题的可能解,每个粒子在搜索空间中单独的搜寻最优解,通过粒子个体的简单行为和群体内的信息交互,实现了问题求解的智能性。</p><p><strong>粒子具有两个属性:速度和位置</strong>；速度代表移动的快慢，位置代表移动的方向。</p><p>❗ <strong>关键问题</strong>：是个性(个体认知)体现多一点，还是更服从团队(社会认知)！！</p><p>每个粒子每次搜索得到的最优解，记为当前粒子的<strong>个体极值</strong>；然后将此个体极值与整个粒子群里的其他粒子共享，找出最优的个体极值，作为整个粒子群的当前全局最优解。所有粒子根据自己的个体极值和整个粒子群共享的当前全局最优解来不断调整自己的速度和位置。</p><p><img src="https://tacotuesdayyy.oss-cn-shenzhen.aliyuncs.com/umg/image-20200713170920596.png" alt="image-20200713170920596"></p><p>算法流程：</p><p>1、初始化；C1，C2∈[0,4]</p><p>2、根据目标函数计算每个粒子的适应值；</p><p>3、更新粒子的速度</p>]]></content>
    
    <summary type="html">
    
      记录下从7月5日开始，我参加湖南大学数学建模培训课程所做的笔记、收获和心得
    
    </summary>
    
    
      <category term="Math Models" scheme="http://Luweir.github.io/categories/Math-Models/"/>
    
    
      <category term="数学建模" scheme="http://Luweir.github.io/tags/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/"/>
    
      <category term="笔记" scheme="http://Luweir.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>数学建模培训第四题</title>
    <link href="http://luweir.github.io/2020/07/10/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E5%9F%B9%E8%AE%AD%E7%AC%AC%E5%9B%9B%E9%A2%98/"/>
    <id>http://luweir.github.io/2020/07/10/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E5%9F%B9%E8%AE%AD%E7%AC%AC%E5%9B%9B%E9%A2%98/</id>
    <published>2020-07-10T02:51:00.000Z</published>
    <updated>2020-07-10T06:13:42.105Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>已知95个目标点的数据见Excel文件data6.xlsx，第1列是这95个点的编号，第2,3列是这95个点的坐标，第4列是这些点重要性分类，标明“1”的是第一类重要目标点，标明“2”的是第二类重要目标点，未标明类别的是一般目标点，第5，6，7标明了这些点的连接关系。</p><p><img src="https://tacotuesdayyy.oss-cn-shenzhen.aliyuncs.com/umg/image-20200709105449816.png" alt="image-20200709105449816"></p><p><img src="https://tacotuesdayyy.oss-cn-shenzhen.aliyuncs.com/umg/image-20200709105654721.png" alt="image-20200709105654721"></p><p><img src="https://tacotuesdayyy.oss-cn-shenzhen.aliyuncs.com/umg/image-20200709105706908.png" alt="image-20200709105706908"></p><p>如第三行的数据，表示顶点C的坐标为（-1160，587.5），它是一般目标点，C点和D点相连，C点也和F点相连。</p><h1 id="三个问题"><a href="#三个问题" class="headerlink" title="三个问题"></a>三个问题</h1><p>（1）画出上面的无向图，一类重要目标点用“五角星”画出，二类重要点用“*”画出，一般目标点用“.”画出。要求必须画出无向图的度量图，顶点的位置坐标必须准确，不要画出无向图的拓扑图。</p><p>（2）当权重为距离时，求上面无向图的最小生成树，并画出最小生成树。</p><p>（3）求顶点L到顶点R3的最短距离及最短路径，并画出最短路径。</p><h1 id="问题求解"><a href="#问题求解" class="headerlink" title="问题求解"></a>问题求解</h1><p><strong>坐标、无向、顶点类别、度量图</strong></p><p>待解决的问题：</p><ul><li><input checked="" disabled="" type="checkbox"> 点的坐标表示；</li><li><input checked="" disabled="" type="checkbox"> 点的类别判断；</li><li><input checked="" disabled="" type="checkbox"> 不同颜色不同形状点的设置；</li><li><input disabled="" type="checkbox"> 度量图/拓扑图；</li></ul><p>参考文章：</p><p>1、<a href="https://blog.csdn.net/weixin_38246633/article/details/85342109" target="_blank" rel="noopener">networkx.draw()详解</a></p><p>2、<a href="https://www.cnblogs.com/gispathfinder/p/5790949.html" target="_blank" rel="noopener">网络分析之networkx（转载）</a></p><p>3、<a href="https://blog.csdn.net/qq_40357974/article/details/95590230?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase" target="_blank" rel="noopener">使用networkx绘制带节点坐标图（节点、节点坐标和边）</a></p><p>4、<a href="https://blog.csdn.net/baidu_37995814/article/details/94006280?utm_medium=distribute.pc_relevant.none-task-blog-baidujs-3" target="_blank" rel="noopener">得到不同颜色和节点形状的网络结构图</a></p><h2 id="第一问："><a href="#第一问：" class="headerlink" title="第一问："></a>第一问：</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: gb2312 -*-</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cvxpy <span class="keyword">as</span> cp</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> networkx <span class="keyword">as</span> nx</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1、使用pandas读取excel表格文件，避免一个个输入数据</span></span><br><span class="line">df=pd.read_excel(<span class="string">r'F:\Users\Administrator\Desktop\data6.xlsx'</span>)</span><br><span class="line"><span class="comment"># 2、将df中的顶点列转化成列表nodes</span></span><br><span class="line">nodes=df.顶点.tolist()</span><br><span class="line"><span class="comment"># 3、创建一个空的无向图G</span></span><br><span class="line">G=nx.Graph()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4、给所有结点根据重要性标识分类</span></span><br><span class="line"><span class="comment"># 5、node1表示第1类结点</span></span><br><span class="line"><span class="comment">#node2表示第2类结点</span></span><br><span class="line"><span class="comment">#    node表示一般结点</span></span><br><span class="line">node1 = []</span><br><span class="line">node2 = []</span><br><span class="line">node = []</span><br><span class="line"></span><br><span class="line"><span class="comment"># vnode1表示第1类结点坐标</span></span><br><span class="line"><span class="comment"># vnode2表示第2类结点坐标</span></span><br><span class="line"><span class="comment"># vnode 表示一般结点坐标  </span></span><br><span class="line"><span class="comment"># vnode存放所有结点坐标</span></span><br><span class="line">vnode1 = []</span><br><span class="line">vnode2 = []</span><br><span class="line">vnode = []</span><br><span class="line">vnodes = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(df)):</span><br><span class="line">    vnodes.append(df[[<span class="string">'x坐标'</span>, <span class="string">'y坐标'</span>]].values[i])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (df.顶点类别[i] == <span class="number">1</span>):</span><br><span class="line">        node1.append(df.loc[i, <span class="string">'顶点'</span>])</span><br><span class="line">        vnode1.append(df[[<span class="string">'x坐标'</span>, <span class="string">'y坐标'</span>]].values[i])</span><br><span class="line">    <span class="keyword">if</span> (df.顶点类别[i] == <span class="number">2</span>):</span><br><span class="line">        node2.append(df.loc[i, <span class="string">'顶点'</span>])</span><br><span class="line">        vnode2.append(df[[<span class="string">'x坐标'</span>, <span class="string">'y坐标'</span>]].values[i])</span><br><span class="line">    <span class="keyword">if</span> (df.顶点类别.isnull()[i]):</span><br><span class="line">        node.append(df.loc[i, <span class="string">'顶点'</span>])</span><br><span class="line">        vnode.append(df[[<span class="string">'x坐标'</span>, <span class="string">'y坐标'</span>]].values[i])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 6、把nodes存入G中</span></span><br><span class="line">G.add_nodes_from(nodes)</span><br><span class="line"><span class="comment"># 7、获取结点与坐标之间的映射关系，用字典表示;</span></span><br><span class="line">npos1 = dict(zip(node1,vnode1))</span><br><span class="line">npos2 = dict(zip(node2,vnode2))</span><br><span class="line">npos = dict(zip(node,vnode))</span><br><span class="line">pos=dict(zip(nodes,vnodes))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 8、标志字典，构件结点与表示点之间的关系</span></span><br><span class="line">nlabels = dict(zip(nodes, nodes))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 9、edges中存放所有的边</span></span><br><span class="line">edges = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(df)):</span><br><span class="line">    <span class="comment"># 如果有相邻的顶点，就把把这条边加入到edges中</span></span><br><span class="line">    <span class="keyword">if</span> df[<span class="string">'相邻的顶点1'</span>].notnull()[i]:</span><br><span class="line">        edges.append([df.loc[i, <span class="string">'顶点'</span>], df.loc[i, <span class="string">'相邻的顶点1'</span>]])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> df[<span class="string">'相邻的顶点2'</span>].notnull()[i]:</span><br><span class="line">        edges.append([df.loc[i, <span class="string">'顶点'</span>], df.loc[i, <span class="string">'相邻的顶点2'</span>]])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> df[<span class="string">'相邻的顶点3'</span>].notnull()[i]:</span><br><span class="line">        edges.append([df.loc[i, <span class="string">'顶点'</span>], df.loc[i, <span class="string">'相邻的顶点3'</span>]])</span><br><span class="line">        </span><br><span class="line"><span class="comment"># 绘制坐标轴</span></span><br><span class="line">x_max=df[<span class="string">'x坐标'</span>].max()</span><br><span class="line">y_max=df[<span class="string">'y坐标'</span>].max()</span><br><span class="line">x_min=df[<span class="string">'x坐标'</span>].min()</span><br><span class="line">y_min=df[<span class="string">'y坐标'</span>].min()</span><br><span class="line"></span><br><span class="line">x_num = (x_max - x_min) / <span class="number">10</span></span><br><span class="line">y_num = (y_max - y_min) / <span class="number">10</span></span><br><span class="line"></span><br><span class="line">fig,ax = plt.subplots()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 10、按点的类边绘制无向图，</span></span><br><span class="line">nx.draw_networkx_nodes(G,npos1,nodelist=node1,node_shape=<span class="string">'p'</span>,node_size=<span class="number">50</span>) <span class="comment">#绘制顶点</span></span><br><span class="line">nx.draw_networkx_nodes(G,npos2,nodelist=node2,node_shape=<span class="string">'*'</span>,node_size=<span class="number">50</span>) <span class="comment">#绘制顶点</span></span><br><span class="line">nx.draw_networkx_nodes(G,npos,nodelist=node,node_shape=<span class="string">'.'</span>,node_size=<span class="number">50</span>) <span class="comment">#绘制顶点</span></span><br><span class="line">nx.draw_networkx_edges(G,pos,edges) <span class="comment"># 绘制边</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># nx.draw_networkx_labels(G, pos, nlabels)  # 添加标签</span></span><br><span class="line"><span class="comment"># 注释x轴y轴</span></span><br><span class="line">plt.xlabel(<span class="string">'x'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'y'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加坐标系</span></span><br><span class="line">plt.xlim((x_min - x_num, x_max + x_num))</span><br><span class="line">plt.ylim((y_min - y_num, y_max + y_num))</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>最终无向图如下：<br><img src="https://tacotuesdayyy.oss-cn-shenzhen.aliyuncs.com/umg/image-20200710124855614.png" alt="image-20200710124855614" style="zoom:1200%;" /></p><p>注解：</p><p>1、第一步中只用pandas读取的表格数据如下：</p><p><img src="https://tacotuesdayyy.oss-cn-shenzhen.aliyuncs.com/umg/image-20200710000903683.png" alt="image-20200710000903683"></p><p>2、第5步得到的各类结点以及对应坐标如图所示</p><p><img src="https://tacotuesdayyy.oss-cn-shenzhen.aliyuncs.com/umg/image-20200710102726326.png" alt="三类顶点"></p><p><img src="https://tacotuesdayyy.oss-cn-shenzhen.aliyuncs.com/umg/image-20200710102902025.png" alt="所有顶点的坐标"></p><p>3、edges如图所示：</p><p><img src="https://tacotuesdayyy.oss-cn-shenzhen.aliyuncs.com/umg/image-20200710103004131.png" alt="image-20200710103004131"></p><p>4、pos，即各个顶点的坐标如图所示：</p><p><img src="https://tacotuesdayyy.oss-cn-shenzhen.aliyuncs.com/umg/image-20200710103634834.png" alt="image-20200710103634834"></p><h2 id="第二问："><a href="#第二问：" class="headerlink" title="第二问："></a>第二问：</h2><p>第二问参考的例题6-12 </p><p><img src="https://tacotuesdayyy.oss-cn-shenzhen.aliyuncs.com/umg/image-20200710125053894.png" alt="image-20200710125053894"></p><p>每条边的权值都是两点间的距离，但这一题由于点的位置都存放在表格中，所以我们只能通过表格来获取点的坐标，再平方和开根号，算出存在边的两个点之间的距离：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: gb2312 -*-</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> networkx <span class="keyword">as</span> nx</span><br><span class="line"><span class="keyword">import</span> pylab <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> cvxpy <span class="keyword">as</span> cp</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="comment"># 1、前面这部分同第一问</span></span><br><span class="line">df=pd.read_excel(<span class="string">r'F:\Users\Administrator\Desktop\建模培训\四次作业\data6.xlsx'</span>)</span><br><span class="line">G=nx.Graph()</span><br><span class="line"></span><br><span class="line">node1 = []</span><br><span class="line">node2 = []</span><br><span class="line">node = []</span><br><span class="line">nodes = []</span><br><span class="line"></span><br><span class="line">vnode1 = []</span><br><span class="line">vnode2 = []</span><br><span class="line">vnode = []</span><br><span class="line">vnodes = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(df)):</span><br><span class="line">    nodes.append(df.loc[i, <span class="string">'顶点'</span>])</span><br><span class="line">    vnodes.append(df[[<span class="string">'x坐标'</span>, <span class="string">'y坐标'</span>]].values[i])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (df.顶点类别[i] == <span class="number">1</span>):</span><br><span class="line">        node1.append(df.loc[i, <span class="string">'顶点'</span>])</span><br><span class="line">        vnode1.append(df[[<span class="string">'x坐标'</span>, <span class="string">'y坐标'</span>]].values[i])</span><br><span class="line">    <span class="keyword">if</span> (df.顶点类别[i] == <span class="number">2</span>):</span><br><span class="line">        node2.append(df.loc[i, <span class="string">'顶点'</span>])</span><br><span class="line">        vnode2.append(df[[<span class="string">'x坐标'</span>, <span class="string">'y坐标'</span>]].values[i])</span><br><span class="line">    <span class="keyword">if</span> (df.顶点类别.isnull()[i]):</span><br><span class="line">        node.append(df.loc[i, <span class="string">'顶点'</span>])</span><br><span class="line">        vnode.append(df[[<span class="string">'x坐标'</span>, <span class="string">'y坐标'</span>]].values[i])</span><br><span class="line"></span><br><span class="line">G.add_nodes_from(nodes)</span><br><span class="line"><span class="comment"># 获取结点与坐标之间的映射关系，用字典表示</span></span><br><span class="line">npos1 = dict(zip(node1,vnode1))</span><br><span class="line">npos2 = dict(zip(node2,vnode2))</span><br><span class="line">npos = dict(zip(node,vnode))</span><br><span class="line">pos=dict(zip(nodes,vnodes))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 存放所有的边，构成无向图</span></span><br><span class="line">edges = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(df)):</span><br><span class="line">    <span class="comment"># 如果有相邻的顶点</span></span><br><span class="line">    <span class="keyword">if</span> df[<span class="string">'相邻的顶点1'</span>].notnull()[i]:</span><br><span class="line">        edges.append([df.loc[i, <span class="string">'顶点'</span>], df.loc[i, <span class="string">'相邻的顶点1'</span>]])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> df[<span class="string">'相邻的顶点2'</span>].notnull()[i]:</span><br><span class="line">        edges.append([df.loc[i, <span class="string">'顶点'</span>], df.loc[i, <span class="string">'相邻的顶点2'</span>]])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> df[<span class="string">'相邻的顶点3'</span>].notnull()[i]:</span><br><span class="line">        edges.append([df.loc[i, <span class="string">'顶点'</span>], df.loc[i, <span class="string">'相邻的顶点3'</span>]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2、开始计算两点之间的权重，用L存放所有的带权重边</span></span><br><span class="line">L=[]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(edges)):</span><br><span class="line">    a=edges[i][<span class="number">0</span>]  <span class="comment"># 第一个点</span></span><br><span class="line">    b=edges[i][<span class="number">1</span>]  <span class="comment"># 第二个点</span></span><br><span class="line">    x1=pos[a][<span class="number">0</span>]  <span class="comment"># a点横坐标</span></span><br><span class="line">    x2=pos[a][<span class="number">1</span>]  <span class="comment"># a点纵坐标</span></span><br><span class="line">    y1=pos[b][<span class="number">0</span>]  <span class="comment"># b点横坐标</span></span><br><span class="line">    y2=pos[b][<span class="number">1</span>]  <span class="comment"># b点纵坐标</span></span><br><span class="line">    temp=(a,b,math.sqrt(math.pow(x1-x2,<span class="number">2</span>)+math.pow(y1-y2,<span class="number">2</span>))) <span class="comment"># 求两点之间距离</span></span><br><span class="line">    L.append(temp) </span><br><span class="line"></span><br><span class="line">G.add_weighted_edges_from(L) <span class="comment"># 将L加入G中</span></span><br><span class="line">T = nx.minimum_spanning_tree(G)  <span class="comment"># 返回可迭代对象</span></span><br><span class="line">c = nx.to_numpy_matrix(T)  <span class="comment"># 返回最小生成树的邻接矩阵</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出邻接矩阵</span></span><br><span class="line">cdf=pd.DataFrame(c)</span><br><span class="line">cdf.to_excel(<span class="string">r"work4Data.xlsx"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 求最小生成树的权重</span></span><br><span class="line">w = c.sum() / <span class="number">2</span>  </span><br><span class="line">print(<span class="string">"最小生成树的权重:\n w = "</span>,w) </span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据图的拉普拉斯特征向量排列各节点</span></span><br><span class="line">pos=nx.spectral_layout(G)</span><br><span class="line"><span class="comment"># 3、最小生成树绘制</span></span><br><span class="line"></span><br><span class="line">nx.draw_networkx_nodes(G,pos,nodelist=node1,node_shape=<span class="string">'p'</span>,node_size=<span class="number">50</span>) <span class="comment">#绘制顶点</span></span><br><span class="line">nx.draw_networkx_nodes(G,pos,nodelist=node2,node_shape=<span class="string">'*'</span>,node_size=<span class="number">50</span>) <span class="comment">#绘制顶点</span></span><br><span class="line">nx.draw_networkx_nodes(G,pos,nodelist=node,node_shape=<span class="string">'.'</span>,node_size=<span class="number">50</span>) <span class="comment">#绘制顶点</span></span><br><span class="line">nx.draw_networkx_edges(T,pos,with_labels=<span class="literal">True</span>,font_weight=<span class="string">"bold"</span>)</span><br><span class="line">w2=nx.get_edge_attributes(T,<span class="string">'weight'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4、添加标签 （透明度为0.8 数字大小为2）</span></span><br><span class="line"><span class="comment"># nx.draw_networkx_edge_labels(T,pos,edge_labels=w2,alpha=0.8,font_size=2)  </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 5、保存图片</span></span><br><span class="line">plt.savefig(<span class="string">'figure4-2 最小生成树图形'</span>,dpi=<span class="number">1000</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>最终结果如下：</p><p><img src="https://tacotuesdayyy.oss-cn-shenzhen.aliyuncs.com/umg/image-20200710131656654.png" alt="image-20200710131656654"></p><p>不显示标签（权值）最小生成树为：</p><p><img src="https://tacotuesdayyy.oss-cn-shenzhen.aliyuncs.com/umg/image-20200710131805230.png" alt="image-20200710131805230"></p><p>显示标签（权值）最小生成树为：</p><p><img src="https://tacotuesdayyy.oss-cn-shenzhen.aliyuncs.com/umg/20200710131913.png" alt=""></p><p>注解：</p><p>1、第2步计算各点之间的距离，部分结果如图所示</p><p><img src="https://tacotuesdayyy.oss-cn-shenzhen.aliyuncs.com/umg/image-20200710131319360.png" alt="image-20200710131319360"></p><p>2、<strong>邻接矩阵c</strong>的部分数据如图所示</p><p><img src="https://tacotuesdayyy.oss-cn-shenzhen.aliyuncs.com/umg/image-20200710131545865.png" alt="image-20200710131545865"></p>]]></content>
    
    <summary type="html">
    
      记录做数学建模培训第四题的过程和心得
    
    </summary>
    
    
      <category term="Math Models" scheme="http://Luweir.github.io/categories/Math-Models/"/>
    
    
      <category term="数学建模" scheme="http://Luweir.github.io/tags/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/"/>
    
  </entry>
  
  <entry>
    <title>数学建模培训第二题</title>
    <link href="http://luweir.github.io/2020/07/09/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E5%9F%B9%E8%AE%AD%E7%AC%AC%E4%BA%8C%E9%A2%98/"/>
    <id>http://luweir.github.io/2020/07/09/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E5%9F%B9%E8%AE%AD%E7%AC%AC%E4%BA%8C%E9%A2%98/</id>
    <published>2020-07-09T01:43:00.000Z</published>
    <updated>2020-07-10T06:13:06.037Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>已知某物资有8个配送中心可以供货，有15个部队用户需要该物资，配送中心和部队用户之间单位物资的运费，15个部队用户的物资需求量和8个配送中心的物资储备量数据见表1。    </p><p>​                                                                  表1  配送中心和部队用户之间单位物资的运费和物资需求量、储备量数据</p><p><img src="https://tacotuesdayyy.oss-cn-shenzhen.aliyuncs.com/umg/image-20200709095703981.png" alt=" 表1  配送中心和部队用户之间单位物资的运费和物资需求量、储备量数据"> </p><h1 id="两个问题"><a href="#两个问题" class="headerlink" title="两个问题"></a>两个问题</h1><p>（1）根据题目给定的数据，求最小运费调用计划。</p><p>（2）若每个配送中心，可以对用户配送物资，也可以不对用户配送物资；若配送物资的话，<strong>配送量要大于等于1000且小于等于2000</strong>，求此时的费用最小调用计划。</p><h1 id="求解过程"><a href="#求解过程" class="headerlink" title="求解过程"></a>求解过程</h1><h2 id="第一问："><a href="#第一问：" class="headerlink" title="第一问："></a>第一问：</h2><p>第一问虽然不难，但第一次上手这类题目，要注意行列不要搞混；</p><p>贴上代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cvxpy <span class="keyword">as</span> cp</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="comment"># 从data4_5_1.txt中获得数据，c(15,8)代表整个运费数据；</span></span><br><span class="line">c=np.genfromtxt(<span class="string">"data4_5_1.txt"</span>,dtype=float,max_rows=<span class="number">15</span>,usecols=range(<span class="number">8</span>))</span><br><span class="line">d=np.genfromtxt(<span class="string">"data4_5_1.txt"</span>,dtype=float,max_rows=<span class="number">15</span>,usecols=<span class="number">8</span>) <span class="comment"># 取第9列，即15个用户的需求量</span></span><br><span class="line">e=np.genfromtxt(<span class="string">"data4_5_1.txt"</span>,dtype=float,skip_header=<span class="number">15</span>) <span class="comment"># 跳过15行，取第16行，取8个配送中心得储备量</span></span><br><span class="line"><span class="comment"># x(15,8)为未知量，X[i,j]代表配送中心j配送给用户i的量;</span></span><br><span class="line">x=cp.Variable((<span class="number">15</span>,<span class="number">8</span>),pos=<span class="literal">True</span>)</span><br><span class="line"><span class="comment"># Minimize表示求得最优解，存放于obj中</span></span><br><span class="line">obj=cp.Minimize(cp.sum(cp.multiply(c,x)))</span><br><span class="line"><span class="comment"># con列表存放各种限制条件</span></span><br><span class="line">con=[cp.sum(x,axis=<span class="number">0</span>,keepdims=<span class="literal">True</span>)&lt;=e.reshape(<span class="number">1</span>,<span class="number">8</span>), <span class="comment"># axis=0按列求和，各列之和要小于对应配送中心的储备量</span></span><br><span class="line">     cp.sum(x,axis=<span class="number">1</span>,keepdims=<span class="literal">True</span>)==d.reshape(<span class="number">15</span>,<span class="number">1</span>)] <span class="comment"># axis=1按行求和，各行之和要等于(或者大于)对应用户的需求量</span></span><br><span class="line"><span class="comment"># 构建问题</span></span><br><span class="line">prob=cp.Problem(obj,con)</span><br><span class="line"><span class="comment"># 使用GLPK_MI对问题进行求解</span></span><br><span class="line">prob.solve(solver=<span class="string">'GLPK_MI'</span>)</span><br><span class="line"><span class="comment"># 输出最小运费</span></span><br><span class="line">print(<span class="string">"最优值为："</span>,prob.value)</span><br><span class="line"><span class="comment"># 输出最小运费方案（即x)</span></span><br><span class="line">print(<span class="string">"最优解为：\n"</span>,x.value)l+l</span><br><span class="line"><span class="comment"># 将x数据保存至表格中</span></span><br><span class="line">xd=pd.DataFrame(x.value)</span><br><span class="line">xd.to_excel(<span class="string">"data4_5_2.xlsx"</span>)</span><br></pre></td></tr></table></figure><p>结果：</p><p><img src="https://tacotuesdayyy.oss-cn-shenzhen.aliyuncs.com/umg/image-20200709102639445.png" alt="image-20200709102639445"></p><p>一开始就是<strong>搞混了d，e所代表得含义</strong>，从而导致约束条件那里出问题，结果显示无解！</p><p>Notice：</p><p>1、cp.Variable()参数中：pos=True表示x的所有元素为正，integer=True表示x的所有元素为整数；</p><h2 id="第二问："><a href="#第二问：" class="headerlink" title="第二问："></a>第二问：</h2><p>第二问一开始考虑比较欠缺，直接用0，1模型来做，发现在con约束条件那里行不通！</p><p>随后放弃0，1模型，直接对x进行约束，同样得不到正确结果，因为这样的约束是对x的所有取值而言的；</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">con=[x&gt;=<span class="number">1000</span>,x&lt;=<span class="number">2000</span>,</span><br><span class="line">     cp.sum(x,axis=<span class="number">0</span>,keepdims=<span class="literal">True</span>)&lt;=e.reshape(<span class="number">1</span>,<span class="number">8</span>),</span><br><span class="line">     cp.sum(x,axis=<span class="number">1</span>,keepdims=<span class="literal">True</span>)&gt;=d.reshape(<span class="number">15</span>,<span class="number">1</span>) ]</span><br></pre></td></tr></table></figure><p>当设定x&gt;=1000后，结果x中所有元素的最小值就要是1000，就会得到这样的结果；</p><p><img src="https://tacotuesdayyy.oss-cn-shenzhen.aliyuncs.com/umg/image-20200709102709057.png" alt="image-20200709102709057"></p><p>显然这是不符合条件的，所以下一步我就想到能不能这样约束x：</p><p><code>x==0 or (x&gt;=1000 and x&lt;=2000)</code>这样的话x就能取0或者[1000,2000]里面的值，就能求出最优解了；</p><p>但遗憾的是结果报错，反复实验几次后请教司守奎老师，了解到con列表中的各元素之间都是与的关系，并且元素不能为元组，所以这个方法亦行不通；</p><p>经过这么久，我就只能得到一个不符合条件但接近最优解的结果：</p><p><img src="https://tacotuesdayyy.oss-cn-shenzhen.aliyuncs.com/umg/image-20200709103140217.png" alt="image-20200709103140217"></p><p>显然这里的900不符合[1000,2000]的范围；</p><p>在学完第六节的钢管运输问题后，这道题目就有些思路了，我可以利用==整数模型和线性模型结合的办法==，令<strong>矩阵T [ i , j ]表示配送中心 j 是否对用户 i 进行配送</strong>，而<strong>X[ i , j ]依旧表示配送中心 j 配送各用户 i 的量</strong>，这样T 和 X 就有着对应关系，T[i,j]为0，那么配送了必为0，T[i,j]为1，那么配送量就限制在[1000,2000]之间；</p><p>这样的话最终得到的X矩阵必满足条件：<code>1000*T&lt;=X&lt;=2000*T</code></p><p>贴上代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cvxpy <span class="keyword">as</span> cp</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">c=np.genfromtxt(<span class="string">"data4_5_1.txt"</span>,dtype=float,max_rows=<span class="number">15</span>,usecols=range(<span class="number">8</span>))</span><br><span class="line">d=np.genfromtxt(<span class="string">"data4_5_1.txt"</span>,dtype=float,max_rows=<span class="number">15</span>,usecols=<span class="number">8</span>) </span><br><span class="line">e=np.genfromtxt(<span class="string">"data4_5_1.txt"</span>,dtype=float,skip_header=<span class="number">15</span>) </span><br><span class="line"></span><br><span class="line">x=cp.Variable((<span class="number">15</span>,<span class="number">8</span>),pos=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 8个配送中心，每次配送给用户的量都要在1000和2000之间，用于建立0，1模型;</span></span><br><span class="line">t=cp.Variable((<span class="number">15</span>,<span class="number">8</span>),integer=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">obj=cp.Minimize(cp.sum(cp.multiply(c,x)))</span><br><span class="line"></span><br><span class="line">con=[x&gt;=<span class="number">1000</span>*t,</span><br><span class="line">     x&lt;=<span class="number">2000</span>*t,</span><br><span class="line">     t&gt;=<span class="number">0</span>,t&lt;=<span class="number">1</span>,x&gt;=<span class="number">0</span>,</span><br><span class="line">     cp.sum(x,axis=<span class="number">0</span>,keepdims=<span class="literal">True</span>)&lt;=e.reshape(<span class="number">1</span>,<span class="number">8</span>),</span><br><span class="line">     cp.sum(x,axis=<span class="number">1</span>,keepdims=<span class="literal">True</span>)&gt;=d.reshape(<span class="number">15</span>,<span class="number">1</span>)]</span><br><span class="line"></span><br><span class="line">prob=cp.Problem(obj,con)</span><br><span class="line">prob.solve(solver=<span class="string">'GLPK_MI'</span>)</span><br><span class="line">print(<span class="string">"最优值为："</span>,prob.value)</span><br><span class="line">print(<span class="string">"最优解为：\n"</span>,x.value)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出t</span></span><br><span class="line">print(<span class="string">"题解t：\n"</span>,t.value)</span><br><span class="line"></span><br><span class="line">xd=pd.DataFrame(x.value)</span><br><span class="line">xd.to_excel(<span class="string">"data4_5_2.xlsx"</span>)</span><br></pre></td></tr></table></figure><p>得到最优解：</p><p><img src="https://tacotuesdayyy.oss-cn-shenzhen.aliyuncs.com/umg/image-20200709104214516.png" alt="image-20200709104214516"></p><p>具体的建模过程还得参照我组大佬的文档，我这只是代码实现部分！</p>]]></content>
    
    <summary type="html">
    
      写下完成数学建模培训第二题的一点思路
    
    </summary>
    
    
      <category term="Math Models" scheme="http://Luweir.github.io/categories/Math-Models/"/>
    
    
      <category term="数学建模" scheme="http://Luweir.github.io/tags/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/"/>
    
  </entry>
  
  <entry>
    <title>Mr.L的工具栏</title>
    <link href="http://luweir.github.io/2020/07/04/Mr.L%E7%9A%84%E5%B7%A5%E5%85%B7%E6%A0%8F/"/>
    <id>http://luweir.github.io/2020/07/04/Mr.L%E7%9A%84%E5%B7%A5%E5%85%B7%E6%A0%8F/</id>
    <published>2020-07-03T23:52:00.000Z</published>
    <updated>2020-07-26T02:25:02.536Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、初始必备"><a href="#一、初始必备" class="headerlink" title="一、初始必备"></a>一、初始必备</h1><p>1、百度云</p><p>各种软件、电子书、教程都存在百度云！</p><p>2、Google浏览器 + 书签 + 相关插件</p><p>时常备份百度云书签以及插件、换设备时不用重新开始；</p><p>3、清理工具：Ccleaner</p><p>麻雀虽小、五脏俱全，清理强大，无广告！</p><p>4、文件搜索工具：Everything</p><p>速度是自带搜索的n倍以上</p><h1 id="二、文档类工具"><a href="#二、文档类工具" class="headerlink" title="二、文档类工具"></a>二、文档类工具</h1><p>1、WPS </p><p>各设备平台同步，超大云空间；</p><p><strong>文档阅读、标注都在云文档上完成</strong>，方便同步；不要保存在本地(除非要发送至他人)！</p><p>2、Office 2016 </p><p>写论文啥的要用word，比wps稳定；</p><p>3、Typora + PicGo </p><p>写markdown文档以及图床工具(使用的阿里云)；</p><p>4、Subline Text3 </p><p>查看各种类型的代码；</p><p>5、Xmind</p><p>构件思维导图；</p><h1 id="三、编程类工具"><a href="#三、编程类工具" class="headerlink" title="三、编程类工具"></a>三、编程类工具</h1><p>1、Vscode</p><p>暂且用它来刷Leetcode等算法题；轻便、五脏俱全；</p><p>2、pycharm</p><p>3、Anaconda</p><p>4、IntelliJ IDEA</p><p>5、Matlab</p><p>6、Git</p><h1 id="四、剪辑类工具"><a href="#四、剪辑类工具" class="headerlink" title="四、剪辑类工具"></a>四、剪辑类工具</h1><p>1、PS</p><p>2、PR</p><h1 id="五、其它工具"><a href="#五、其它工具" class="headerlink" title="五、其它工具"></a>五、其它工具</h1><p>1、To Do</p><p>任务清单神奇、Windows多平台同步；</p><p>2、Fiddler</p><p>抓包神器，抓一些网站上的视频啥的；</p><p>3、Mathpix Snipping </p><p>截图识别公式，直接粘贴在文档中</p>]]></content>
    
    <summary type="html">
    
      备份下我的常用工具（存放于百度云），换设备的时候提高效率
    
    </summary>
    
    
      <category term="Privacy" scheme="http://Luweir.github.io/categories/Privacy/"/>
    
    
      <category term="Tools" scheme="http://Luweir.github.io/tags/Tools/"/>
    
  </entry>
  
  <entry>
    <title>A Module</title>
    <link href="http://luweir.github.io/2020/07/04/A%20Module/"/>
    <id>http://luweir.github.io/2020/07/04/A%20Module/</id>
    <published>2020-07-03T23:37:00.000Z</published>
    <updated>2020-07-13T08:15:00.513Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>安装cvspy包</title>
    <link href="http://luweir.github.io/2020/07/03/%E5%AE%89%E8%A3%85cvspy%E5%8C%85/"/>
    <id>http://luweir.github.io/2020/07/03/%E5%AE%89%E8%A3%85cvspy%E5%8C%85/</id>
    <published>2020-07-03T15:04:20.822Z</published>
    <updated>2020-07-10T07:17:03.592Z</updated>
    
    <content type="html"><![CDATA[<p>下载压缩包：链接：<a href="https://pan.baidu.com/s/1wxMO5IN0R9S8fZnoGv75XQ" target="_blank" rel="noopener">https://pan.baidu.com/s/1wxMO5IN0R9S8fZnoGv75XQ</a>  ；提取码：svrc</p><p>注意版本要对应，我用的python3.7.2；不同版本参考这篇文章：<a href="https://blog.csdn.net/qq_36477513/article/details/104779850" target="_blank" rel="noopener">Python下载安装第三方库cvxpy包</a></p><p><strong>1、将压缩包解压(记住解压的位置，我是解压到的桌面)</strong></p><p><img src="https://tacotuesdayyy.oss-cn-shenzhen.aliyuncs.com/umg/image-20200703153111851.png" alt="image-20200703153111851"></p><p>里面是这些文件：</p><p><img src="https://tacotuesdayyy.oss-cn-shenzhen.aliyuncs.com/umg/image-20200703153134772.png" alt="image-20200703153134772"></p><p><strong>2、在文件所在的文件夹中打开DOC界面（win10直接在当前文件夹空白处按住shift，右键打开powershell窗口）</strong></p><h2 id=""><a href="#" class="headerlink" title=""></a><img src="https://tacotuesdayyy.oss-cn-shenzhen.aliyuncs.com/umg/image-20200703153318636.png" alt="image-20200703153318636"></h2><p>然后依次安装下列包</p><p><img src="https://tacotuesdayyy.oss-cn-shenzhen.aliyuncs.com/umg/image-20200703153749989.png" alt="image-20200703153749989"></p><p>在命令行中依次输入<code>pip install xxxxx.whl</code>  </p><p>xxxxx.whl就是上面说的包的全名！ 一定要复制全名 加后缀；</p><p>类似这个：</p><p><img src="https://tacotuesdayyy.oss-cn-shenzhen.aliyuncs.com/umg/image-20200703154007070.png" alt="image-20200703154007070"></p><p>每安装一个 下面就有进度，成功的话最后一句是<code>successfully installed  xxxxx-xx</code></p><p>最后安装cvxpy后</p><p><img src="https://tacotuesdayyy.oss-cn-shenzhen.aliyuncs.com/umg/image-20200703154149223.png" alt="image-20200703154149223"></p><p><strong>3、在win + R ，输入cmd</strong></p><p> 然后再命令行中先输入 <code>python</code> 再输入<code>import cvxpy</code></p><p>如果是下面这样 则表示成功；</p><p><img src="https://tacotuesdayyy.oss-cn-shenzhen.aliyuncs.com/umg/image-20200703154413352.png" alt="image-20200703154413352"></p><p>失败的话它会显示 <strong>找不到 名字为cvspy的module</strong>windows下安装pandoc并通过Typora导出pdf和word详细攻略</p>]]></content>
    
    <summary type="html">
    
      安装python库cvspy
    
    </summary>
    
    
      <category term="Software" scheme="http://Luweir.github.io/categories/Software/"/>
    
    
      <category term="Python" scheme="http://Luweir.github.io/tags/Python/"/>
    
      <category term="cvspy" scheme="http://Luweir.github.io/tags/cvspy/"/>
    
  </entry>
  
  <entry>
    <title>Google浏览器安装Google访问助手</title>
    <link href="http://luweir.github.io/2020/07/03/Google%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AE%89%E8%A3%85%E8%AE%BF%E9%97%AE%E5%8A%A9%E6%89%8B/"/>
    <id>http://luweir.github.io/2020/07/03/Google%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AE%89%E8%A3%85%E8%AE%BF%E9%97%AE%E5%8A%A9%E6%89%8B/</id>
    <published>2020-07-03T15:04:13.944Z</published>
    <updated>2020-07-03T15:20:55.074Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1、下载Google浏览器和访问助手"><a href="#1、下载Google浏览器和访问助手" class="headerlink" title="1、下载Google浏览器和访问助手"></a>1、下载Google浏览器和访问助手</h1><p>在链接中下载Google浏览器和Google访问助手；</p><p>链接：<a href="https://pan.baidu.com/s/1nn6SbqSLwvVhkOSVocTUzg" target="_blank" rel="noopener">https://pan.baidu.com/s/1nn6SbqSLwvVhkOSVocTUzg</a> ；提取码：zbdo；</p><h1 id="2、解压"><a href="#2、解压" class="headerlink" title="2、解压"></a>2、解压</h1><p>安装Google浏览器，将下载好的Google访问助手<strong>后缀 crx 改成 rar</strong></p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly90YWNvdHVlc2RheXl5Lm9zcy1jbi1zaGVuemhlbi5hbGl5dW5jcy5jb20vdW1nL2ltYWdlLTIwMjAwNzAyMjI0NjAyMjk0LnBuZw?x-oss-process=image/format,png" alt="image-20200702224602294"></p><p>在桌面新建一个文件夹；</p><p>然后打开Google访问助手进行解压，将里面的<strong>所有文件解压到桌面的新建文件夹</strong>中；</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly90YWNvdHVlc2RheXl5Lm9zcy1jbi1zaGVuemhlbi5hbGl5dW5jcy5jb20vdW1nL2ltYWdlLTIwMjAwNzAyMjI0ODI4MjEyLnBuZw?x-oss-process=image/format,png" alt="image-20200702224828212"></p><h1 id="3、Google浏览器加载"><a href="#3、Google浏览器加载" class="headerlink" title="3、Google浏览器加载"></a>3、Google浏览器加载</h1><p>在Google浏览器中打开<strong>扩展程序</strong></p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly90YWNvdHVlc2RheXl5Lm9zcy1jbi1zaGVuemhlbi5hbGl5dW5jcy5jb20vdW1nL2ltYWdlLTIwMjAwNzAyMjI1MjUwNTQwLnBuZw?x-oss-process=image/format,png" alt="image-20200702225250540"></p><p>点击 <strong>加载已解压的扩展程序</strong></p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly90YWNvdHVlc2RheXl5Lm9zcy1jbi1zaGVuemhlbi5hbGl5dW5jcy5jb20vdW1nL2ltYWdlLTIwMjAwNzAyMjI1NTEzNjkzLnBuZw?x-oss-process=image/format,png" alt="image-20200702225513693"></p><p>然后选择<strong>桌面的新建文件夹</strong>！</p><p>然后就加载成功了</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly90YWNvdHVlc2RheXl5Lm9zcy1jbi1zaGVuemhlbi5hbGl5dW5jcy5jb20vdW1nL2ltYWdlLTIwMjAwNzAyMjI1NTU1NTM3LnBuZw?x-oss-process=image/format,png" alt="image-20200702225555537"></p><h1 id="4、永久激活"><a href="#4、永久激活" class="headerlink" title="4、永久激活"></a>4、永久激活</h1><p>安装成功后打开新页面会自动弹出这个界面，提示永久激活！</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly90YWNvdHVlc2RheXl5Lm9zcy1jbi1zaGVuemhlbi5hbGl5dW5jcy5jb20vdW1nL2ltYWdlLTIwMjAwNzAyMjI1OTUzMTAyLnBuZw?x-oss-process=image/format,png" alt="image-20200702225953102"></p><p>点击永久免费激活；</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly90YWNvdHVlc2RheXl5Lm9zcy1jbi1zaGVuemhlbi5hbGl5dW5jcy5jb20vdW1nL2ltYWdlLTIwMjAwNzAyMjMwMDQwNDY1LnBuZw?x-oss-process=image/format,png" alt="image-20200702230040465"></p><p>前往选项页面设置；</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly90YWNvdHVlc2RheXl5Lm9zcy1jbi1zaGVuemhlbi5hbGl5dW5jcy5jb20vdW1nL2ltYWdlLTIwMjAwNzAyMjMwMTAwNzkyLnBuZw?x-oss-process=image/format,png" alt="image-20200702230100792"></p><p>点击自动打开主页，随便选一个即可；</p><p>然后重启浏览器，就会以你刚刚设置的为主页，并且有以下提示；</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly90YWNvdHVlc2RheXl5Lm9zcy1jbi1zaGVuemhlbi5hbGl5dW5jcy5jb20vdW1nL2ltYWdlLTIwMjAwNzAyMjMwMTUxNjcxLnBuZw?x-oss-process=image/format,png" alt="image-20200702230151671"></p><p>不要停用就行了！</p><h1 id="Notice"><a href="#Notice" class="headerlink" title="Notice"></a>Notice</h1><p>这个文件夹不可以删除！删除了扩展程序就没了！<br>如果觉得放桌面碍眼，就放你自己指定的文件夹，然后重新添加扩展一遍就行了！</p>]]></content>
    
    <summary type="html">
    
      下载并加载Google访问助手
    
    </summary>
    
    
      <category term="Software" scheme="http://Luweir.github.io/categories/Software/"/>
    
    
  </entry>
  
  <entry>
    <title>明天冲乐高机器人面试</title>
    <link href="http://luweir.github.io/2020/07/03/%E6%98%8E%E5%A4%A9%E5%86%B2%E4%B9%90%E9%AB%98%E6%9C%BA%E5%99%A8%E4%BA%BA%E9%9D%A2%E8%AF%95/"/>
    <id>http://luweir.github.io/2020/07/03/%E6%98%8E%E5%A4%A9%E5%86%B2%E4%B9%90%E9%AB%98%E6%9C%BA%E5%99%A8%E4%BA%BA%E9%9D%A2%E8%AF%95/</id>
    <published>2020-07-03T15:04:00.000Z</published>
    <updated>2020-07-03T15:12:29.731Z</updated>
    
    <content type="html"><![CDATA[<p>​    Boss直聘的信息还是比智联的靠谱，明天上午10：30去福中福应聘乐高机器人编程老师，人生第一次面试！<a id="more"></a>哈哈哈哈！可能也没多正规，也不一定会看简历，反正就上吧，就要求C++和python嘛，也看看机器人是怎么玩的；</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;​    Boss直聘的信息还是比智联的靠谱，明天上午10：30去福中福应聘乐高机器人编程老师，人生第一次面试！
    
    </summary>
    
    
      <category term="Privacy" scheme="http://Luweir.github.io/categories/Privacy/"/>
    
    
      <category term="记录" scheme="http://Luweir.github.io/tags/%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>Back from JiangSu</title>
    <link href="http://luweir.github.io/2020/07/02/Back%20from%20JiangSu/"/>
    <id>http://luweir.github.io/2020/07/02/Back%20from%20JiangSu/</id>
    <published>2020-07-02T15:15:02.000Z</published>
    <updated>2020-07-03T02:25:47.812Z</updated>
    
    <content type="html"><![CDATA[<p>​    今天从江苏回益阳，挺累的；一路上睡了很久，也思考了很久；大概就是想些最近的事吧；<a id="more"></a>先是人工智能的那个竞赛，我们组是在线试衣系统，目前在攻克生成1：1线上模型的解决方案；然后就是华为杯数学建模的比赛，暂时处于培训阶段，准备先把这些资料弄熟吧，跟着培训的进度，有人指点总有好处；然后就是自己又想在Github上找些项目做，在深度学习方向有所进展，读研也要跟着导师走这条路的；最后还想自己赚钱，先赚小几千跟YLL出去旅个游吧，不求经济独立，只求有些收入；</p><p>​    事是有点多奥，还有驾照的事，十来号就要考科三了，这几天得抓紧练，一次过了啥都好说！慢慢来吧，事多急也没用，反而容易啥都干不好；</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;​    今天从江苏回益阳，挺累的；一路上睡了很久，也思考了很久；大概就是想些最近的事吧；
    
    </summary>
    
    
      <category term="Privacy" scheme="http://Luweir.github.io/categories/Privacy/"/>
    
    
      <category term="记录" scheme="http://Luweir.github.io/tags/%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>位运算的巧妙之处</title>
    <link href="http://luweir.github.io/2020/06/30/%E4%BD%8D%E8%BF%90%E7%AE%97%E7%9A%84%E5%B7%A7%E5%A6%99%E4%B9%8B%E5%A4%84/"/>
    <id>http://luweir.github.io/2020/06/30/%E4%BD%8D%E8%BF%90%E7%AE%97%E7%9A%84%E5%B7%A7%E5%A6%99%E4%B9%8B%E5%A4%84/</id>
    <published>2020-06-30T05:59:59.000Z</published>
    <updated>2020-06-30T07:47:16.240Z</updated>
    
    <content type="html"><![CDATA[<h1 id="位运算的巧妙之处"><a href="#位运算的巧妙之处" class="headerlink" title="位运算的巧妙之处"></a>位运算的巧妙之处</h1><p>算法中，位运算可以巧妙运用在一下几个方面：</p><p>1、判断奇偶数  =&gt;  x&amp;1</p><p>2、判断数x中第k ( 从右至左 ) 位是1还是0  </p><p>法1：<code>( x &gt;&gt; ( k - 1 ) ) &amp; 1</code></p><p><img src="https://tacotuesdayyy.oss-cn-shenzhen.aliyuncs.com/umg/aHR0cHM6Ly90YWNvdHVlc2RheXl5Lm9zcy1jbi1zaGVuemhlbi5hbGl5dW5jcy5jb20vdW1nLzIwMjAwNTE4MjEyNDI0LnBuZw" alt="img"></p><p>法2：<code>x &amp; ( 1 &lt;&lt; ( k - 1 ) )</code></p><p>3、交换两个整数变量 a , b 的值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = a ^ b;</span><br><span class="line">b = b ^ a;</span><br><span class="line">a = a ^ b;</span><br></pre></td></tr></table></figure><p>这里为什么能这样做，在后面的异或运算中会说明；</p><p>4、不用判断语句，求整数绝对值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> (value ^ (value &gt;&gt; <span class="number">31</span>))-(value &gt;&gt;<span class="number">31</span>)</span><br></pre></td></tr></table></figure><p>同样在异或运算中说明；</p><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><h3 id="二进制中1的个数"><a href="#二进制中1的个数" class="headerlink" title="二进制中1的个数"></a>二进制中1的个数</h3><p><strong>描述</strong>：实现一个函数，输入一个正整数，输出该数二进制表示中1的个数。</p><p>例：9的二进制表示为1001，有2位是1；</p><p><strong>思路</strong>：循环运用判断x的第k位是否为1的方法；</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly90YWNvdHVlc2RheXl5Lm9zcy1jbi1zaGVuemhlbi5hbGl5dW5jcy5jb20vdW1nL0NBQ0E3QjlEOTBFNEI3MEFFMUE0RTE1RUI2RkY4RENCLnBuZw?x-oss-process=image/format,png" alt=""></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(value)</span><br><span class="line">&#123;</span><br><span class="line">count += value &amp; <span class="number">1</span>;</span><br><span class="line">value = value &gt;&gt; <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> count;</span><br></pre></td></tr></table></figure><p>方法二：</p><p>&amp;运算有这样一个性质：a = ( a - 1 ) &amp; a ； 这样a就能<strong>消除最低位的一个1</strong>；</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly90YWNvdHVlc2RheXl5Lm9zcy1jbi1zaGVuemhlbi5hbGl5dW5jcy5jb20vdW1nL0UwOTA3MzlDMkFEQzIwN0Q2OTEzMTBDRUZBMDQ0NzM5LnBuZw?x-oss-process=image/format,png" alt=""></p><p>思路：利用这一性质，我们可以每次将value-1，然后与自己&amp;，能做多少次这样的操作就说明有多少个1；</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(value)</span><br><span class="line">&#123;</span><br><span class="line">value = (value - <span class="number">1</span>) &amp; value;</span><br><span class="line">count++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> count;</span><br></pre></td></tr></table></figure><h1 id="异或运算的巧妙之处"><a href="#异或运算的巧妙之处" class="headerlink" title="异或运算的巧妙之处"></a>异或运算的巧妙之处</h1><h2 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h2><p>异或又称不进位加法，两个数相异或，对应位相同则为0，不同则为1；</p><p>具有以下性质：</p><p>1、a ^ a = 0；</p><p>2、0 ^ a = a；</p><p>3、异或具有交换律和结合律</p><pre><code>b ^ c = c ^ b；a ^ b ^ c = a ^ ( b ^ c) = ( a ^ b ) ^ c；</code></pre><p>4、( -1 ) ^ a =！a;</p><h2 id="应用-1"><a href="#应用-1" class="headerlink" title="应用"></a>应用</h2><h3 id="交换两个变量的值"><a href="#交换两个变量的值" class="headerlink" title="交换两个变量的值"></a>交换两个变量的值</h3><p>交换变量a,b的值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = a ^ b;</span><br><span class="line">b = b ^ a;</span><br><span class="line">a = a ^ b;</span><br></pre></td></tr></table></figure><p>利用异或运算的交换律和结合律，可以得到如下：</p><p>1、a = a ^ b;</p><p>2、b = b ^ a;</p><p>把1式代入2式中，此时 b = b ^ ( a ^ b ) ，则 b = b ^ b ^ a = a;</p><p>3、a = a ^ b;</p><p>将1式和 b = a 代入3式，则 a = a ^ b ^ a = b;</p><h3 id="不用判断语句，求整数绝对值"><a href="#不用判断语句，求整数绝对值" class="headerlink" title="不用判断语句，求整数绝对值"></a>不用判断语句，求整数绝对值</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> (value ^ (value &gt;&gt; <span class="number">31</span>))-(value &gt;&gt;<span class="number">31</span>)</span><br></pre></td></tr></table></figure><p>1、若value为正数，则value二进制表示中最高位一定为0，那么 value &gt;&gt; 31 =0;</p><p>value ^ (value &gt;&gt; 31) = value ^ 0 = value;</p><p>value - (value &gt;&gt; 31) = value - 0 = value;</p><p>即正数的绝对值仍是自身；</p><p>2、若value为负数，则value二进制表示中最高位一定为1，那么 value &gt;&gt; 31 = 111…1 ,一共32个1，即-1；</p><p>value ^ (value &gt;&gt; 31) = ! value;</p><p>而负数以补码形式存放，==补码等于绝对值的原码取反+1==；</p><p>那么这里 ! value - (value &gt;&gt; 31) =&gt; ! value +1 即得到的是value的绝对值；</p><p>如果理解有困难，可以看这个例子：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly90YWNvdHVlc2RheXl5Lm9zcy1jbi1zaGVuemhlbi5hbGl5dW5jcy5jb20vdW1nLzA2N0M4MUQ0RTkzRTQwMDY1REZEODU4M0VGOTYxQkVBLnBuZw?x-oss-process=image/format,png" alt=""></p><h3 id="如何找唯一成对的数？"><a href="#如何找唯一成对的数？" class="headerlink" title="如何找唯一成对的数？"></a>如何找唯一成对的数？</h3><p><strong>问题描述</strong>：1-1000这1000个数放在含有1001个元素的数组中，只有唯一的一个元素值重复，其它均只出现一次。每个数组元素只能访问一次，在不用辅助存储空间的前提下，设计一个算法，将它找出来；</p><p><strong>思路</strong>：根据异或性质1： a ^ a = 0；可以用来==去重==；</p><p>令T = 1 ^ 2 ^ 3 ^….. ^ 1000 ；</p><p>那么遍历数组的同时将当前数字与 T 异或，在数组中只出现一次的数字会与 T 中的该数字相抵消，从而去重；最终会剩下重复的那个元素，因为它在数组和T中一共出现3次；</p><p>举一个只有11个数的例子：         重复的元素在任意位置出现都是可以找出来的；</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly90YWNvdHVlc2RheXl5Lm9zcy1jbi1zaGVuemhlbi5hbGl5dW5jcy5jb20vdW1nLzA0NDlCNzNDOTc1QzE5MkE1OUIzREU1OTBEQzAyODNDLnBuZw?x-oss-process=image/format,png" alt=""></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> T=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">1000</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">T=T^i;      </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">1000</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">T=T^A[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> T;</span><br></pre></td></tr></table></figure><p>如有错误，感谢指正！</p>]]></content>
    
    <summary type="html">
    
      深入了解位运算并使用它解决问题
    
    </summary>
    
    
      <category term="Algorithm" scheme="http://Luweir.github.io/categories/Algorithm/"/>
    
    
      <category term="Bit" scheme="http://Luweir.github.io/tags/Bit/"/>
    
  </entry>
  
  <entry>
    <title>十大经典排序算法C++实现及总结</title>
    <link href="http://luweir.github.io/2020/06/30/%E5%8D%81%E5%A4%A7%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95C-%E5%AE%9E%E7%8E%B0%E5%8F%8A%E6%80%BB%E7%BB%93/"/>
    <id>http://luweir.github.io/2020/06/30/%E5%8D%81%E5%A4%A7%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95C-%E5%AE%9E%E7%8E%B0%E5%8F%8A%E6%80%BB%E7%BB%93/</id>
    <published>2020-06-30T05:58:23.000Z</published>
    <updated>2020-06-30T05:59:43.749Z</updated>
    
    <content type="html"><![CDATA[<h1 id="算法性能总结"><a href="#算法性能总结" class="headerlink" title="算法性能总结"></a>算法性能总结</h1><p><img src="https://img-blog.csdnimg.cn/20200510135640764.jpeg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3d5bGwxOTk4MDgxMg==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h1 id="1、冒泡排序"><a href="#1、冒泡排序" class="headerlink" title="1、冒泡排序"></a>1、冒泡排序</h1><p><img src="https://img-blog.csdnimg.cn/20200510140633159.gif#pic_center" alt="在这里插入图片描述"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1、Bubble Sort 冒泡排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (length &lt; <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length - <span class="number">1</span>; i++) <span class="comment">//需length-1趟排序确定后length-1个数，剩下第一个数不用排序；</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; length - <span class="number">1</span> - i; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[j + <span class="number">1</span>] &lt; a[j])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> temp = a[j + <span class="number">1</span>];</span><br><span class="line">                a[j + <span class="number">1</span>] = a[j];</span><br><span class="line">                a[j] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="2、选择排序"><a href="#2、选择排序" class="headerlink" title="2、选择排序"></a>2、选择排序</h1><p><img src="https://img-blog.csdnimg.cn/20200510140552757.gif#pic_center" alt="在这里插入图片描述"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//2、Select Sort 选择排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">selectSort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (length &lt; <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> minIndex = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; length; j++) <span class="comment">//已确定a[0]~a[i-1],从i-1开始查找最小的数，然后与a[i]交换位置；</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[j] &lt; a[minIndex])</span><br><span class="line">                minIndex = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> temp = a[i];</span><br><span class="line">        a[i] = a[minIndex];</span><br><span class="line">        a[minIndex] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="3、插入排序"><a href="#3、插入排序" class="headerlink" title="3、插入排序"></a>3、插入排序</h1><p><img src="https://img-blog.csdnimg.cn/20200510140706474.jpg#pic_center" alt="在这里插入图片描述"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//3、Insert Sort 插入排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertSort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (length &lt; <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; length; i++) <span class="comment">//现在进行插入的是a[i]</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> cur = a[i];</span><br><span class="line">        <span class="keyword">int</span> j = i;</span><br><span class="line">        <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; a[j - <span class="number">1</span>] &gt; cur) <span class="comment">//如果前面的数比cur大，说明cur要插在它们前面，即将它们后移一个位置；</span></span><br><span class="line">        &#123;</span><br><span class="line">            a[j] = a[j - <span class="number">1</span>];</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        a[j] = cur;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="4、希尔排序"><a href="#4、希尔排序" class="headerlink" title="4、希尔排序"></a>4、希尔排序</h1><p><img src="https://img-blog.csdnimg.cn/20200510141025753.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3d5bGwxOTk4MDgxMg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//4、Shell Sort 希尔排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shellSort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (length &lt; <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> gap = length / <span class="number">2</span>; <span class="comment">//整个数组分为gap个组，即每隔 gap-1 个位置的元素为一组</span></span><br><span class="line">    <span class="keyword">while</span> (gap &gt; <span class="number">0</span>)       <span class="comment">//最终整个数组分为一组 即所有元素为一组；</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = gap; i &lt; length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> cur = a[i];</span><br><span class="line">            <span class="keyword">int</span> preIndex = i - gap;</span><br><span class="line">            <span class="keyword">while</span> (preIndex &gt;= <span class="number">0</span> &amp;&amp; a[preIndex] &gt; cur) <span class="comment">//对每一组元素进行插入排序</span></span><br><span class="line">            &#123;</span><br><span class="line">                a[i] = a[preIndex];</span><br><span class="line">                preIndex -= gap;</span><br><span class="line">            &#125;</span><br><span class="line">            a[preIndex + gap] = cur;</span><br><span class="line">        &#125;</span><br><span class="line">        gap /= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="5、归并排序"><a href="#5、归并排序" class="headerlink" title="5、归并排序"></a>5、归并排序</h1><p><img src="https://img-blog.csdnimg.cn/20200510141619255.jpg#pic_center" alt="在这里插入图片描述"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//5、Merge Sort 归并排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> left, <span class="keyword">int</span> mid, <span class="keyword">int</span> right)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> <span class="comment">//  left需要排序数组 a[] 的左端下标，right为右端下标</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> length = right - left + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (length &lt; <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> mid = (right + left) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    mergeSort(a, <span class="number">0</span>, mid);</span><br><span class="line">    mergeSort(a, mid + <span class="number">1</span>, right);</span><br><span class="line">    merge(a, left, mid, right); <span class="comment">//调用merge函数 将二者合并</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> left, <span class="keyword">int</span> mid, <span class="keyword">int</span> right)</span> <span class="comment">//将数组a 的两个子数组a[left] ~ a[mid] 与 a[mid+1] ~ a[right] 合并</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = right - left + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; temp;</span><br><span class="line">    <span class="keyword">int</span> i = left, j = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; i &lt;= mid &amp;&amp; j &lt;= right;)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[i] &lt; a[j])</span><br><span class="line">        &#123;</span><br><span class="line">            temp.push_back(a[i]);</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            temp.push_back(a[j]);</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid)</span><br><span class="line">        temp.push_back(a[i++]); <span class="comment">//此时必有一个子数组没有走完 需要把剩下的元素全部放进vector</span></span><br><span class="line">    <span class="keyword">while</span> (j &lt;= right)</span><br><span class="line">        temp.push_back(a[j++]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = left, k = <span class="number">0</span>; i &lt;= right; i++) <span class="comment">//把vector中已排完序的元素存入数组a[left]~a[right]</span></span><br><span class="line">    &#123;</span><br><span class="line">        a[i] = temp[k++];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="6、快速排序"><a href="#6、快速排序" class="headerlink" title="6、快速排序"></a>6、快速排序</h1><p><img src="https://img-blog.csdnimg.cn/2020051014204349.gif#pic_center" alt="在这里插入图片描述"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//6、Quick Sort 快速排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left &gt;= right)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> key = a[left]; <span class="comment">//以第一个数为基数进行快排；</span></span><br><span class="line">    <span class="keyword">int</span> pointL = left, pointR = right;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (pointL &lt; pointR)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//一定要先动右指针，否则右指针所指向的元素无处存放</span></span><br><span class="line">        <span class="keyword">while</span> (pointR &gt; pointL &amp;&amp; a[pointR] &gt;= key) <span class="comment">//若右指针指向的元素大于key 则右指针左移，直到右指针指向的元素小于key 或者 左右指针坐标相同</span></span><br><span class="line">            pointR--;</span><br><span class="line">        a[pointL] = a[pointR]; <span class="comment">//把这个小于key的元素放到key的左边，即左指针指向的位置</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (pointR &gt; pointL &amp;&amp; a[pointL] &lt;= key) <span class="comment">//若左指针指向的元素小于key 则左指针右移，直到左指针指向的元素大于key 或者 左右指针坐标相同</span></span><br><span class="line">            pointL++;</span><br><span class="line">        a[pointR] = a[pointL]; <span class="comment">//把这个大于key的元素放到key的右边，即右指针指向的位置</span></span><br><span class="line">    &#125;</span><br><span class="line">    a[pointR] = key; <span class="comment">//此时左右指针指向同一位置，这个位置就是key应该放的位置</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//对key两边的元素同样使用快排</span></span><br><span class="line">    quickSort(a, left, pointR - <span class="number">1</span>);</span><br><span class="line">    quickSort(a, pointR + <span class="number">1</span>, right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="7、计数排序"><a href="#7、计数排序" class="headerlink" title="7、计数排序"></a>7、计数排序</h1><p><img src="https://img-blog.csdnimg.cn/20200510142135552.gif#pic_center" alt="在这里插入图片描述"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//7、Counting Sort 计数排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">countingSort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (length &lt; <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> min = a[<span class="number">0</span>], max = a[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> bios; <span class="comment">//偏移量</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) <span class="comment">//找最大最小值</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[i] &lt; min)</span><br><span class="line">            min = a[i];</span><br><span class="line">        <span class="keyword">if</span> (a[i] &gt; max)</span><br><span class="line">            max = a[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bios = <span class="number">0</span> - min;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">temp</span><span class="params">(max - min + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) <span class="comment">//把出现了的元素作为temp的下标 并置1；</span></span><br><span class="line">    &#123;</span><br><span class="line">        temp[a[i] + bios]++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; max - min + <span class="number">1</span>; i++) <span class="comment">//顺序扫描以便vector即可</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (temp[i])</span><br><span class="line">        &#123;</span><br><span class="line">            a[index++] = i - bios;</span><br><span class="line">            temp[i]--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="8、桶排序"><a href="#8、桶排序" class="headerlink" title="8、桶排序"></a>8、桶排序</h1><p><img src="https://img-blog.csdnimg.cn/20200510142409661.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3d5bGwxOTk4MDgxMg==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//8、Bucket Sort 桶排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bucketSort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (length &lt; <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> min = a[<span class="number">0</span>], max = a[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[i] &lt; min)</span><br><span class="line">            min = a[i];</span><br><span class="line">        <span class="keyword">if</span> (a[i] &gt; max)</span><br><span class="line">            max = a[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> buckNum = (max - min) / length + <span class="number">1</span>; <span class="comment">//桶的数量</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; bucketArr;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; buckNum; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; temp;</span><br><span class="line">        bucketArr.push_back(temp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//每个元素入桶</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> num = (a[i] - min) / length;</span><br><span class="line">        bucketArr[num].push_back(a[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对每个桶排序 并且排序完后赋值</span></span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bucketArr.size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (bucketArr[i].size())</span><br><span class="line">        &#123;</span><br><span class="line">            sort(bucketArr[i].begin(), bucketArr[i].end()); <span class="comment">//快排</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; bucketArr[i].size(); j++)</span><br><span class="line">            &#123;</span><br><span class="line">                a[index++] = bucketArr[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="9、基数排序"><a href="#9、基数排序" class="headerlink" title="9、基数排序"></a>9、基数排序</h1><p><img src="https://img-blog.csdnimg.cn/20200510142523884.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3d5bGwxOTk4MDgxMg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//9、Base Sort 基数排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">baseSort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> length)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//得到最大位数；</span></span><br><span class="line">    <span class="keyword">int</span> max = a[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> d = <span class="number">0</span>;<span class="comment">//最大位数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[i] &gt; max)</span><br><span class="line">            max = a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (max)</span><br><span class="line">    &#123;</span><br><span class="line">        max /= <span class="number">10</span>;</span><br><span class="line">        d++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> factor = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= d; i++) <span class="comment">//从个位数排到d位数</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; bucket[<span class="number">10</span>]; <span class="comment">//初始化十个桶</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = (a[i] / factor) % <span class="number">10</span>; <span class="comment">//得到a[i]的now_d位数，并放入对应桶中</span></span><br><span class="line">            bucket[temp].push_back(a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) <span class="comment">//遍历十个桶，按从小到大顺序放入原数组</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> size = bucket[i].size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; size; k++)</span><br><span class="line">            &#123;</span><br><span class="line">                a[j++] = bucket[i][k];</span><br><span class="line">            &#125;</span><br><span class="line">            bucket[i].clear(); <span class="comment">//桶置空</span></span><br><span class="line">        &#125;</span><br><span class="line">        factor *= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="10、堆排序"><a href="#10、堆排序" class="headerlink" title="10、堆排序"></a>10、堆排序</h1><p><img src="https://img-blog.csdnimg.cn/20200510142536785.gif#pic_center" alt="在这里插入图片描述"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//10、Heap Sort 堆排序   大顶堆做出来顺序，小顶堆做出来逆序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fixDown</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> i, <span class="keyword">int</span> length)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//先对 a 堆化</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = length / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) </span><br><span class="line">    &#123;</span><br><span class="line">        fixDown(a, i, length); <span class="comment">//把i当前小顶堆的根节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 完成后 此时a已经是合法的小顶堆</span></span><br><span class="line">    <span class="comment">//调整堆结构</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x = length - <span class="number">1</span>; x &gt; <span class="number">0</span>; x--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//把堆顶元素(0号元素)和末尾元素对调；</span></span><br><span class="line">        swap(a, <span class="number">0</span>, x);</span><br><span class="line">        <span class="comment">//缩小堆的范围，对堆顶元素进行向下调整；</span></span><br><span class="line">        fixDown(a, <span class="number">0</span>, x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fixDown</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> i, <span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//找到左右子孩子</span></span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">2</span> * i + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> right = <span class="number">2</span> * i + <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> min = left;     <span class="comment">//min指向左右孩子中较小的那个</span></span><br><span class="line">    <span class="keyword">if</span> (left &gt;= length) <span class="comment">//若左孩子越界则右孩子必越界</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (right &lt; length &amp;&amp; a[right] &lt; a[left]) <span class="comment">//右孩子未越界并且右孩子值比左孩子小</span></span><br><span class="line">        min = right;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果a[i]比这两个孩子的值都要小，则不用调整；</span></span><br><span class="line">    <span class="keyword">if</span> (a[i] &lt; a[min])</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//否则，其值和a[i]交换；</span></span><br><span class="line">    swap(a, i, min);</span><br><span class="line">    <span class="comment">//小孩子那个位置的值发生变化，i变更为小孩子的那个位置，于是递归调整；</span></span><br><span class="line">    fixDown(a, min, length);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = a[i];</span><br><span class="line">    a[i] = a[j];</span><br><span class="line">    a[j] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1、Bubble Sort 冒泡排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> length)</span></span>;</span><br><span class="line"><span class="comment">//2、Select Sort 选择排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">selectSort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> length)</span></span>;</span><br><span class="line"><span class="comment">//3、Insert Sort 插入排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertSort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> length)</span></span>;</span><br><span class="line"><span class="comment">//4、Shell Sort 希尔排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shellSort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> length)</span></span>;</span><br><span class="line"><span class="comment">//5、Merge Sort 归并排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> left, <span class="keyword">int</span> mid, <span class="keyword">int</span> right)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>;</span><br><span class="line"><span class="comment">//6、Quick Sort 快速排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>;</span><br><span class="line"><span class="comment">//7、Counting Sort 计数排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">countingSort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> length)</span></span>;</span><br><span class="line"><span class="comment">//8、Bucket Sort 桶排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bucketSort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> length)</span></span>;</span><br><span class="line"><span class="comment">//9、Base Sort 基数排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">baseSort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> length)</span></span>;</span><br><span class="line"><span class="comment">//10、Heap Sort 堆排序   大顶堆做出来顺序，小顶堆做出来逆序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fixDown</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> i, <span class="keyword">int</span> length)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">8</span>] = &#123;<span class="number">3</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">10</span>&#125;;</span><br><span class="line">    <span class="comment">// bubbleSort(a, 8);</span></span><br><span class="line">    <span class="comment">// selectSort(a,8);</span></span><br><span class="line">    <span class="comment">// insertSort(a, 8);</span></span><br><span class="line">    <span class="comment">// shellSort(a, 8);</span></span><br><span class="line">    <span class="comment">// mergeSort(a, 0, 7);</span></span><br><span class="line">    <span class="comment">// quickSort(a, 0, 7);</span></span><br><span class="line">    <span class="comment">// countingSort(a, 8);</span></span><br><span class="line">    <span class="comment">// bucketSort(a, 8);</span></span><br><span class="line">    <span class="comment">// baseSort(a, 8);</span></span><br><span class="line">    heapSort(a, <span class="number">8</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; a[i] &lt;&lt; <span class="string">' '</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如有错误，欢迎评论指正，谢谢！</p>]]></content>
    
    <summary type="html">
    
      回顾排序算法并用C++写出
    
    </summary>
    
    
      <category term="Algorithm" scheme="http://Luweir.github.io/categories/Algorithm/"/>
    
    
      <category term="Sort" scheme="http://Luweir.github.io/tags/Sort/"/>
    
  </entry>
  
  <entry>
    <title>多维数组和矩阵</title>
    <link href="http://luweir.github.io/2020/06/30/%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84%E5%92%8C%E7%9F%A9%E9%98%B5/"/>
    <id>http://luweir.github.io/2020/06/30/%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84%E5%92%8C%E7%9F%A9%E9%98%B5/</id>
    <published>2020-06-30T05:56:53.000Z</published>
    <updated>2020-06-30T05:57:59.381Z</updated>
    
    <content type="html"><![CDATA[<h1 id="T-1：顺时针打印二维数组"><a href="#T-1：顺时针打印二维数组" class="headerlink" title="T 1：顺时针打印二维数组"></a>T 1：顺时针打印二维数组</h1><p>这个问题看起来很容易，逻辑清晰，但实现起来还是复杂些，要考虑到不能重复打印，超出边界；</p><p><img src="https://tacotuesdayyy.oss-cn-shenzhen.aliyuncs.com/umg/6D9767219FAE9AF7C2366339F14CE90D.png" alt="img"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printMatrix</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> leftuprow = <span class="number">0</span>, leftupcol = <span class="number">0</span>, rightdownrow = a.size()<span class="number">-1</span>, rightdowncol = a[<span class="number">0</span>].size()<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">while</span> (leftuprow &lt;= rightdownrow &amp;&amp; leftupcol &lt;= rightdowncol)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> r = leftuprow;</span><br><span class="line"><span class="keyword">int</span> c = leftupcol;</span><br><span class="line"><span class="keyword">while</span> (c &lt;=rightdowncol)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a[r][c++]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line">c = rightdowncol;</span><br><span class="line">r = leftuprow+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (r &lt;= rightdownrow)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a[r++][c] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line">r = rightdownrow;</span><br><span class="line">c = rightdowncol - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (c &gt;= leftupcol)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a[r][c--]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line">c = leftupcol;</span><br><span class="line">r = rightdownrow - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (r &gt; leftuprow)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a[r--][c] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line">leftupcol++;</span><br><span class="line">leftuprow++;</span><br><span class="line">rightdowncol--;</span><br><span class="line">rightdownrow--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; test;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">12</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; temp;</span><br><span class="line"><span class="keyword">while</span> (i%<span class="number">4</span>)</span><br><span class="line">&#123;</span><br><span class="line">temp.push_back(i++);</span><br><span class="line">&#125;</span><br><span class="line">temp.push_back(i);</span><br><span class="line">test.push_back(temp);</span><br><span class="line">&#125;</span><br><span class="line">printMatrix(test);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="T-2：将0所在的行列清零"><a href="#T-2：将0所在的行列清零" class="headerlink" title="T 2：将0所在的行列清零"></a>T 2：将0所在的行列清零</h1><p> 如果矩阵中某个元素为0，则将其所在行和列清零；</p><p><img src="https://tacotuesdayyy.oss-cn-shenzhen.aliyuncs.com/umg/36A2FA5854D74B2030A76CABEBA1C05E.png" alt="img"></p><p>可能会想到，我一边遍历矩阵，遇到0就将它所在行列全部清0；</p><p>但这样存在一个问题：如果某一行有多个0，遇到第一个0，会将本行和该列清0，那么循环遍历下去，这一行剩下的都是0，会将这些本不该清0的列都清0；</p><p>思路：把每个值为0的位置标记，最后统一对它们所在的行和列清0；</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setZero</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; result;</span><br><span class="line"><span class="keyword">int</span> lenRow=a.size(),lenCol=a[<span class="number">0</span>].size();</span><br><span class="line">    </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;lenRow;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;lenCol;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(a[i][j]==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; temp;</span><br><span class="line">temp.push_back(i);</span><br><span class="line">temp.push_back(j);</span><br><span class="line">result.push_back(temp);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> r:result)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> row=r[<span class="number">0</span>],col=r[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;lenCol;i++)</span><br><span class="line">&#123;</span><br><span class="line">a[i][col]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;lenRow;i++)</span><br><span class="line">&#123;</span><br><span class="line">a[row][i]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; test;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">16</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; temp;</span><br><span class="line"><span class="keyword">while</span> (i%<span class="number">4</span>)</span><br><span class="line">&#123;</span><br><span class="line">temp.push_back(i++);</span><br><span class="line">&#125;</span><br><span class="line">temp.push_back(i);</span><br><span class="line">test.push_back(temp);</span><br><span class="line">&#125;</span><br><span class="line">test[<span class="number">1</span>][<span class="number">2</span>]=<span class="number">0</span>;</span><br><span class="line">test[<span class="number">2</span>][<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">setZero(test);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> a:test)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> aa:a)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;aa&lt;&lt;<span class="string">' '</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="T-3：Z字形打印"><a href="#T-3：Z字形打印" class="headerlink" title="T 3：Z字形打印"></a>T 3：Z字形打印</h1><p>  <img src="https://tacotuesdayyy.oss-cn-shenzhen.aliyuncs.com/umg/2C048FA071C38FA6CA1CDE0A01B7E73D.png" alt="img"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Z</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> r = <span class="number">0</span>, m = a.size();<span class="comment">//m=最大行数</span></span><br><span class="line"><span class="keyword">int</span> c = <span class="number">0</span>, n = a[<span class="number">0</span>].size();<span class="comment">//n=最大列数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> dir = <span class="literal">true</span>; <span class="comment">//控制方向，true为向上，false为向下</span></span><br><span class="line"><span class="keyword">while</span> (r &lt; m &amp;&amp; c &lt; n)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//从左下到右上，走上坡</span></span><br><span class="line"><span class="keyword">if</span> (dir)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a[r][c] &lt;&lt; <span class="string">' '</span>;</span><br><span class="line"><span class="keyword">if</span> (r == <span class="number">0</span> &amp;&amp; c &lt; n - <span class="number">1</span>) <span class="comment">//到第一行，但未到列边界，只能往右走</span></span><br><span class="line">&#123;</span><br><span class="line">dir = !dir;</span><br><span class="line">c++;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (r &lt; m - <span class="number">1</span> &amp;&amp; c == n - <span class="number">1</span>) <span class="comment">//到最后一列，未到最后一行，只能向下走</span></span><br><span class="line">&#123;</span><br><span class="line">dir = !dir;</span><br><span class="line">r++;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">r--;</span><br><span class="line">c++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="comment">//相反，走下坡</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a[r][c] &lt;&lt; <span class="string">' '</span>;</span><br><span class="line"><span class="keyword">if</span> (c == <span class="number">0</span> &amp;&amp; r &lt; m - <span class="number">1</span>) <span class="comment">//到第一列，未到最后一行，只能往下走</span></span><br><span class="line">&#123;</span><br><span class="line">dir = !dir;</span><br><span class="line">r++;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (r == m - <span class="number">1</span> &amp;&amp; c &lt; n - <span class="number">1</span>) <span class="comment">//到最后一行，未到最后一列，只能向右走</span></span><br><span class="line">&#123;</span><br><span class="line">dir = !dir;</span><br><span class="line">c++;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">r++;</span><br><span class="line">c--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="T-4：子数组的最大累加和"><a href="#T-4：子数组的最大累加和" class="headerlink" title="T 4：子数组的最大累加和"></a>T 4：子数组的最大累加和</h1><p>给定一个数组，返回子数组的最大累加和；</p><p>如 a = {1,-2,3,5,-2,6,-1};所有的子数组中[3,5,-2,6]可以累加出最大的和12；</p><p><strong>思路：若累加到当前数的和sum为负，那么比较sum和max，若sum比max大，则更新max，并中断此次累加操作（因为无论下个数next是正是负，sum+next都比next小），从下一个数开始累加；</strong></p><p><strong>若加到当前数的和sum为正，则继续累加下去，每次累加比较和max的大小；</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = nums.size();</span><br><span class="line">    <span class="keyword">if</span> (len == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>, maxSum = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        sum += nums[i];</span><br><span class="line">        <span class="keyword">if</span> (sum &gt; maxSum)</span><br><span class="line">            maxSum = sum;</span><br><span class="line">        <span class="keyword">if</span> (sum &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            sum = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxSum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>详情见<a href="https://blog.csdn.net/wyll19980812/article/details/105899832" target="_blank" rel="noopener">Leetcode第53题：最大子序和</a>；</p><h1 id="T-5：矩阵的乘法"><a href="#T-5：矩阵的乘法" class="headerlink" title="T 5：矩阵的乘法"></a>T 5：矩阵的乘法</h1><p><img src="https://tacotuesdayyy.oss-cn-shenzhen.aliyuncs.com/umg/image-20200607120125129.png" alt="image-20200607120125129"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">mutMatrix</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; m1, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; m2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n = m1.size();  <span class="comment">//矩阵1的行数</span></span><br><span class="line"><span class="keyword">int</span> m = m1[<span class="number">0</span>].size(); <span class="comment">//矩阵1的列数,矩阵2的行数肯定和矩阵1的列数相同</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> p = m2[<span class="number">0</span>].size(); <span class="comment">//矩阵2的列数</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; result;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; temp;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; p; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; m; k++)</span><br><span class="line">&#123;</span><br><span class="line">sum += m1[i][k] * m2[k][j];</span><br><span class="line">&#125;</span><br><span class="line">temp.push_back(sum);</span><br><span class="line">&#125;</span><br><span class="line">result.push_back(temp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      学习多维数组、矩阵并解决相关问题；
    
    </summary>
    
    
      <category term="Algorithm" scheme="http://Luweir.github.io/categories/Algorithm/"/>
    
    
      <category term="数组" scheme="http://Luweir.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>递归</title>
    <link href="http://luweir.github.io/2020/06/30/%E9%80%92%E5%BD%92/"/>
    <id>http://luweir.github.io/2020/06/30/%E9%80%92%E5%BD%92/</id>
    <published>2020-06-30T05:54:39.000Z</published>
    <updated>2020-06-30T05:57:01.447Z</updated>
    
    <content type="html"><![CDATA[<h1 id="递归思路"><a href="#递归思路" class="headerlink" title="递归思路"></a>递归思路</h1><p>1、找重复：找出子问题</p><p>2、找变化：变化的量应该作为参数；</p><p>3、找边界：设计函数的出口；</p><h1 id="T-1：求阶乘"><a href="#T-1：求阶乘" class="headerlink" title="T 1：求阶乘"></a>T 1：求阶乘</h1><p>输入n，使用递归的方法输出n！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Rec</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> n*Rec(n<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="T-2：求数组元素和"><a href="#T-2：求数组元素和" class="headerlink" title="T 2：求数组元素和"></a>T 2：求数组元素和</h1><p>对arr的所有元素求和</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Rec</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; arr,<span class="keyword">int</span> begin)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (begin == arr.size() - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> arr[begin];</span><br><span class="line">    <span class="keyword">return</span> arr[begin] + Rec(arr,begin + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="T-3：斐波那契数列"><a href="#T-3：斐波那契数列" class="headerlink" title="T 3：斐波那契数列"></a>T 3：斐波那契数列</h1><p>f(0)=1</p><p>f(1)=1</p><p>f(2)=f(0)+f(1)=2</p><p>f(3)=f(1)+f(2)=3</p><p>f(n)=f(n-2)+f(n-1)</p><p>输入n，求f(n)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Feb</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">0</span> || n==<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> Feb(n<span class="number">-2</span>)+Feb(n<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="T-4：最大公约数"><a href="#T-4：最大公约数" class="headerlink" title="T 4：最大公约数"></a>T 4：最大公约数</h1><p>输入m，n，求它俩的最大公约数(m&gt;n)</p><p><img src="https://tacotuesdayyy.oss-cn-shenzhen.aliyuncs.com/umg/D1AA4BA544FAD099236791A033D02C40.png" alt="img"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Rec</span><span class="params">(<span class="keyword">int</span> m,<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    <span class="keyword">return</span> Rec(n,m%n)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="T-5：插入排序改递归"><a href="#T-5：插入排序改递归" class="headerlink" title="T 5：插入排序改递归"></a>T 5：插入排序改递归</h1><p>使用递归的方法对数组arr进行排序；</p><p><img src="https://tacotuesdayyy.oss-cn-shenzhen.aliyuncs.com/umg/0987DC5E0C739BD06B069661E8A9D4C7.png" alt=""></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;arr, <span class="keyword">int</span> pos)</span><span class="comment">//对arr[0]-arr[pos]进行排序</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (pos == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">insertSort(arr, pos - <span class="number">1</span>);<span class="comment">//等pos前面的元素都排序完了，我再对pos元素进行排序；</span></span><br><span class="line"><span class="keyword">int</span> p = pos;</span><br><span class="line"><span class="keyword">int</span> val = arr[p];</span><br><span class="line"><span class="keyword">while</span> (p &gt; <span class="number">0</span> &amp;&amp; val &lt; arr[p - <span class="number">1</span>])<span class="comment">//只要比前面的元素小，就继续向前找位置</span></span><br><span class="line">&#123;</span><br><span class="line">arr[p] = arr[p - <span class="number">1</span>];</span><br><span class="line">p--;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//此时arr[p]&gt;arr[p-1]，在此位置插入；</span></span><br><span class="line">arr[p] = val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="T-6：汉诺塔问题"><a href="#T-6：汉诺塔问题" class="headerlink" title="T 6：汉诺塔问题"></a>T 6：汉诺塔问题</h1><p> A B C三处，将A处的n个盘子移动到C处，每次只能移动1个盘子，下盘子只能放在大盘子上面；</p><p><img src="https://tacotuesdayyy.oss-cn-shenzhen.aliyuncs.com/umg/timg" alt="n=3时"></p><p><img src="https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1591377131142&di=e447a26477dff87d89a6b6b7011c7856&imgtype=0&src=http%3A%2F%2F5b0988e595225.cdn.sohucs.com%2Fimages%2F20180221%2Fd3f07e39985b4f91a0d6d367d4edfca4.gif" alt="n=6时"></p><p>1、找重复：把n块盘子从A移动到C，那么我只需叫人通过中介C帮我把n-1个盘子移动到B处，然后我把第n个盘子移动到C处，再叫别人把B处的n-1个盘子通过中介A挪到C处；</p><p>2、找变化：移动过程中，<strong>初始地、中介、目的地以及目前移动的哪块盘子</strong>都不一样，这些都是变化量；</p><p>3、找边界：如果n==0时，不存在第0块盘子，所以此时什么都不用做，返回即可；</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Hanuo</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">char</span> begin, <span class="keyword">char</span> help, <span class="keyword">char</span> dest)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (n &lt; <span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">Hanuo(n - <span class="number">1</span>, begin, dest, help);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"move "</span> &lt;&lt; n &lt;&lt; <span class="string">" from "</span> &lt;&lt; begin &lt;&lt; <span class="string">" to "</span> &lt;&lt; dest &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">Hanuo(n - <span class="number">1</span>, help, begin, dest);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Hanuo(<span class="number">3</span>, <span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="T-7：二分查找的递归算法"><a href="#T-7：二分查找的递归算法" class="headerlink" title="T 7：二分查找的递归算法"></a>T 7：二分查找的递归算法</h1><p>对于有序数组arr，输入key，使用递归形式的二分查找方法查找key所对应的索引；</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BinarySearch</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(left &gt; right) <span class="comment">//此时表示在数组arr中找不到该key值</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//二分查找</span></span><br><span class="line"><span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (arr[mid] == key)</span><br><span class="line"><span class="keyword">return</span> mid;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (arr[mid] &lt; key)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> BinarySearch(arr, mid + <span class="number">1</span>, right, key);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> BinarySearch(arr, left, mid - <span class="number">1</span>, key);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="递归性能"><a href="#递归性能" class="headerlink" title="递归性能"></a>递归性能</h1><p>递归的时间复杂度取决于子问题的分支数；</p><p>比如求阶乘的时间复杂度为O(n)，而斐波那契时间复杂度大约为O(2^n^);</p><p><img src="https://tacotuesdayyy.oss-cn-shenzhen.aliyuncs.com/umg/129A733126CAE2E88E14342CDE22066A.png" alt=""></p><p>因为分支数越多意味着有更多的<strong>冗余运算</strong>，即多做了很多次重复的计算，这是就需要动态规划或者非递归的迭代形式来降低复杂度；</p><p>由于递归重复调用当前函数，函数主要使用栈空间，所以递归的空间复杂度也较高；</p><p>但递归有个最大的好处就是：==容易理解==；</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>==递归就是偷懒==：</p><p>​        我解决问题的一个部分，剩下的交给别人处理；或者理解为一个蛋糕，我只切一小块，剩下的怎么分交给别人完成；</p>]]></content>
    
    <summary type="html">
    
      学习递归思路并解决问题
    
    </summary>
    
    
      <category term="Algorithm" scheme="http://Luweir.github.io/categories/Algorithm/"/>
    
    
      <category term="递归" scheme="http://Luweir.github.io/tags/%E9%80%92%E5%BD%92/"/>
    
  </entry>
  
  <entry>
    <title>心理学-影响力</title>
    <link href="http://luweir.github.io/2020/06/30/%E5%BF%83%E7%90%86%E5%AD%A6-%E5%BD%B1%E5%93%8D%E5%8A%9B/"/>
    <id>http://luweir.github.io/2020/06/30/%E5%BF%83%E7%90%86%E5%AD%A6-%E5%BD%B1%E5%93%8D%E5%8A%9B/</id>
    <published>2020-06-30T02:26:01.000Z</published>
    <updated>2020-06-30T02:27:43.324Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-作者介绍"><a href="#1-作者介绍" class="headerlink" title="1. 作者介绍"></a>1. 作者介绍</h1><p>本书《影响力》作者：<strong>罗伯特·西奥迪尼</strong>(Robert B．Cialdirli)，”影响力教父”，著名社会心理学家；</p><p>点评鉴赏：<br>1、西奥迪尼在影响力方面对我的影响，其他任何科学家都比不上……这本最佳畅销书呈现了六至八种方法，让你精灵古怪的想法不会再阻碍你获得最佳利益。——查理·芒格巴菲特的黄金搭档，伯克希尔·哈撒韦公司副总裁<br>2、如果总统只能随时向—位顾问请教的话，我推荐当今世界最了不起的社会心理学家、影响力大师——西奥迪尼。——《助推》作者理查德·泰勒<br>3、在谈判中，如果所有事情都僵持不下，除了西奥迪尼我再也想不到还有谁可以给我建议。——全球最著名的管理学大师之一，商界教皇汤姆·彼得斯<br>4、西奥迪尼的书是我们在FBl遥遥领先的基础，他的书使职业谈判专员成长为危机干预者。我们借鉴了西奥迪尼书里的很多内容。我们观察人们是怎样对别人施加影响的，发现影响是通过建立关系，赢得信任，并对别人的问题和关心的事情真正感兴趣而获得的。——FBI谈判专员，作家加里·内斯纳<br>5、西奥迪尼《影响力》—书中的素材宛如一座金矿。——《社会与临床心理学杂志》<br>6、如果你的时间只够看一本书，那就看《影响力》吧。——《全新销售》作者丹尼尔·平克<br>7、西奥迪尼是社会心理学的真正先驱之一。——哈佛大学心理学教授，《撞上快乐》作者丹尼尔·吉尔伯特<br>8、对从事市场营销的人员来说，本书是过去十年中最重要的著作之一。——《市场营销研究杂志》</p><h1 id="2-影响力的武器"><a href="#2-影响力的武器" class="headerlink" title="2. 影响力的武器"></a>2. 影响力的武器</h1><p>当某一个触发特征出现时，我们会不假思索地作出相应的反应，之所以会这样，就是因为我们被难以察觉的影响力武器摆布了；</p><p><strong>Q：为什么无人问津的东西，价格翻倍后，反而被一抢而空？</strong></p><blockquote><p>哈佛心理学家埃伦·兰格得出结论：我们在需要别人帮忙的时候，要是能给一个理由，成功的概率会更大；</p></blockquote><p>这里亦是如此，对于稍微富裕的人，他们用一套标准准则来指导自己买东西：一分钱一分货，价格贵等于东西好，才有买的必要；再加上他们对这个东西的了解甚少时，他们自然而然会用上价格这个一贯的准绳；即<strong>价格本身成为了质量的触发特征</strong>；<br>而就算提价效果不佳，卖家仍可以按标价打折，面对虚高的标价，消费者仍然会产生“贵=好”的反应；</p><p><strong>Q：为什么房地产商在售楼时，先带顾客去看没人会买的破房子？</strong></p><blockquote><p>知觉对比心理：如果两个东西本来就有很大不同，然后一前一后地展示出来，我们往往会认为两者的区别     比实际上更大；就像售货员往往先展示昂贵地物件；</p></blockquote><p>先看标上虚高价的破房子，再带顾客看真正想卖的地方，正是利用对比心理；</p><p><strong>Q：为什么汽车经销商在顾客掏钱买车后才会建议顾客买各种配件？</strong><br>同样运用对比心理，几万元的生意要成交了，再花一些几百元升级以下配件似乎微不足道；即使这些价格单个看上去没多少，合在一起，整个车的价格就好像注水猪肉一般涨上去了；</p><h1 id="3-互惠"><a href="#3-互惠" class="headerlink" title="3. 互惠"></a>3. 互惠</h1><blockquote><p>互惠原理认为，我们应该尽量以类似的方式报答他人为我们所做的一切；</p></blockquote><blockquote><p>每一笔债都还的干干净净，就好像上帝他老人家是债主；          ——爱默生</p></blockquote><blockquote><p>正是因为有了互惠体系，人类才成为人类，祖先在“有债必还得信誉网”里分享食物和技巧，我们才成为人；——理查德·利基</p></blockquote><p><strong>不对等交换</strong>：互惠原理可触发不对等交换，因为亏欠感让人觉得很不舒服，然后违背互惠原理，接受而不试图回报他人善举的人，是不受社会群体欢迎的，谁也不愿意被贴上“忘恩负义”的标签；</p><p><strong>互惠式让步</strong>：互惠原理通过两种途径来实现互惠让步，第一条：它迫使接受了对方让步的人以同样的方式回应；第二条尽管不明显，但很关键：由于接受了让步的人有回报的义务，任务就乐意率先让步，从而启动有益的交换过程；</p><blockquote><p>拒绝-后撤术：你想让我答应你的请求，你可以先向我提一个更大的要求，这样的要求我肯定是拒绝的，等我拒绝后你再提一个稍小的要求，这个要求才是你真正的目标；若这样布置，我会把第二个要求当作你对我的让步，并可能感觉到我也应该让步，从而答应你的要求；<br>这同样也运用了先大后小的知觉对比原理；</p></blockquote><p>实验证明，拒绝-后撤手法似乎不仅刺激人们答应请求，还鼓励他们切身实践承诺，甚至叫他们自愿履行进一步的要求；</p><p><strong>如何拒绝？</strong><br>倘若别人的提议我们确实赞同，那就不妨接受它；倘若这一提议别有用途，那我们就置之不理；<br>互惠原理告诉你：别人怎么对你，你就有权怎么对他；</p><p><strong>Q：为什么精明的政客会让连普通人都能看出来的愚蠢的”水门事件”发生？</strong><br>水门事件的策划人是戈登·利迪，他一开始提的是100万美元 + 窃听器 +跟踪飞机 +绑架小分队 +游艇；这必然不会被其他人通过；随后他削减方案，降至50万美元，也被否定；最终米切尔等人同意了利迪的第三次提议：25万美元；<br>在水门事件被曝光后，不难发掘互惠式让步的力量有多大；</p><p><strong>Q：为什么超时总喜欢提供”免费试用”？</strong><br>免费试用目的一是让公众知道自己产品的质量，二是它同时也是一份礼物，与互惠原理应用起来；这样就有一部分人购买了一些产品，哪怕并不是十分喜欢；</p><h1 id="4-承诺和一致"><a href="#4-承诺和一致" class="headerlink" title="4.承诺和一致"></a>4.承诺和一致</h1><blockquote><p>承诺和一致原理认为，一旦做出了一个选择或采取了某种立场，我们就会立刻碰到来自内心和外部的压力，迫使我们的言行与它保持一致。在这种压力下，我们会想方设法地以行动证明自己先前地决定是正确的；</p></blockquote><blockquote><p>一开始就拒绝，比最后反悔要容易——达·芬奇</p></blockquote><p>一旦做出艰难的选择，人就很乐意相信自己选择对了；事实上，我们所有人都会一次次地欺骗自己，并且愿意做出进一步的承诺，以便坚信自己做的没错，</p><p>在接受琐碎请求时务必小心谨慎，因为一旦同意了，他就可能影响我们的自我认知。它不仅能提高我们对分量更大的类似请求的顺从度，还能使我们更乐意去做一些跟先前答应的小要求毫不相关的事情；</p><p>书面声明能有效地真正改变人，原因之一在于他们很容易公之于众；公开承诺往往具有持久的效力；</p><p>每当一个人当众选择了一种立场，她便会产生维护它的动机，因为这样才能显得前后一致；<br>前后一致是一种很好的为人特点，不具备这一特点的人会被视为浮躁、多变、优柔寡断等；而具备这一特点的人，则显得理性、自信、可靠、值得依赖；</p><p>为一个承诺符出的努力越多，它对承诺者的影响也就越大；</p><p>费尽周折才得到某样东西的人，比轻轻松松就得到的人，对这件东西往往更为珍视；</p><p>只有当我们认为外界不存在强大的压力时，我们才会为自己的行为发自内心地负起责任；</p><p>死脑筋地保持一致愚不可及，而不是保持一致愚不可及；</p><p>我们在生活中不可能完全摆脱它，如果我们一致纠结于做某件事的坏处，那就做不了什么事了；</p><p><strong>Q：为什么大公司常发起一些有奖征文比赛，参赛者无须购买该公司任何产品，却有机会获得大奖？</strong><br>征文比赛的目的是让尽量多的人写下对一种产品的表白；参赛者知道，要想胜出，就必须称赞相关的产品；于是，他们开始寻找该产品值得称道的地方，并在文章中加以描述；随之而来的结果是，成千上万的人以书面形式证明了该产品具有这样那样的优点，在书面文字的神奇推动下，他们就真的相信了自己所写的东西；</p><p><strong>Q：为什么一些二手车经销商在收购旧车，以旧换新时会故意高估旧车的价格？</strong></p><blockquote><p>抛低球：先给人一个甜头，诱使人做出有力的购买决定，而后，等决定做好了，交易还没最终拍板，卖方巧妙地取消了最初的甜头；</p></blockquote><p>此处二手经销商故意抬高旧车价格，客户觉得这笔交易太划算，立刻就想成交；之后等快签合同地时候，销售员说之前对旧车的股价高了400美元，并把换购补贴降至正常水平。客户知道扣了钱之后的交易仍是公平的，也就接受了；</p><h1 id="5-社会认同"><a href="#5-社会认同" class="headerlink" title="5.社会认同"></a>5.社会认同</h1><blockquote><p>社会认同原理认为，在判断何为正确时，我们会根据别人的意见行事，尤其是当我们在特定情形下判断某一行为是否正确时。如果看到别人在某种场合做某件事，我们就会断定这样做是有道理的；</p></blockquote><blockquote><p>在人人想法都差不多的地方，没人会想得太多；——沃尔特·李普曼</p></blockquote><blockquote><p>社会认同原理指出：在判断何为正确时，我们会根据别人的意见行事；</p></blockquote><p>问题在于：我们对社会认同的反应方式完全是无意识的、条件反射式的，这样一来，偏颇甚至伪造的证据也能愚弄我们；</p><blockquote><p>卡维特·罗伯特：95%的人都爱模仿别人，只有5%的人能首先发起行动，所以，要想把人说服，我们提供任何证据的效果都比不上别人的行动；</p></blockquote><p>一般来说，我们在自己不确定、情况不明或含糊不清、意外性太大的时候，我们最有可能觉得别人的行为是正确的；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">对于社会认同的响应方式，我们有了进一步认识：</span><br><span class="line">    首先，我们似乎持有这样的假设，要是很多人在做同样的事情，他们必然知道一些我们不知道的事情。</span><br><span class="line">    尤其是在我们并不确定的时候，我们很乐意对这种集体智慧投入极大的信任。</span><br><span class="line">    其次，人群很多时候都是错的，因为群体的成员并不是根据优势信息才采取行动，而只是基于社会认同原理在做反应；</span><br></pre></td></tr></table></figure><p><strong>Q：为什么现场有大量其他旁观者在场时，旁观者对紧急情况伸出援手的可能性最低？</strong><br>原因之一：周围有其他可以帮忙的人，单个人要承担的责任就减少了；人人都会想着会有别人帮忙，结果人人都没帮忙；<br>原因之二：很多时候，紧急情况咋看起来并不显得十分紧急，碰到这种不确定的情况，人很自然地根据周围其他人的行动来判断，我们往往根据其他目击者的反应方式，得知事情到底够不够紧急；</p><p><strong>多元无知状态</strong>：每个人都得做出判断：既然没人在乎，那就应该没什么问题。与此同时，危险也有可能累计到这样一个程度：某一个体不受看似平静的其他人所影响，采取了行动；<br>多元无知效应似乎在陌生人里显得最为突出，因为我们喜欢在公众面前表现得优雅而成熟，又因为我们不熟悉陌生人的反应，所以，置身于一群素不相识的人里面，我们有可能无法流露出关切地表情，也无法正确地解读他人关切的表情；</p><p>旁观者群体没能帮忙，不是因为他们无情，而是因为他们不能确定；<br><strong>Q：在遇到紧急情况时，什么才是最有效的求救方式？</strong><br>在人群中找出一个人来，盯着他，直接指着说：你，穿蓝夹克的那位先生，我需要帮助，请叫救护车过来；<br>这样一句话消除了一切有可能阻碍或拖延救助的不确定性，你把那位先生放在了“救助者”的位置上，他现在应该明白，紧急救助是必要的；他应该负起责；<br>因此，一般而言，在需要紧急救助时，你的最佳策略就是<strong>减少不确定性</strong>，让周围人注意到你的状况，搞清楚自己的责任；不要让旁观者自己判断；</p><p><strong>Q：为什么自杀事件广为报道时，报道所覆盖地区的自杀事件反而增多？</strong></p><blockquote><p>相似性：我们在观察与我们相似的人的行为时，社会认同理论会发挥出最大的影响力；<br>社会认同原理的病态例证：一些人根据其他陷入困境的人如何行动来决定自己该怎么做；</p></blockquote><p>轰动的自杀新闻之所以会引发事故热潮，原因其实就是：模仿自杀(维特效应)；<br>我们根据他人的行为来判断自己怎么做才合适，尤其是在我们觉得这些人跟自己相似的时候；</p><p>要是自杀新闻后增多的事故真的意味着有人在蓄意模仿，那么这些跟风模仿者最可能效仿的是跟自己类似的人；<br>事实证明：在自杀事件上头条新闻之后的一段时间改变出行方式，能提高生存概率；</p><p><strong>Q：为什么圭亚那琼斯敦的910名教徒会集体自杀？</strong><br>人们在不确定的时候，会根据他人的行动来指导自己的行动；不确定性是社会认同原理的左膀右臂；<br>影响力最强的领导者是那些知道怎么安排群体内部条件，让社会认同原理朝对自己有利方向发挥作用的人；显然这里的领导者就是这些教徒之首，琼斯；</p><p>如何拒绝？<br>面对明显是伪造的社会证据，我们只要多保持一点警惕感，就能很好地保护自己了；</p><h1 id="6-喜好"><a href="#6-喜好" class="headerlink" title="6.喜好"></a>6.喜好</h1><p>一个人的某个正面特征就能主导其他人看待此人的眼光；<br>请求者还有另一种利用相似点增加好感及顺从概率的办法：他们假装跟我们有着相似的背景和兴趣；</p><p>虽然接触带来的熟悉往往能导致更大的好感，可要是接触本身蕴含了让人反感的体验，就会适得其反；<br>证据表明，以团队为导向的学习能缓解敌对状态；</p><p><strong>条件反射和关联</strong>：<br>制造商们总是急着把自己的产品跟当前的文化热潮联系起来；<br>把名人和产品联系在一起，是广告商利用关联原理赚钱的另一种方法；</p><p>根据关联原理，倘若我们能用一些哪怕非常表面的方式让自己跟成功联系起来，我们的公共形象也会显得光辉起来；<br>我们展示积极的联系，隐藏消极的联系，努力让旁观者觉得我们更高大，更值得喜欢；</p><p><strong>Q：在审讯嫌疑犯时，为什么“好警察+坏警察”搭档的方法能够奏效？</strong><br>靠着坏警察的威胁，嫌犯心理很快充满了对长期监禁的恐惧情绪；<strong>知觉对比原理</strong>也发挥了作用，相较于满嘴胡言乱语的坏警察，好警察显得是非常讲道理的好人，且屡次帮嫌犯说话，<strong>互惠原理</strong>让嫌犯感到压力；这种刑讯手法见效的主要原因在于，<strong>它让犯人感觉有人站在自己这一边</strong>，有人为自己着想，也会更加容易向他坦白；</p><p>如何拒绝？<br>我们有必要当心对顺从专业人士的过度好感，意识到这种好感，能提醒我们把交易者和交易分开，只根据生意本身的好坏做决定</p><h1 id="7-权威"><a href="#7-权威" class="headerlink" title="7.权威"></a>7.权威</h1><p>每当面对人类行为背后的一种强力推动因素，我们都会很自然地想到，这种推动因素地村仔是有着充分理由的；就服从权威一例而言，稍微思考下人类社会地组织方式，我们就能找到很多说得过去的解释；被人类普遍接受的多层次权威体制能赋予社会巨大的优势，有了它，适于资源生产、贸易、国防、扩张和社会控制的成熟社会结构才得以发展；</p><p>一旦我们意识到服从权威在大对数情况下是有好处的，就很容易不假思索地服从；</p><p>在没有真正权威的情况下，有几种象征权威的符号能十分有效地触发我们的顺从态度——头衔、衣着和身份标志<br>头衔比当事人的本质更能影响他人的行为；<br>权力和权威的外部特征，说不定是靠假冒伪劣的材料编造出来的</p><p><strong>Q：为什么受过正规培训的护理人员会毫不犹豫地执行来自医生地明明漏洞百出的提示？</strong><br>很多情况下，只要有正统地权威说了话，其他本来应该考虑地事情就变得不相关了；这种时候，我们并不从整体上来审视局面，而是只对其中的一个方面给予关注，作出反应；</p><h1 id="8-稀缺"><a href="#8-稀缺" class="headerlink" title="8.稀缺"></a>8.稀缺</h1><blockquote><p>不管是什么东西，只要你晓得会失去它，自然就会爱上它了；——GK切斯特顿</p></blockquote><p>对失去某种东西的恐惧似乎比对获得同一物品的渴望，更能激发人们的行动力；</p><p>基本可以根据一样东西的难易程度，迅速、准确地判断它的质量；</p><p>机会越来越少的话，我们的自由也会随之丧失；</p><p><strong>Q：为什么面值一元的错版纸币，其价值远远超出了面值的几百倍？</strong><br>倘若瑕疵把一样东西变得稀缺了，垃圾也能化成值钱的宝贝；</p><p><strong>Q：为什么在拍卖场里，人们会不由自主地举牌？</strong><br>渴望拥有一件众人争抢的东西，几乎是出于本能的身体反应；<br>参与竞争稀缺资源的感觉，有着强大地刺激性；</p><p>如何拒绝？<br><strong>稀缺的东西并不因为难以弄到手，就变得更好吃、更好看、更好听、更好用了；</strong></p><h1 id="9-尾声"><a href="#9-尾声" class="headerlink" title="9. 尾声"></a>9. 尾声</h1><blockquote><p>贯穿本书的平行主题：尽管只靠孤立数据容易做出愚蠢的决定，可现代生活的节奏又要求我们频繁使用这一结局；</p></blockquote><p>正常情况下，促使我们做出顺从决策的几个最常用的信息，都可以引导我们做出正确的决策，这就是为什么我们在决策时频繁、机械地使用互惠、承诺与一致、社会认同、喜好、权威以及稀缺原理的原因；每个原理本身都能极为可靠地提示我们，什么时候说”是“比说”不“更加有利；但现实中，大量的、极易伪造的信息被人利用，他们借此引诱我们做出机械的反应并从中获利，我们不得不防；</p><p><img src="https://img-blog.csdnimg.cn/20200505195949284.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3d5bGwxOTk4MDgxMg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">读后感：</span><br><span class="line">     一本很好的心理学书籍，用极易理解的几个维度概括出了我们为人处事所经历的或者即将经历的方方面面；</span><br><span class="line">     说实话，以前没看过心理学书籍，但很向往；这本书买了半年了，这是第一次简洁地将它看完，对其中的论点有所触动，句句都说到心理；</span><br><span class="line">     由于只是粗略的看了一遍，每个论点后仅细品了一个典型的例子，对于其他部分仍需要日后反复深究；</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      《影响力》读书笔记及读后感
    
    </summary>
    
    
      <category term="课外读物" scheme="http://Luweir.github.io/categories/%E8%AF%BE%E5%A4%96%E8%AF%BB%E7%89%A9/"/>
    
    
      <category term="心理学" scheme="http://Luweir.github.io/tags/%E5%BF%83%E7%90%86%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>PS技术大杂烩</title>
    <link href="http://luweir.github.io/2020/06/30/PS%E6%8A%80%E6%9C%AF%E5%A4%A7%E6%9D%82%E7%83%A9/"/>
    <id>http://luweir.github.io/2020/06/30/PS%E6%8A%80%E6%9C%AF%E5%A4%A7%E6%9D%82%E7%83%A9/</id>
    <published>2020-06-30T02:22:17.000Z</published>
    <updated>2020-06-30T02:25:10.295Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、PS六个要点"><a href="#一、PS六个要点" class="headerlink" title="一、PS六个要点"></a>一、PS六个要点</h1><h2 id="1、图层"><a href="#1、图层" class="headerlink" title="1、图层"></a>1、图层</h2><p><img src="https://tacotuesdayyy.oss-cn-shenzhen.aliyuncs.com/umg/image-20200623154317588.png" alt=""></p><h2 id="2、形状"><a href="#2、形状" class="headerlink" title="2、形状"></a>2、形状</h2><h2 id="3、选区"><a href="#3、选区" class="headerlink" title="3、选区"></a>3、选区</h2><p>选择的区域</p><h2 id="4、画笔"><a href="#4、画笔" class="headerlink" title="4、画笔"></a>4、画笔</h2><p>alt + 点击 ：取色到前景色；</p><h2 id="5、文字"><a href="#5、文字" class="headerlink" title="5、文字"></a>5、文字</h2><h2 id="6、钢笔"><a href="#6、钢笔" class="headerlink" title="6、钢笔"></a>6、钢笔</h2><p>创建圆滑的曲线</p><h2 id=""><a href="#" class="headerlink" title=""></a></h2><h1 id="二、图像相关问题"><a href="#二、图像相关问题" class="headerlink" title="二、图像相关问题"></a>二、图像相关问题</h1><h2 id="把竖图变横图"><a href="#把竖图变横图" class="headerlink" title="把竖图变横图"></a>把竖图变横图</h2><h2 id="图像变清晰-润滑"><a href="#图像变清晰-润滑" class="headerlink" title="图像变清晰(润滑)"></a>图像变清晰(润滑)</h2><p>1、复制图层-&gt;滤镜-&gt;表面模糊-&gt;调透明度</p><p>2、复制图层-&gt;滤镜-&gt;其他-&gt;高反差保留(数值2-5之间)-&gt;混合模式选叠加</p><h2 id="如何擦除图层A上图层B内容"><a href="#如何擦除图层A上图层B内容" class="headerlink" title="如何擦除图层A上图层B内容"></a>如何擦除图层A上图层B内容</h2><p>给图层B添加蒙版，在前景色黑色背景色白色的情况下是用画笔进行擦除</p><p><img src="https://tacotuesdayyy.oss-cn-shenzhen.aliyuncs.com/umg/image-20200623163842497.png" alt="image-20200623163842497"></p><h2 id="图像修复"><a href="#图像修复" class="headerlink" title="图像修复"></a>图像修复</h2><h3 id="去水印"><a href="#去水印" class="headerlink" title="去水印"></a>去水印</h3><p>不同的图片去水印的方法也不一样，关键看图片背景的纹理是不是太复杂；</p><p>复杂的话可能就要用仿制图章工具一点点弄，不复杂的话，直接修补工具去掉水印</p><p><strong>1、背景不复杂的</strong></p><p><img src="https://tacotuesdayyy.oss-cn-shenzhen.aliyuncs.com/umg/image-20200624123719245.png" alt="image-20200624123719245"></p><p>修补工具选择要修补的区域 然后移动到纹理相似的区域即可完成修补</p><p><img src="https://tacotuesdayyy.oss-cn-shenzhen.aliyuncs.com/umg/image-20200624123831174.png" alt="image-20200624123831174"></p><p>对于交界面的那个文字 修补时注意对齐</p><p><img src="https://tacotuesdayyy.oss-cn-shenzhen.aliyuncs.com/umg/image-20200624123919838.png" alt="image-20200624123919838"></p><p><strong>2、背景复杂的</strong></p><p><img src="https://tacotuesdayyy.oss-cn-shenzhen.aliyuncs.com/umg/image-20200624124017767.png" alt="image-20200624124017767"></p><p>用仿制图章一点点复制</p><p><img src="https://tacotuesdayyy.oss-cn-shenzhen.aliyuncs.com/umg/image-20200624124609223.png" alt="image-20200624124609223"></p><h3 id="去人物斑点"><a href="#去人物斑点" class="headerlink" title="去人物斑点"></a>去人物斑点</h3><p><img src="https://tacotuesdayyy.oss-cn-shenzhen.aliyuncs.com/umg/image-20200624124802314.png" alt="image-20200624124802314"></p><p>污点修复画笔工具</p><p><img src="https://tacotuesdayyy.oss-cn-shenzhen.aliyuncs.com/umg/image-20200624124911319.png" alt="image-20200624124911319"></p><p>一个个点就行</p><p><img src="https://tacotuesdayyy.oss-cn-shenzhen.aliyuncs.com/umg/image-20200624124929915.png" alt="image-20200624124929915"></p><h3 id="消除图像中乱入的事物"><a href="#消除图像中乱入的事物" class="headerlink" title="消除图像中乱入的事物"></a>消除图像中乱入的事物</h3><p>简单的直接选区，选择要消除的东西 然后填充 内容识别</p><p><img src="https://tacotuesdayyy.oss-cn-shenzhen.aliyuncs.com/umg/image-20200624125220838.png" alt="image-20200624125220838"></p><p><img src="https://tacotuesdayyy.oss-cn-shenzhen.aliyuncs.com/umg/image-20200624125234824.png" alt="image-20200624125234824"></p><p><img src="https://tacotuesdayyy.oss-cn-shenzhen.aliyuncs.com/umg/image-20200624125245552.png" alt="image-20200624125245552"></p><p><img src="https://tacotuesdayyy.oss-cn-shenzhen.aliyuncs.com/umg/image-20200624125254898.png" alt="image-20200624125254898"></p><p>内容感知工具：把区域A移到区域B，A的原区域部分会内容识别，移到B的A也会内容识别把A放到B那，如果有点瑕疵，再用别的工具处理；</p><h2 id="图像合成"><a href="#图像合成" class="headerlink" title="图像合成"></a>图像合成</h2><p>P图、表情包制作等；</p><p>工具：套索 钢笔 + 图像混合；</p><h3 id="把A的脸P到B的脸上"><a href="#把A的脸P到B的脸上" class="headerlink" title="把A的脸P到B的脸上"></a>把A的脸P到B的脸上</h3><img src="https://tacotuesdayyy.oss-cn-shenzhen.aliyuncs.com/umg/image-20200624125951735.png" alt="image-20200624125951735" style="zoom:33%;" /><img src="https://tacotuesdayyy.oss-cn-shenzhen.aliyuncs.com/umg/image-20200624125947733.png" alt="image-20200624125947733" style="zoom:33%;" /><p><img src="https://tacotuesdayyy.oss-cn-shenzhen.aliyuncs.com/umg/image-20200624130240729.png" alt="image-20200624130240729"></p><p>把这个图层复制到超越那里；</p><p>然后扣除原图对应区域，可以将区域进行一定的缩小</p><p><img src="https://tacotuesdayyy.oss-cn-shenzhen.aliyuncs.com/umg/image-20200624130838988.png" alt="image-20200624130838988"></p><p>然后选择两个图层，编辑，自动混合图层，确定；</p><p><img src="https://tacotuesdayyy.oss-cn-shenzhen.aliyuncs.com/umg/image-20200624130719550.png" alt="image-20200624130719550"></p><p>这种一般适合两个图片人物脸朝向相同，否则需要做出一些调整；</p><p>整个步骤为：</p><p><img src="https://tacotuesdayyy.oss-cn-shenzhen.aliyuncs.com/umg/image-20200624131045772.png" alt="image-20200624131045772"></p><h3 id="把完整的人P到另一个场景"><a href="#把完整的人P到另一个场景" class="headerlink" title="把完整的人P到另一个场景"></a>把完整的人P到另一个场景</h3><p>注意：姿势眼神、身体比例、光影颜色；</p><p><img src="https://tacotuesdayyy.oss-cn-shenzhen.aliyuncs.com/umg/M4DN%60M7L2TDO%5DM0~@36@@S7.png" alt="img"></p><p><img src="https://tacotuesdayyy.oss-cn-shenzhen.aliyuncs.com/umg/PI117%5B%5DP7VY52J%5DH@3PM6%7DI.png" alt="img"></p><p><img src="https://tacotuesdayyy.oss-cn-shenzhen.aliyuncs.com/umg/image-20200624143121988.png" alt="image-20200624143121988"></p><p>把图层复制过去后，调整好大小和位置，利用仿制图章、修补和选区自由变化、水平翻转等方法将周围背景进行修改，然后对色彩进行判断，看是否需要降低饱和度，是否需要加深颜色等等；</p><p>加阴影就是在图层上新建一个图层 然后调整画笔透明度和流量、硬度，进行刻画；</p><h3 id="换头大法"><a href="#换头大法" class="headerlink" title="换头大法"></a>换头大法</h3><p><img src="https://tacotuesdayyy.oss-cn-shenzhen.aliyuncs.com/umg/image-20200624143941405.png" alt="image-20200624143941405"></p><p><img src="https://tacotuesdayyy.oss-cn-shenzhen.aliyuncs.com/umg/image-20200624143944940.png" alt="image-20200624143944940"></p><p>把头和脖子扣下来，然后复制在图像2中，调整大小位置，对图像2背景利用图章等工具进行调整，然后给头，脖子添加阴影，方向键微调元素位置，然后用可选颜色调整肤色；</p><p><img src="https://tacotuesdayyy.oss-cn-shenzhen.aliyuncs.com/umg/image-20200624145345249.png" alt="image-20200624145345249"></p><p><img src="https://tacotuesdayyy.oss-cn-shenzhen.aliyuncs.com/umg/image-20200624145356705.png" alt="image-20200624145356705"></p><h1 id="三、制作相关"><a href="#三、制作相关" class="headerlink" title="三、制作相关"></a>三、制作相关</h1><h2 id="制作幻影"><a href="#制作幻影" class="headerlink" title="制作幻影"></a>制作幻影</h2><p>复制多个该图层，调整好位置，依次调整透明度</p><p><img src="https://tacotuesdayyy.oss-cn-shenzhen.aliyuncs.com/umg/image-20200623155030859.png" alt="image-20200623155030859"></p><h2 id="用文字组成的图像特效"><a href="#用文字组成的图像特效" class="headerlink" title="用文字组成的图像特效"></a>用文字组成的图像特效</h2><p><img src="https://tacotuesdayyy.oss-cn-shenzhen.aliyuncs.com/umg/image-20200623162003679.png" alt="image-20200623162003679"></p><p>1、把图层填充为黑色；</p><p>2、选择文字框，复制一堆的英文；调整颜色为白色，调整字形，字体大小；</p><p>3、把图片粘贴进去，注意要在文字的上面，然后在图片图层上创建剪贴蒙版；</p><p><img src="https://tacotuesdayyy.oss-cn-shenzhen.aliyuncs.com/umg/image-20200623162131974.png" alt="image-20200623162131974"></p><h2 id="海报设计"><a href="#海报设计" class="headerlink" title="海报设计"></a>海报设计</h2><p>字体、层次、距离；</p><p>不要用一大堆乱七八糟的字体，会有凌乱的感觉；</p><p><img src="https://tacotuesdayyy.oss-cn-shenzhen.aliyuncs.com/umg/image-20200626151623951.png" alt="image-20200626151623951"></p><p><img src="https://tacotuesdayyy.oss-cn-shenzhen.aliyuncs.com/umg/image-20200626151635086.png" alt="image-20200626151635086"></p><p>海报的目的只是信息的传递，选三种以下的字体即可；</p><p>文字层次，决定信息的可读性；注意对齐；</p><p><img src="https://tacotuesdayyy.oss-cn-shenzhen.aliyuncs.com/umg/image-20200626151709811.png" alt="image-20200626151709811"></p><p><img src="https://tacotuesdayyy.oss-cn-shenzhen.aliyuncs.com/umg/image-20200626151827905.png" alt="image-20200626151827905"></p><p>人物与标题的排列方式</p><p><img src="https://tacotuesdayyy.oss-cn-shenzhen.aliyuncs.com/umg/image-20200626151855041.png" alt="image-20200626151855041"></p><h1 id="四、人物抠图相关问题"><a href="#四、人物抠图相关问题" class="headerlink" title="四、人物抠图相关问题"></a>四、人物抠图相关问题</h1><h2 id="抠图大法"><a href="#抠图大法" class="headerlink" title="抠图大法"></a>抠图大法</h2><h3 id="选择并遮住"><a href="#选择并遮住" class="headerlink" title="选择并遮住"></a>选择并遮住</h3><p>1、魔棒/快速/套索 选区/选择主题 </p><p>2、选择并遮住</p><p>一般选择叠加模式，红色部分为非选择部分，调整下不透明度；</p><p>==半径==就是边缘的半径：越大则图像处理的边缘半径越大；</p><p>3、第二个神器工具：调整边缘画笔</p><p>对边缘细节拿这个笔刷</p><p>4、确定，添加图层蒙版，如果还需要修改细节部分，则选择==海绵工具==刷一下；</p><p>==海绵工具==就是去掉颜色的饱和度，或者直接选择头发，调整饱和度；</p><p>5、背景填充颜色；</p><h2 id="人物磨皮-证件照-换背景"><a href="#人物磨皮-证件照-换背景" class="headerlink" title="人物磨皮/证件照/换背景"></a>人物磨皮/证件照/换背景</h2><p><img src="https://tacotuesdayyy.oss-cn-shenzhen.aliyuncs.com/umg/image-20200624150617653.png" alt="image-20200624150617653"></p><p>1、污点修复工具修复大块瑕疵；</p><p>2、磨皮滤镜工具Portraiture进行磨皮；</p><p><img src="https://tacotuesdayyy.oss-cn-shenzhen.aliyuncs.com/umg/image-20200624155501802.png" alt="image-20200624155501802"></p><p>但是，磨皮后有些模糊，不清晰；</p><p>滤镜-&gt;其他-&gt;高反差保留-&gt;数值在2-5之间，确定-&gt;混合模式改成叠加；</p><p>发现图像清晰很多；</p><p><img src="https://tacotuesdayyy.oss-cn-shenzhen.aliyuncs.com/umg/image-20200624155802184.png" alt="image-20200624155802184"></p><p>3、调整颜色</p><p><img src="https://tacotuesdayyy.oss-cn-shenzhen.aliyuncs.com/umg/image-20200624160431312.png" alt="image-20200624160431312"></p><p>4、调整五官，用滤镜下的液化，有个人脸识别工具</p><p><img src="https://tacotuesdayyy.oss-cn-shenzhen.aliyuncs.com/umg/image-20200624160651903.png" alt="image-20200624160651903"></p><p><img src="https://tacotuesdayyy.oss-cn-shenzhen.aliyuncs.com/umg/image-20200624160824426.png" alt="image-20200624160824426"></p><p>5、换证件照背景</p><p>新建图层，背景色调为蓝色，然后填充；</p><p><img src="https://tacotuesdayyy.oss-cn-shenzhen.aliyuncs.com/umg/image-20200624161027239.png" alt="image-20200624161027239"></p><p><img src="https://tacotuesdayyy.oss-cn-shenzhen.aliyuncs.com/umg/image-20200624161938797.png" alt="image-20200624161938797"></p><p>各证件照大小：</p><p><img src="https://tacotuesdayyy.oss-cn-shenzhen.aliyuncs.com/umg/image-20200624162020013.png" alt="image-20200624162020013"></p><p>新建-&gt;调整好证件照大小-&gt;分辨率300 颜色模式CMYK-&gt;创建；</p><p>给刚刚做完的图像盖印，然后复制过来，放缩，然后另存为；</p><h2 id="人物精修-男"><a href="#人物精修-男" class="headerlink" title="人物精修 - 男"></a>人物精修 - 男</h2><p><img src="https://tacotuesdayyy.oss-cn-shenzhen.aliyuncs.com/umg/image-20200625165624032.png" alt="image-20200625165624032"></p><p>1、污点修复工具去除大斑点；</p><p>2、高低频；</p><p><img src="https://tacotuesdayyy.oss-cn-shenzhen.aliyuncs.com/umg/image-20200625163102517.png" alt="image-20200625163102517"></p><p>先对低频处理：</p><p>在通道中找到对比度比较高的颜色图层-&gt;滤镜-&gt;其他-&gt;高反差保留-&gt;调到斑点刚刚好出现的数值即可；</p><p>图像-&gt;计算-&gt;混合模式-&gt;强光；</p><p>图像-&gt;计算-&gt;确定；</p><p>图像-&gt;计算-&gt;确定；</p><p>图像-&gt;计算-&gt;确定；</p><p>斑点越来越清楚；</p><p>ctrl+点击 进行选区  选择二的是高光的部分，就是白色的部分；</p><p><img src="https://tacotuesdayyy.oss-cn-shenzhen.aliyuncs.com/umg/image-20200625163601189.png" alt="image-20200625163601189"></p><p>反选；</p><p>ctrl + M 把曲线拉高一点 这样就能把黑的斑点调亮；</p><p><img src="https://tacotuesdayyy.oss-cn-shenzhen.aliyuncs.com/umg/image-20200625163826389.png" alt="image-20200625163826389"></p><p>滤镜-&gt; 模糊-&gt; 高斯模糊；</p><p>高频处理：</p><p>滤镜-&gt;高反差保留-&gt; 数值调到跟高斯模糊差不多即可；</p><p>混合模式改为线性光/点光；</p><p>3、修改</p><p>对低频进行修改：</p><p>选定暗斑区域，对区域选区，然后高斯模糊；</p><p>调整曲线;</p><p>用Portraiture插件对低频处理同理；</p><p>4、液化，人脸识别处理；</p><p><img src="https://tacotuesdayyy.oss-cn-shenzhen.aliyuncs.com/umg/image-20200625165655867.png" alt="image-20200625165655867"></p><h2 id="人物精修-女"><a href="#人物精修-女" class="headerlink" title="人物精修 - 女"></a>人物精修 - 女</h2><p>痘印、皱纹、暗斑(亮度问题)</p><h3 id="法一"><a href="#法一" class="headerlink" title="法一"></a>法一</h3><p><img src="https://tacotuesdayyy.oss-cn-shenzhen.aliyuncs.com/umg/image-20200625165959086.png" alt="image-20200625165959086"></p><p>1、修补工具、污点工具处理；</p><p>2、黑白颜色调出，曲线调整图层调整使得对比明显，让痘痘显现出来，如果还不清楚，再复制一份曲线调整；把这三个打组；</p><p>3、新建空白图层，填充50%灰；</p><p>然后用画笔工具，降低流量和平滑，  前景白背景黑，在灰图层上进行精修，就是把黑色的斑点点白；</p><p><img src="https://tacotuesdayyy.oss-cn-shenzhen.aliyuncs.com/umg/image-20200625171633811.png" alt="image-20200625171633811"></p><h3 id="法二：双曲线"><a href="#法二：双曲线" class="headerlink" title="法二：双曲线"></a>法二：双曲线</h3><p><img src="https://tacotuesdayyy.oss-cn-shenzhen.aliyuncs.com/umg/image-20200625171851591.png" alt="image-20200625171851591"></p><p>把亮曲线亮度调高，暗曲线的亮度调低，然后两个都填充黑色(两个图层不可见)</p><p><img src="https://tacotuesdayyy.oss-cn-shenzhen.aliyuncs.com/umg/image-20200625172221336.png" alt="image-20200625172221336"></p><p>此时可以打开观察后图层组，如果把暗的地方变亮，就在亮图层上对暗的地方进行画笔涂抹；相当于把不可见的那里删除，让他变亮到开始亮曲线的程度；</p><p>把亮的地方变暗同理；</p><p><img src="https://tacotuesdayyy.oss-cn-shenzhen.aliyuncs.com/umg/image-20200625172420646.png" alt="image-20200625172420646"></p><h3 id="调整肤色"><a href="#调整肤色" class="headerlink" title="调整肤色"></a>调整肤色</h3><p>可选颜色 黄色 降低黄色；</p><p>调整红色，红色降低，红色对立面青色增加；</p><p><img src="https://tacotuesdayyy.oss-cn-shenzhen.aliyuncs.com/umg/image-20200625173212982.png" alt="image-20200625173212982"></p><h2 id="给人物加影子-阴影"><a href="#给人物加影子-阴影" class="headerlink" title="给人物加影子/阴影"></a>给人物加影子/阴影</h2><p>1、ctrl + j 复制图层；</p><p>2、锁定透明像素；</p><p><img src="https://tacotuesdayyy.oss-cn-shenzhen.aliyuncs.com/umg/image-20200623134005435.png" alt="image-20200623134005435"></p><p>3、alt + del 填充黑色 然后解锁；</p><p>4、ctrl + T 把影子往下压，然后垂直翻转，斜切到合适位置；</p><p>5、调整透明度或者调整混合选项；</p><h2 id="嘴唇上色口红"><a href="#嘴唇上色口红" class="headerlink" title="嘴唇上色口红"></a>嘴唇上色口红</h2><p>1、选区  羽化5像素左右  建立图层；</p><p><img src="https://tacotuesdayyy.oss-cn-shenzhen.aliyuncs.com/umg/image-20200623134650608.png" alt="image-20200623134650608"></p><p>2、填充红色</p><p><img src="https://tacotuesdayyy.oss-cn-shenzhen.aliyuncs.com/umg/image-20200623134702613.png" alt="image-20200623134702613"></p><p>3、混合模式更改为正片叠底</p><p><img src="https://tacotuesdayyy.oss-cn-shenzhen.aliyuncs.com/umg/image-20200623134736510.png" alt="image-20200623134736510"></p><p>4、调整混合选项 按住ait+左键 调整</p><p><img src="https://tacotuesdayyy.oss-cn-shenzhen.aliyuncs.com/umg/image-20200623134907452.png" alt="image-20200623134907452"></p><h1 id="五、调色相关问题"><a href="#五、调色相关问题" class="headerlink" title="五、调色相关问题"></a>五、调色相关问题</h1><h2 id="日系风格"><a href="#日系风格" class="headerlink" title="日系风格"></a>日系风格</h2><p><img src="https://tacotuesdayyy.oss-cn-shenzhen.aliyuncs.com/umg/image-20200626135900462.png" alt="image-20200626135900462"></p><p>滤镜-&gt;Camera滤镜</p><p>太黑了  =&gt;  曝光不够，加曝光，黑色，阴影；</p><p>调整对比度、饱和度等；</p><p>添加一些光线 =&gt;  新建图层 拿画笔点个白色的 然后放大 调整位置；</p><p><img src="https://tacotuesdayyy.oss-cn-shenzhen.aliyuncs.com/umg/image-20200626140433543.png" alt="image-20200626140433543"></p><h2 id="小清新"><a href="#小清新" class="headerlink" title="小清新"></a>小清新</h2><p><img src="https://tacotuesdayyy.oss-cn-shenzhen.aliyuncs.com/umg/image-20200626140652988.png" alt="image-20200626140652988"></p><p>camera滤镜调整 HSL调整 </p><p>饱和度：调整色彩浓度；</p><p><img src="https://tacotuesdayyy.oss-cn-shenzhen.aliyuncs.com/umg/image-20200626141231281.png" alt="image-20200626141231281"></p><p>再调整下曲线，配上文字；</p><h1 id="Add：相关功能和选项介绍"><a href="#Add：相关功能和选项介绍" class="headerlink" title="Add：相关功能和选项介绍"></a>Add：相关功能和选项介绍</h1><h2 id="混合模式"><a href="#混合模式" class="headerlink" title="混合模式"></a>混合模式</h2><h3 id="正片叠底"><a href="#正片叠底" class="headerlink" title="正片叠底"></a>正片叠底</h3><p>正片叠底是 ps 中的一种混合模式，存在于颜色混合模式、通道混合模式、图层混合模式的变暗模式组中，是用户使用频率较高的一种变暗模式，使用“正片叠底” 混合模式时一般不会产生色阶溢出，当调换基色和混合色的位置，结果色相同。</p><h2 id="调节颜色"><a href="#调节颜色" class="headerlink" title="调节颜色"></a>调节颜色</h2><h3 id="可选颜色"><a href="#可选颜色" class="headerlink" title="可选颜色"></a>可选颜色</h3><p>拉低那个颜色就是将哪个颜色减弱；</p><p>注意看是对整个图像调色 还是对下一图层调色 设定好；</p><h1 id="Add：快捷键"><a href="#Add：快捷键" class="headerlink" title="Add：快捷键"></a>Add：快捷键</h1><h2 id="填充相关"><a href="#填充相关" class="headerlink" title="填充相关"></a>填充相关</h2><p>D 恢复前景背景黑白色</p><p>X 切换背景色</p><p>SHIFT +  F5 填充</p><p>图层蒙版下：</p><p>ctrl + delete 快速填充背景色；</p><p>alt + delete 快速填充前景色</p><h2 id="选区相关"><a href="#选区相关" class="headerlink" title="选区相关"></a>选区相关</h2><p>ctrl + j 快速创建选区；</p><p>ctrl + 左键图层  选择图层所在选区；</p><p>ctrl + H 隐藏选区；</p><h2 id="变换相关"><a href="#变换相关" class="headerlink" title="变换相关"></a>变换相关</h2><p>ctrl + T 自由变换；</p><h2 id="图层相关"><a href="#图层相关" class="headerlink" title="图层相关"></a>图层相关</h2><p>ctrl + 左键 选择改图层</p><p>ctrl + shift + alt + e 盖印图层，把下面所有操作合并在这个图层上；</p><h1 id="Add：待解决的问题"><a href="#Add：待解决的问题" class="headerlink" title="Add：待解决的问题"></a>Add：待解决的问题</h1><h2 id="滤镜等8BF工具不被兼容问题"><a href="#滤镜等8BF工具不被兼容问题" class="headerlink" title="滤镜等8BF工具不被兼容问题"></a>滤镜等8BF工具不被兼容问题</h2>]]></content>
    
    <summary type="html">
    
      学习总结的一些PS使用技巧
    
    </summary>
    
    
      <category term="Software" scheme="http://Luweir.github.io/categories/Software/"/>
    
    
      <category term="PS" scheme="http://Luweir.github.io/tags/PS/"/>
    
  </entry>
  
  <entry>
    <title>计算机方向及导师选择有感</title>
    <link href="http://luweir.github.io/2020/06/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%B9%E5%90%91%E5%8F%8A%E5%AF%BC%E5%B8%88%E9%80%89%E6%8B%A9%E6%9C%89%E6%84%9F/"/>
    <id>http://luweir.github.io/2020/06/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%B9%E5%90%91%E5%8F%8A%E5%AF%BC%E5%B8%88%E9%80%89%E6%8B%A9%E6%9C%89%E6%84%9F/</id>
    <published>2020-06-29T11:03:15.000Z</published>
    <updated>2020-06-30T01:55:11.444Z</updated>
    
    <content type="html"><![CDATA[<p>​    正常的话，初试成绩出来后就要联系并确定导师，拟录取后得到导师指点，适应研究生生活；但由于一些阻碍（前几个老师名额都满了，后两个老师的名额没确定下来，暂时无法答复我），导师和方向的问题迟迟没有解决，也是我一直打着等老师回复的幌子拖着这个事。</p><p>​    索性今天就把方向给定了，根据方向去联系导师，本来导师又多，我也不认识，学长学姐也没有参考性的建议，只能排除一些雷硬冲了；</p><p>​    就我而言，喜欢一些有挑战的东西，但常常因为不够自信而不去尝试，这次就冲一把；搜了一些资料，也看了一些论坛帖子，对以下几个方向有了一些理解：</p><p>​    <strong>人工智能/机器学习/深度学习</strong>：存在着分支关系的这三个方向，需要很好的数学功底，算法功底；读研期间处理模型的时候，需要往复的调参数，越熟练调得越快；而数学到了一定的高度后，就是靠天赋了；所以，这是一个极具有挑战的方向；</p><p>毕业后，工作一般是算法岗位、算法工程师，薪资待遇好；纯算法方向（对模型创新）比较吃学历、吃赛奖、吃顶会，工程方向（将现有模型变成落地项目）的话门槛要求相对低点；</p><p>其中的自然语言处理(<strong>NLP</strong>)和计算机视觉(<strong>CV</strong>)属于比较火热的方向，但CV由于人数多、落地少，NLP相对来说比较受青睐，但目前基本就大厂设了，进大厂难，小厂如果有的话，则进去相对容易一些，在以后的话应该有一个好的发展；</p><p>在我看来，<strong>智能推荐</strong>的领域应该比NLP的宽，并且感觉覆盖面更广一些，不知道就业形势会不会好点；</p><p>​    <strong>大数据</strong>：大数据的方向大体有开发和分析两种，主要以java为主吧，python也有；大数据薪资也算可以，就业不错，应该算是主流方向吧；</p><p>​    <strong>开发岗位</strong>：这个不算是研究方向，但是就业的一个很好的指南针；学好Java，步入开发岗位，岗位多，薪资过得去，避坑机器学习，也是大多数程序员的选择吧；</p><p>所以，读研期间就以<strong>优先NLP/推荐系统，然后机器学习/深度学习，其次大数据相关方向</strong>吧，毕竟很多东西都没真正接触过，也不知道自己真正喜欢什么，想要什么；课后就自己学学java开发，凡事留条后路；</p><p>最近国家还投了2000亿在电子产业上，估计通信电子行业在几年内会持续上升吧；</p>]]></content>
    
    <summary type="html">
    
      定方向，待联系导师
    
    </summary>
    
    
      <category term="Privacy" scheme="http://Luweir.github.io/categories/Privacy/"/>
    
    
      <category term="记录" scheme="http://Luweir.github.io/tags/%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>C++面试题</title>
    <link href="http://luweir.github.io/2020/06/29/C++%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>http://luweir.github.io/2020/06/29/C++%E9%9D%A2%E8%AF%95%E9%A2%98/</id>
    <published>2020-06-29T03:50:22.000Z</published>
    <updated>2020-06-29T07:30:28.651Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-C-和C的区别"><a href="#1-C-和C的区别" class="headerlink" title="1. C++和C的区别"></a>1. C++和C的区别</h1><p>1）在设计思想上：</p><p>C++是<strong>面向对象</strong>的语言，而C是面向过程的<strong>结构化编程</strong>语言；</p><p>2）在内容方面：</p><p>C++是C的超集，即C是C++的子集，C++兼容C；</p><p>C++引入类、封装、隐藏、继承、多态等特性；引入STL标准模板库等；</p><p>C++提供<strong>引用&amp;</strong>机制，降低使用指针的复杂度；</p><p>C++提供内联函数inline；</p><p>3）在语法方面：</p><p>C++中new和delete是对内存分配的运算符，取代了c的malloc和free；</p><p>C++中用控制标准输入输出的iostream类库代替了标准C中的stdio函数库；</p><p>C++中的try/catch/throw异常处理机制取代了C中的setjmp()和longjmp()；</p><p>强制类型转换，C++提供两种两种格式，而C只有第一种；</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> el = <span class="number">123.233</span>;</span><br><span class="line"><span class="keyword">int</span> i = (<span class="keyword">int</span>) el; <span class="comment">//第一种 </span></span><br><span class="line"><span class="keyword">int</span> j = <span class="keyword">int</span> (el);<span class="comment">//第二种</span></span><br></pre></td></tr></table></figure><p>C++允许设置函数默认参数，而C不允许；</p><p>C++允许对函数进行重载(两个同名函数，若它们参数类型不一致or参数个数不同，则为两个不同的函数)，而C不允许；</p><p>C++允许在程序任何地方定义变量，而C只允许在函数开头部分定义；</p><p>详解可参考文章：<a href="https://blog.csdn.net/cherrydreamsover/article/details/81835976?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-1.nonecase&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-1.nonecase" target="_blank" rel="noopener">C++和C的区别</a></p><h1 id="2-static的作用"><a href="#2-static的作用" class="headerlink" title="2. static的作用"></a>2. static的作用</h1><p>1、全局静态变量</p><p>存放于静态存储区；</p><p>在整个程序运行期间都存在；</p><p>未被初始化时自动初始化为0；</p><p>作用域：从定义之处开始到文件结尾；</p><p>2、局部静态变量</p><p>仅作用域与全局静态变量不同：局部静态变量在定义它的函数or语句块结束时，作用域便结束，此时不可访问，当再次调用函数时，即可访问且值不变；</p><p>3、静态函数</p><p>函数默认extern，即可以被其他文件可用；</p><p>而静态函数只能在声明它的文件中可见，不能被其他文件所引用；</p><p>4、类的静态成员变量</p><p>类的静态成员可实现多个对象之间的数据共享，只存储于溢出，共该类的所有对象共用；</p><p>5、类的静态成员函数</p><p>调用静态成员函数不需要用对象名（但可以用），且静态成员函数中不能直接引用类中的非静态成员，因为它不知道这个成员为那个对象所有；</p><p>调用静态成员函数使用如下格式：<code>&lt;类名&gt;::&lt;静态成员函数名&gt;(&lt;参数表&gt;);</code></p><h1 id="3-C-中的四种cast转换"><a href="#3-C-中的四种cast转换" class="headerlink" title="3. C++中的四种cast转换"></a>3. C++中的四种cast转换</h1><p>C++中四种类型转换是：static_cast, dynamic_cast, const_cast, reinterpret_cast；</p><p>1、const_cast</p><p>用于将const变量转为非const；</p><p>2、static_cast</p><p>用于各种隐式转换，比如非const转const，void*转指针等, static_cast能用于多态向上转化，如果向下转能成功但是不安全，结果未知；</p><p>3、dynamic_cast</p><p>用于动态类型转换。只能用于含有虚函数的类，用于类层次间的向上和向下转化。只能转指针或引用。向下转化时，如果是非法的对于指针返回NULL，对于引用抛异常。</p><p>向上转换：指的是子类向基类的转换；</p><p>向下转换：指的是基类向子类的转换；</p><p>它通过判断在执行到该语句的时候变量的运行时类型和要转换的类型是否相同来判断是否能够进行向下转换；</p><p>4、reinterpret_cast</p><p>几乎什么都可以转，比如将int转指针，可能会出问题，尽量少用；</p><h1 id="4-C-C中指针和引用的区别"><a href="#4-C-C中指针和引用的区别" class="headerlink" title="4. C++/C中指针和引用的区别"></a>4. C++/C中指针和引用的区别</h1><p>1、指针有自己的一块空间，而引用只是别名；</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">short a=<span class="number">1</span>;</span><br><span class="line">short *p=&amp;a;</span><br><span class="line">short &amp;b=a;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="keyword">sizeof</span>(p);<span class="comment">//输出4</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="keyword">sizeof</span>(b);<span class="comment">//输出2</span></span><br></pre></td></tr></table></figure><p>2、指针可被初始化为NULL，而引用必须被初始化且必须是一个已有对象的引用；</p><p>3、可以有const指针，但是没有const引用；</p><p>4、指针可以在使用中指向其他对象，而引用一旦初始化，便不能再指向别的对象；</p><p>5、指针可以有多级(**p)，而引用只有一级；</p><p>6、指针和引用使用++运算符的意义不同；如若变量i是int类型，p指向i，b是i的引用；那么++p表示p的值等于 i 的地址加四个地址单位后的地址；而++b的值是i+1；</p><p>7、如果返回动态内存分配的对象或者内存，必须使用指针，引用可能引起内存泄露；</p><h1 id="5-什么是野指针"><a href="#5-什么是野指针" class="headerlink" title="5. 什么是野指针"></a>5. 什么是野指针</h1><p>野指针就是指向一个已删除的对象或者未申请访问受限内存区域的指针；</p><h1 id="6-为什么对于会被继承的类，其析构函数必须是虚函数？"><a href="#6-为什么对于会被继承的类，其析构函数必须是虚函数？" class="headerlink" title="6. 为什么对于会被继承的类，其析构函数必须是虚函数？"></a>6. 为什么对于会被继承的类，其析构函数必须是虚函数？</h1><p>将可能会被继承的父类的析构函数设置为虚函数，可以保证当我们new一个子类，然后使用基类指针指向该子类对象，释放该子类对象的空间时，可以释放掉子类的空间，防止内存泄漏。</p><p>C++默认的析构函数不是虚函数是因为虚函数需要额外的虚函数表和虚表指针，占用额外的内存。而对于不会被继承的类来说，其析构函数如果是虚函数，就会浪费内存。因此C++默认的析构函数不是虚函数，而是只有当需要当作父类时，设置为虚函数。</p><p>详解可参考：<a href="https://blog.csdn.net/qq_42717239/article/details/102806722?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-1.nonecase&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-1.nonecase" target="_blank" rel="noopener">继承-虚析构函数</a></p><h1 id="7-函数指针"><a href="#7-函数指针" class="headerlink" title="7. 函数指针"></a>7. 函数指针</h1><p>1、定义</p><p>函数指针是指向函数的指针变量；</p><p>函数指针本身首先是一个指针变量，该指针变量指向一个具体的函数。这正如用指针变量可指向整型变量、字符型、数组一样，这里是指向函数；</p><p>C在编译时，每一个函数都有一个入口地址，该入口地址就是函数指针所指向的地址；有了指向函数的指针变量后，可用该指针变量调用函数，就如同用指针变量可引用其他类型变量一样，在这些概念上是大体一致的；</p><p>2、用途：</p><p>调用函数和做函数的参数，比如回调函数。</p><p>3、示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fun</span><span class="params">(<span class="keyword">char</span> c)</span> <span class="comment">//函数fun</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> (*pf)(<span class="keyword">char</span> c); <span class="comment">//定义函数指针pf</span></span><br><span class="line">    pf=fun;  <span class="comment">//将函数指针pf指向函数fun</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;pf(<span class="string">'a'</span>);  <span class="comment">//输出97</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="8-C-中析构函数的作用"><a href="#8-C-中析构函数的作用" class="headerlink" title="8. C++中析构函数的作用"></a>8. C++中析构函数的作用</h1><p>析构函数与构造函数对应，当对象结束其生命周期，如对象所在的函数已调用完毕时，系统会自动执行析构函数。</p><p>析构函数名也应与类名相同，只是在函数名前面加一个位取反符<del>，例如</del>stud( )，以区别于构造函数。它不能带任何参数，也没有返回值（包括void类型）。只能有一个析构函数，不能重载；</p><p>如果用户没有编写析构函数，编译系统会自动生成一个缺省的析构函数（即使自定义了析构函数，编译器也总是会为我们合成一个析构函数，并且如果自定义了析构函数，编译器在执行时会先调用自定义的析构函数再调用合成的析构函数），它也不进行任何操作。所以许多简单的类中没有用显式的析构函数；</p><p>如果一个类中有指针，且在使用的过程中动态的申请了内存，那么最好显示构造析构函数在销毁类之前，释放掉申请的内存空间，避免内存泄漏；</p><p>类析构顺序：1）派生类本身的析构函数；2）对象成员析构函数；3）基类析构函数。</p><h1 id="9-静态函数和虚函数的区别"><a href="#9-静态函数和虚函数的区别" class="headerlink" title="9. 静态函数和虚函数的区别"></a>9. 静态函数和虚函数的区别</h1><p>静态函数在编译的时候就已经确定运行时机，虚函数在运行的时候动态绑定。虚函数因为用了虚函数表机制，调用的时候会增加一次内存开销；</p><h1 id="10-重载和覆盖"><a href="#10-重载和覆盖" class="headerlink" title="10. 重载和覆盖"></a>10. 重载和覆盖</h1><p><strong>重载</strong>：两个函数名相同，但是参数列表不同（个数，类型），返回值类型没有要求，在同一作用域中；</p><p><strong>重写/覆盖</strong>：子类继承了父类，父类中的函数是虚函数，在子类中重新定义了这个虚函数，这种情况是重写;</p><h1 id="11-对虚函数和多态的理解"><a href="#11-对虚函数和多态的理解" class="headerlink" title="11. 对虚函数和多态的理解"></a>11. 对虚函数和多态的理解</h1><p>多态的实现主要分为静态多态和动态多态，静态多态主要是重载，在编译的时候就已经确定；动态多态是用虚函数机制实现的，在运行期间动态绑定。举个例子：一个父类类型的指针指向一个子类对象时候，使用父类的指针去调用子类中重写了的父类中的虚函数的时候，会调用子类重写过后的函数，在父类中声明为加了virtual关键字的函数，在子类中重写时候不需要加virtual也是虚函数。<br>虚函数的实现：在有虚函数的类中，类的最开始部分是一个虚函数表的指针，这个指针指向一个虚函数表，表中放了虚函数的地址，实际的虚函数在代码段(.text)中。当子类继承了父类的时候也会继承其虚函数表，当子类重写父类中虚函数时候，会将其继承到的虚函数表中的地址替换为重新写的函数地址。使用了虚函数，会增加访问内存开销，降低效率。</p><h1 id="12-写个函数在main函数执行前先运行"><a href="#12-写个函数在main函数执行前先运行" class="headerlink" title="12. 写个函数在main函数执行前先运行"></a>12. 写个函数在main函数执行前先运行</h1><p>C++ 的全局对象的构造函数会在 main 函数之前先运行；</p><p>其实在 c 语言里面很早就有了，在 gcc 中可以使用attribute关键字指定如下（在编译器编译的时候就绝决定了）</p><p>详解可参考文章：<a href="https://www.cnblogs.com/zpcoding/p/10805639.html" target="_blank" rel="noopener">如何再main()执行之前先运行其他函数</a></p><h1 id="13-const-char-arr-”123”-char-brr-”123”-char-crr-”123”-的区别"><a href="#13-const-char-arr-”123”-char-brr-”123”-char-crr-”123”-的区别" class="headerlink" title="13. const char *arr=”123”; char *brr=”123”;char  crr[]=”123”;的区别"></a>13. const char *arr=”123”; char *brr=”123”;char  crr[]=”123”;的区别</h1><p>首先， “123”永远都是保存在常量区，要么指针指向常量区”123”，要么数组复制“123”到栈区；</p><p>1）const char *arr=”123”;</p><p>“123”保存在常量区，const本来是修饰arr指向的值不能通过arr去修改，但是字符串“123”在常量区，本来就不能改变，所以加不加const效果都一样;</p><p>2） char *brr=”123”;</p><p>“123”保存在常量区,brr和arr指向的是同一个位置，同样不能通过brr去修改”123”的值</p><p>3）char crr[] = “123”;</p><p>这里“123”相当于一个字符数组，”123”从常量区复制到栈区，可以通过crr去修改；</p><h1 id="14-C语言是怎么进行函数调用的？"><a href="#14-C语言是怎么进行函数调用的？" class="headerlink" title="14. C语言是怎么进行函数调用的？"></a>14. C语言是怎么进行函数调用的？</h1><p>每一个函数调用都会分配函数栈，在栈内进行函数执行过程；</p><p>调用前，先把返回地址压栈，然后把当前函数的ebp指针压栈。然后ebp改为当前esp值，此时ebp=esp，表示初始的子函数帧栈大小为0，然后移动帧指针（修改ebp寄存器）与栈指针（修改esp寄存器），为swap函数创建一个栈帧结构；</p><p>详解可参考：<a href="https://blog.csdn.net/weixin_42462202/article/details/88317097" target="_blank" rel="noopener">C语言函数调用过程</a></p><h1 id="15-说一声fork-wait-exec函数"><a href="#15-说一声fork-wait-exec函数" class="headerlink" title="15. 说一声fork,wait,exec函数"></a>15. 说一声fork,wait,exec函数</h1><p>父进程产生子进程使用<strong>fork()</strong>拷贝出来一个父进程的副本，此时只拷贝了父进程的页表，两个进程都读同一块内存，当有进程写的时候使用写时拷贝机制(可参考：<a href="https://blog.csdn.net/wyll19980812/article/details/106007166" target="_blank" rel="noopener">操作系统面试题汇总</a>中的fork()与vfork())分配内存，<strong>exec()</strong>函数可以加载一个elf文件去替换父进程，从此父进程和子进程就可以运行不同的程序了。fork()给父进程返回子进程的PID，给子进程返回0；</p><p>调用了<strong>wait()</strong>的父进程将会发生阻塞，直到有子进程状态改变,执行成功返回0，错误返回-1；</p><p>exec()执行成功则子进程从新的程序开始运行，无返回值，执行失败返回-1；</p><h1 id="16-说一下C-中类成员的访问权限"><a href="#16-说一下C-中类成员的访问权限" class="headerlink" title="16. 说一下C++中类成员的访问权限"></a>16. 说一下C++中类成员的访问权限</h1><p>C++通过 public、protected、private 三个关键字来控制成员变量和成员函数的访问权限，它们分别表示公有的、受保护的、私有的，被称为成员访问限定符；</p><p>在类的内部（定义类的代码内部），无论成员被声明为 public、protected 还是 private，都是可以互相访问的，没有访问权限的限制；</p><p>在类的外部（定义类的代码之外），只能通过对象访问成员，并且通过对象只能访问 public 属性的成员，不能访问 private、protected 属性的成员；</p><h1 id="17-C-源文件从文本到可执行文件经历的过程"><a href="#17-C-源文件从文本到可执行文件经历的过程" class="headerlink" title="17. C++源文件从文本到可执行文件经历的过程"></a>17. C++源文件从文本到可执行文件经历的过程</h1><p>对于C++源文件，从文本到可执行文件一般需要四个过程：</p><p>1、预处理阶段：对源代码文件中文件包含关系（头文件）、预编译语句（宏定义）进行分析和替换，生成预编译文件;</p><p>2、编译阶段：将经过预处理后的预编译文件转换成特定汇编代码，生成汇编文件;</p><p>3、汇编阶段：将编译阶段生成的汇编文件转化成机器码，生成可重定位目标文件;</p><p>4、链接阶段：将多个目标文件及所需要的库连接成最终的可执行目标文件;</p><h1 id="18-include头文件的顺序以及双引号””和尖括号-lt-gt-的区别"><a href="#18-include头文件的顺序以及双引号””和尖括号-lt-gt-的区别" class="headerlink" title="18. include头文件的顺序以及双引号””和尖括号&lt;&gt;的区别"></a>18. include头文件的顺序以及双引号””和尖括号&lt;&gt;的区别</h1><p>双引号和尖括号的区别：编译器预处理阶段查找头文件的路径不一样；</p><p>对于使用<strong>双引号””</strong>包含的头文件，查找头文件路径先从当前头文件目录开始，若没找到再从编译器设置的头文件路径开始查找；</p><p>而使用<strong>尖括号&lt;&gt;</strong>包含头文件，查找头文件路径直接从编译器设置的开始</p><h1 id="19-malloc的原理"><a href="#19-malloc的原理" class="headerlink" title="19. malloc的原理"></a>19. malloc的原理</h1><p>Malloc函数用于动态分配内存。为了减少内存碎片和系统调用的开销，malloc其采用内存池的方式，先申请大块内存作为堆区，然后将堆区分为多个内存块，以块作为内存管理的基本单位；当用户申请内存时，直接从堆区分配一块合适的空闲块；</p><p>Malloc采用隐式链表结构将堆区分成连续的、大小不一的块，包含已分配块和未分配块；同时malloc采用显示链表结构来管理所有的空闲块，即使用一个双向链表将空闲块连接起来，每一个空闲块记录了一个连续的、未分配的地址；</p><p>当进行内存分配时，Malloc会通过隐式链表遍历所有的空闲块，选择满足要求的块进行分配；当进行内存合并时，malloc采用边界标记法，根据每个块的前后块是否已经分配来决定是否进行块合并；</p><p>Malloc在申请内存时，一般会通过brk或者mmap系统调用进行申请；其中当申请内存小于128K时，会使用系统函数brk在堆区中分配；而当申请内存大于128K时，会使用系统函数mmap ( mmap将一个文件或者其它对象映射进内存 ) 在映射区分配；</p><h1 id="20-C-的内存管理是怎样的"><a href="#20-C-的内存管理是怎样的" class="headerlink" title="20. C++的内存管理是怎样的"></a>20. C++的内存管理是怎样的</h1><p>在C++中，虚拟内存分为代码段、数据段、BSS段、堆区、文件映射区以及栈区六部分。</p><p>1、代码段:包括只读存储区和文本区，其中只读存储区存储字符串常量，文本区存储程序的机器代码；</p><p>2、数据段：存储程序中已初始化的全局变量和静态变量；</p><p>3、BSS 段：存储未初始化的全局变量和静态变量（局部+全局），以及所有被初始化为0的全局变量和静态变量；</p><p>4、堆区：调用new/malloc函数时在堆区动态分配内存，同时需要调用delete/free来手动释放申请的内存；</p><p>5、映射区:存储动态链接库以及调用mmap函数进行的文件映射；</p><p>6、栈：使用栈空间存储函数的返回地址、参数、局部变量、返回值；</p>]]></content>
    
    <summary type="html">
    
      复试准备期间整理的一套C++面试题
    
    </summary>
    
    
      <category term="C&amp;&amp;C++" scheme="http://Luweir.github.io/categories/C-C/"/>
    
    
      <category term="C&amp;&amp;C++" scheme="http://Luweir.github.io/tags/C-C/"/>
    
      <category term="面试" scheme="http://Luweir.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>tacoyu23的建站史</title>
    <link href="http://luweir.github.io/2020/06/28/tacoyu%E7%9A%84%E5%BB%BA%E7%AB%99%E5%8F%B2/"/>
    <id>http://luweir.github.io/2020/06/28/tacoyu%E7%9A%84%E5%BB%BA%E7%AB%99%E5%8F%B2/</id>
    <published>2020-06-28T12:20:12.000Z</published>
    <updated>2020-06-30T14:00:20.936Z</updated>
    
    <content type="html"><![CDATA[<h1 id="2020-6-27-初学Github"><a href="#2020-6-27-初学Github" class="headerlink" title="2020/6/27 初学Github"></a>2020/6/27 初学Github</h1><ol><li><p>因为在线试衣系统以及以后做项目的需要，花了将近六个小时熟悉传说中的Github；</p></li><li><p>对自己的Github进行修改，并创建 .github.io博客；</p></li></ol><h1 id="2020-6-28-博客初成"><a href="#2020-6-28-博客初成" class="headerlink" title="2020/6/28 博客初成"></a>2020/6/28 博客初成</h1><ol><li><p>在CSDN上找资料，学习使用Git命令以及Hexo；</p></li><li><p>Github上使用Hexo配置初始的next主题；</p></li><li><p>使用next第四个主题，调暗模式，把开始的两篇文章传上去；</p></li><li><p>打开并正确使用标签、分类，设置图像、链接以及打赏功能；</p></li></ol><h1 id="2020-6-29-博客基本完善"><a href="#2020-6-29-博客基本完善" class="headerlink" title="2020/6/29 博客基本完善"></a>2020/6/29 博客基本完善</h1><ol><li><p>增加了一些新功能，比如动态背景、加入fork Github图标(虽然这个基本用不着，哈哈)；</p></li><li><p>增加了评论啊、统计等功能，不过还是有两个没配置成功，新版和旧版的区别还是挺大的，网上大多是旧版的教程；</p></li></ol><p>这个熟能生巧，慢慢摸索着前进吧！</p><h1 id="2020-6-30-完善博客"><a href="#2020-6-30-完善博客" class="headerlink" title="2020/6/30 完善博客"></a>2020/6/30 完善博客</h1><ol><li>改了下主页透明度、上传了一些以前写过的文章，哈哈哈！剩下的懒得传了，以后再说吧；</li><li>调整了一下距离，本来准备把主页摘要框框弄个正方形的，发现不好看，又调回去了；</li><li>估计博客暂时就这样了，还勉强吧，哈哈哈！</li></ol>]]></content>
    
    <summary type="html">
    
      博客搭建的心路历程
    
    </summary>
    
    
      <category term="Privacy" scheme="http://Luweir.github.io/categories/Privacy/"/>
    
    
      <category term="记录" scheme="http://Luweir.github.io/tags/%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
</feed>
