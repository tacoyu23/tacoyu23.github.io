{"meta":{"title":"tacoyu'Blog","subtitle":"一旦你知道失败是什么感觉，就会决心追逐成功！","description":"坚持自己所坚持！热爱自己所热爱！","author":"Mr.L","url":"http://yoursite.com","root":"/"},"pages":[{"title":"关于","date":"2020-06-28T05:19:42.000Z","updated":"2020-06-29T06:23:33.380Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":""},{"title":"资源","date":"2020-06-30T01:32:19.000Z","updated":"2020-06-30T01:32:50.596Z","comments":true,"path":"resources/index.html","permalink":"http://yoursite.com/resources/index.html","excerpt":"","text":""},{"title":"分类","date":"2020-06-27T18:52:02.000Z","updated":"2020-06-27T18:53:04.252Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2020-06-28T05:19:42.000Z","updated":"2020-06-28T05:22:56.824Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"test","slug":"test","date":"2020-06-30T01:29:25.000Z","updated":"2020-06-30T01:29:25.936Z","comments":true,"path":"2020/06/30/test/","link":"","permalink":"http://yoursite.com/2020/06/30/test/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"计算机方向及导师选择有感","slug":"计算机方向及导师选择有感","date":"2020-06-29T11:03:15.000Z","updated":"2020-06-29T12:40:39.492Z","comments":true,"path":"2020/06/29/计算机方向及导师选择有感/","link":"","permalink":"http://yoursite.com/2020/06/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%B9%E5%90%91%E5%8F%8A%E5%AF%BC%E5%B8%88%E9%80%89%E6%8B%A9%E6%9C%89%E6%84%9F/","excerpt":"","text":"​ 正常的话，初试成绩出来后就要联系并确定导师，拟录取后得到导师指点，适应研究生生活；但由于一些阻碍（前几个老师名额都满了，后两个老师的名额没确定下来，暂时无法答复我），导师和方向的问题迟迟没有解决，也是我一直打着等老师回复的幌子拖着这个事。 ​ 索性今天就把方向给定了，根据方向去联系导师，本来导师又多，我也不认识，学长学姐也没有参考性的建议，只能排除一些雷硬冲了； ​ 就我而言，喜欢一些有挑战的东西，但常常因为不够自信而不去尝试，这次就冲一把；搜了一些资料，也看了一些论坛帖子，对以下几个方向有了一些理解： ​ 人工智能/机器学习/深度学习：存在着分支关系的这三个方向，需要很好的数学功底，算法功底；读研期间处理模型的时候，需要往复的调参数，越熟练调得越快；而数学到了一定的高度后，就是靠天赋了；所以，这是一个极具有挑战的方向； 毕业后，工作一般是算法岗位、算法工程师，薪资待遇好；纯算法方向（对模型创新）比较吃学历、吃赛奖、吃顶会，工程方向（将现有模型编程落地项目）的话门槛要求相对低点； 其中的自然语言处理(NLP)和计算机视觉(CV)属于比较火热的方向，但CV由于人数多、落地少，NLP相对来说比较受青睐，但目前基本就大厂设了，进大厂难，小厂如果有的话，则进去相对容易一些，在以后的话应该有一个好的发展； 在我看来，智能推荐的领域应该比NLP的宽，并且感觉覆盖面更广一些，不知道就业形势会不会好点； ​ 大数据：大数据的方向大体有开发和分析两种，主要以java为主吧，python也有；大数据薪资也算可以，就业不错，应该算是主流方向吧； ​ 开发岗位：这个不算是研究方向，但是就业的一个很好的指南针；学好Java，步入开发岗位，岗位多，薪资过得去，避坑机器学习，也是大多数程序员的选择吧； 所以，读研期间就以优先NLP/推荐系统，然后机器学习/深度学习，其次大数据相关方向吧，毕竟很多东西都没真正接触过，也不知道自己真正喜欢什么，想要什么；课后就自己学学java开发，凡事留条后路； 最近国家还投了2000亿在电子产业上，估计通信电子行业在几年内会持续上升吧；","categories":[{"name":"Privacy","slug":"Privacy","permalink":"http://yoursite.com/categories/Privacy/"}],"tags":[{"name":"记录","slug":"记录","permalink":"http://yoursite.com/tags/%E8%AE%B0%E5%BD%95/"}]},{"title":"C++面试题","slug":"C++面试题","date":"2020-06-29T03:50:22.000Z","updated":"2020-06-29T07:30:28.651Z","comments":true,"path":"2020/06/29/C++面试题/","link":"","permalink":"http://yoursite.com/2020/06/29/C++%E9%9D%A2%E8%AF%95%E9%A2%98/","excerpt":"","text":"1. C++和C的区别1）在设计思想上： C++是面向对象的语言，而C是面向过程的结构化编程语言； 2）在内容方面： C++是C的超集，即C是C++的子集，C++兼容C； C++引入类、封装、隐藏、继承、多态等特性；引入STL标准模板库等； C++提供引用&amp;机制，降低使用指针的复杂度； C++提供内联函数inline； 3）在语法方面： C++中new和delete是对内存分配的运算符，取代了c的malloc和free； C++中用控制标准输入输出的iostream类库代替了标准C中的stdio函数库； C++中的try/catch/throw异常处理机制取代了C中的setjmp()和longjmp()； 强制类型转换，C++提供两种两种格式，而C只有第一种； 123float el = 123.233;int i = (int) el; //第一种 int j = int (el);//第二种 C++允许设置函数默认参数，而C不允许； C++允许对函数进行重载(两个同名函数，若它们参数类型不一致or参数个数不同，则为两个不同的函数)，而C不允许； C++允许在程序任何地方定义变量，而C只允许在函数开头部分定义； 详解可参考文章：C++和C的区别 2. static的作用1、全局静态变量 存放于静态存储区； 在整个程序运行期间都存在； 未被初始化时自动初始化为0； 作用域：从定义之处开始到文件结尾； 2、局部静态变量 仅作用域与全局静态变量不同：局部静态变量在定义它的函数or语句块结束时，作用域便结束，此时不可访问，当再次调用函数时，即可访问且值不变； 3、静态函数 函数默认extern，即可以被其他文件可用； 而静态函数只能在声明它的文件中可见，不能被其他文件所引用； 4、类的静态成员变量 类的静态成员可实现多个对象之间的数据共享，只存储于溢出，共该类的所有对象共用； 5、类的静态成员函数 调用静态成员函数不需要用对象名（但可以用），且静态成员函数中不能直接引用类中的非静态成员，因为它不知道这个成员为那个对象所有； 调用静态成员函数使用如下格式：&lt;类名&gt;::&lt;静态成员函数名&gt;(&lt;参数表&gt;); 3. C++中的四种cast转换C++中四种类型转换是：static_cast, dynamic_cast, const_cast, reinterpret_cast； 1、const_cast 用于将const变量转为非const； 2、static_cast 用于各种隐式转换，比如非const转const，void*转指针等, static_cast能用于多态向上转化，如果向下转能成功但是不安全，结果未知； 3、dynamic_cast 用于动态类型转换。只能用于含有虚函数的类，用于类层次间的向上和向下转化。只能转指针或引用。向下转化时，如果是非法的对于指针返回NULL，对于引用抛异常。 向上转换：指的是子类向基类的转换； 向下转换：指的是基类向子类的转换； 它通过判断在执行到该语句的时候变量的运行时类型和要转换的类型是否相同来判断是否能够进行向下转换； 4、reinterpret_cast 几乎什么都可以转，比如将int转指针，可能会出问题，尽量少用； 4. C++/C中指针和引用的区别1、指针有自己的一块空间，而引用只是别名； 12345short a=1;short *p=&amp;a;short &amp;b=a;cout&lt;&lt;sizeof(p);//输出4cout&lt;&lt;sizeof(b);//输出2 2、指针可被初始化为NULL，而引用必须被初始化且必须是一个已有对象的引用； 3、可以有const指针，但是没有const引用； 4、指针可以在使用中指向其他对象，而引用一旦初始化，便不能再指向别的对象； 5、指针可以有多级(**p)，而引用只有一级； 6、指针和引用使用++运算符的意义不同；如若变量i是int类型，p指向i，b是i的引用；那么++p表示p的值等于 i 的地址加四个地址单位后的地址；而++b的值是i+1； 7、如果返回动态内存分配的对象或者内存，必须使用指针，引用可能引起内存泄露； 5. 什么是野指针野指针就是指向一个已删除的对象或者未申请访问受限内存区域的指针； 6. 为什么对于会被继承的类，其析构函数必须是虚函数？将可能会被继承的父类的析构函数设置为虚函数，可以保证当我们new一个子类，然后使用基类指针指向该子类对象，释放该子类对象的空间时，可以释放掉子类的空间，防止内存泄漏。 C++默认的析构函数不是虚函数是因为虚函数需要额外的虚函数表和虚表指针，占用额外的内存。而对于不会被继承的类来说，其析构函数如果是虚函数，就会浪费内存。因此C++默认的析构函数不是虚函数，而是只有当需要当作父类时，设置为虚函数。 详解可参考：继承-虚析构函数 7. 函数指针1、定义 函数指针是指向函数的指针变量； 函数指针本身首先是一个指针变量，该指针变量指向一个具体的函数。这正如用指针变量可指向整型变量、字符型、数组一样，这里是指向函数； C在编译时，每一个函数都有一个入口地址，该入口地址就是函数指针所指向的地址；有了指向函数的指针变量后，可用该指针变量调用函数，就如同用指针变量可引用其他类型变量一样，在这些概念上是大体一致的； 2、用途： 调用函数和做函数的参数，比如回调函数。 3、示例： 12345678910int fun(char c) //函数fun&#123; return c;&#125;int main()&#123; int (*pf)(char c); //定义函数指针pf pf=fun; //将函数指针pf指向函数fun cout&lt;&lt;pf('a'); //输出97&#125; 8. C++中析构函数的作用析构函数与构造函数对应，当对象结束其生命周期，如对象所在的函数已调用完毕时，系统会自动执行析构函数。 析构函数名也应与类名相同，只是在函数名前面加一个位取反符，例如stud( )，以区别于构造函数。它不能带任何参数，也没有返回值（包括void类型）。只能有一个析构函数，不能重载； 如果用户没有编写析构函数，编译系统会自动生成一个缺省的析构函数（即使自定义了析构函数，编译器也总是会为我们合成一个析构函数，并且如果自定义了析构函数，编译器在执行时会先调用自定义的析构函数再调用合成的析构函数），它也不进行任何操作。所以许多简单的类中没有用显式的析构函数； 如果一个类中有指针，且在使用的过程中动态的申请了内存，那么最好显示构造析构函数在销毁类之前，释放掉申请的内存空间，避免内存泄漏； 类析构顺序：1）派生类本身的析构函数；2）对象成员析构函数；3）基类析构函数。 9. 静态函数和虚函数的区别静态函数在编译的时候就已经确定运行时机，虚函数在运行的时候动态绑定。虚函数因为用了虚函数表机制，调用的时候会增加一次内存开销； 10. 重载和覆盖重载：两个函数名相同，但是参数列表不同（个数，类型），返回值类型没有要求，在同一作用域中； 重写/覆盖：子类继承了父类，父类中的函数是虚函数，在子类中重新定义了这个虚函数，这种情况是重写; 11. 对虚函数和多态的理解多态的实现主要分为静态多态和动态多态，静态多态主要是重载，在编译的时候就已经确定；动态多态是用虚函数机制实现的，在运行期间动态绑定。举个例子：一个父类类型的指针指向一个子类对象时候，使用父类的指针去调用子类中重写了的父类中的虚函数的时候，会调用子类重写过后的函数，在父类中声明为加了virtual关键字的函数，在子类中重写时候不需要加virtual也是虚函数。虚函数的实现：在有虚函数的类中，类的最开始部分是一个虚函数表的指针，这个指针指向一个虚函数表，表中放了虚函数的地址，实际的虚函数在代码段(.text)中。当子类继承了父类的时候也会继承其虚函数表，当子类重写父类中虚函数时候，会将其继承到的虚函数表中的地址替换为重新写的函数地址。使用了虚函数，会增加访问内存开销，降低效率。 12. 写个函数在main函数执行前先运行C++ 的全局对象的构造函数会在 main 函数之前先运行； 其实在 c 语言里面很早就有了，在 gcc 中可以使用attribute关键字指定如下（在编译器编译的时候就绝决定了） 详解可参考文章：如何再main()执行之前先运行其他函数 13. const char *arr=”123”; char *brr=”123”;char crr[]=”123”;的区别首先， “123”永远都是保存在常量区，要么指针指向常量区”123”，要么数组复制“123”到栈区； 1）const char *arr=”123”; “123”保存在常量区，const本来是修饰arr指向的值不能通过arr去修改，但是字符串“123”在常量区，本来就不能改变，所以加不加const效果都一样; 2） char *brr=”123”; “123”保存在常量区,brr和arr指向的是同一个位置，同样不能通过brr去修改”123”的值 3）char crr[] = “123”; 这里“123”相当于一个字符数组，”123”从常量区复制到栈区，可以通过crr去修改； 14. C语言是怎么进行函数调用的？每一个函数调用都会分配函数栈，在栈内进行函数执行过程； 调用前，先把返回地址压栈，然后把当前函数的ebp指针压栈。然后ebp改为当前esp值，此时ebp=esp，表示初始的子函数帧栈大小为0，然后移动帧指针（修改ebp寄存器）与栈指针（修改esp寄存器），为swap函数创建一个栈帧结构； 详解可参考：C语言函数调用过程 15. 说一声fork,wait,exec函数父进程产生子进程使用fork()拷贝出来一个父进程的副本，此时只拷贝了父进程的页表，两个进程都读同一块内存，当有进程写的时候使用写时拷贝机制(可参考：操作系统面试题汇总中的fork()与vfork())分配内存，exec()函数可以加载一个elf文件去替换父进程，从此父进程和子进程就可以运行不同的程序了。fork()给父进程返回子进程的PID，给子进程返回0； 调用了wait()的父进程将会发生阻塞，直到有子进程状态改变,执行成功返回0，错误返回-1； exec()执行成功则子进程从新的程序开始运行，无返回值，执行失败返回-1； 16. 说一下C++中类成员的访问权限C++通过 public、protected、private 三个关键字来控制成员变量和成员函数的访问权限，它们分别表示公有的、受保护的、私有的，被称为成员访问限定符； 在类的内部（定义类的代码内部），无论成员被声明为 public、protected 还是 private，都是可以互相访问的，没有访问权限的限制； 在类的外部（定义类的代码之外），只能通过对象访问成员，并且通过对象只能访问 public 属性的成员，不能访问 private、protected 属性的成员； 17. C++源文件从文本到可执行文件经历的过程对于C++源文件，从文本到可执行文件一般需要四个过程： 1、预处理阶段：对源代码文件中文件包含关系（头文件）、预编译语句（宏定义）进行分析和替换，生成预编译文件; 2、编译阶段：将经过预处理后的预编译文件转换成特定汇编代码，生成汇编文件; 3、汇编阶段：将编译阶段生成的汇编文件转化成机器码，生成可重定位目标文件; 4、链接阶段：将多个目标文件及所需要的库连接成最终的可执行目标文件; 18. include头文件的顺序以及双引号””和尖括号&lt;&gt;的区别双引号和尖括号的区别：编译器预处理阶段查找头文件的路径不一样； 对于使用双引号””包含的头文件，查找头文件路径先从当前头文件目录开始，若没找到再从编译器设置的头文件路径开始查找； 而使用尖括号&lt;&gt;包含头文件，查找头文件路径直接从编译器设置的开始 19. malloc的原理Malloc函数用于动态分配内存。为了减少内存碎片和系统调用的开销，malloc其采用内存池的方式，先申请大块内存作为堆区，然后将堆区分为多个内存块，以块作为内存管理的基本单位；当用户申请内存时，直接从堆区分配一块合适的空闲块； Malloc采用隐式链表结构将堆区分成连续的、大小不一的块，包含已分配块和未分配块；同时malloc采用显示链表结构来管理所有的空闲块，即使用一个双向链表将空闲块连接起来，每一个空闲块记录了一个连续的、未分配的地址； 当进行内存分配时，Malloc会通过隐式链表遍历所有的空闲块，选择满足要求的块进行分配；当进行内存合并时，malloc采用边界标记法，根据每个块的前后块是否已经分配来决定是否进行块合并； Malloc在申请内存时，一般会通过brk或者mmap系统调用进行申请；其中当申请内存小于128K时，会使用系统函数brk在堆区中分配；而当申请内存大于128K时，会使用系统函数mmap ( mmap将一个文件或者其它对象映射进内存 ) 在映射区分配； 20. C++的内存管理是怎样的在C++中，虚拟内存分为代码段、数据段、BSS段、堆区、文件映射区以及栈区六部分。 1、代码段:包括只读存储区和文本区，其中只读存储区存储字符串常量，文本区存储程序的机器代码； 2、数据段：存储程序中已初始化的全局变量和静态变量； 3、BSS 段：存储未初始化的全局变量和静态变量（局部+全局），以及所有被初始化为0的全局变量和静态变量； 4、堆区：调用new/malloc函数时在堆区动态分配内存，同时需要调用delete/free来手动释放申请的内存； 5、映射区:存储动态链接库以及调用mmap函数进行的文件映射； 6、栈：使用栈空间存储函数的返回地址、参数、局部变量、返回值；","categories":[{"name":"C&&C++","slug":"C-C","permalink":"http://yoursite.com/categories/C-C/"}],"tags":[{"name":"C&&C++","slug":"C-C","permalink":"http://yoursite.com/tags/C-C/"},{"name":"面试","slug":"面试","permalink":"http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"tacoyu23的建站史","slug":"tacoyu的建站史","date":"2020-06-28T12:20:12.000Z","updated":"2020-06-30T00:13:14.991Z","comments":true,"path":"2020/06/28/tacoyu的建站史/","link":"","permalink":"http://yoursite.com/2020/06/28/tacoyu%E7%9A%84%E5%BB%BA%E7%AB%99%E5%8F%B2/","excerpt":"","text":"2020/6/27 初学Github 因为在线试衣系统以及以后做项目的需要，花了将近六个小时熟悉传说中的Github； 对自己的Github进行修改，并创建 .github.io博客； 2020/6/28 博客初成 在CSDN上找资料，学习使用Git命令以及Hexo； Github上使用Hexo配置初始的next主题； 使用next第四个主题，调暗模式，把开始的两篇文章传上去； 打开并正确使用标签、分类，设置图像、链接以及打赏功能； 2020/6/29 博客基本完善 增加了一些新功能，比如动态背景、加入fork Github图标(虽然这个基本用不着，哈哈)； 增加了评论啊、统计等功能，不过还是有两个没配置成功，新版和旧版的区别还是挺大的，网上大多是旧版的教程； 这个熟能生巧，慢慢摸索着前进吧！","categories":[{"name":"Privacy","slug":"Privacy","permalink":"http://yoursite.com/categories/Privacy/"}],"tags":[{"name":"记录","slug":"记录","permalink":"http://yoursite.com/tags/%E8%AE%B0%E5%BD%95/"}]},{"title":"Hexo搭建Next进行美化详解","slug":"Hexo搭建Next进行美化详解","date":"2020-06-28T09:24:22.000Z","updated":"2020-06-29T14:46:41.249Z","comments":true,"path":"2020/06/28/Hexo搭建Next进行美化详解/","link":"","permalink":"http://yoursite.com/2020/06/28/Hexo%E6%90%AD%E5%BB%BANext%E8%BF%9B%E8%A1%8C%E7%BE%8E%E5%8C%96%E8%AF%A6%E8%A7%A3/","excerpt":"","text":"前提是已经安装Node.js 、Git 和Hexo以及注册Github账户； 安装流程可见：使用 Github Pages 和 Hexo 搭建自己的独立博客【超级详细的小白教程】 1、Next主题的启用在Hexo下面的themes中，右键 选择Git base here 复制这行代码 1git clone https:&#x2F;&#x2F;github.com&#x2F;theme-next&#x2F;hexo-theme-next themes&#x2F;next 等待完成后，打开Hexo的这个文件 找到 theme 把 theme 后面的 landscape 改成 next 即可； 然后在Hexo文件夹中 右键 Git base here 输入以下命令，启动本地预览 出现下面两个INFO表示成功，在浏览器中进入http://localhost:4000进行查看； 查看后需要关闭的话 则要在命令行输入Ctrl + c 结束； 这样 next主题就启动成功了； 2、更改Next主题为中文同样打开Hexo的_config.yml文件，这是配置文件 找到Site 下的 language ，改成zh-CN即可 然后在命令行可开启本地预览查看； 3、添加标签页和分类页打开文件 找到meau 然后把tags 和 categories前面的#号去掉，然后保存 然后本地预览 可发现 但是点进去后不会显示，因为你没有创建标签页和分类页 4、正确打开标签页和分类页进入文件夹 启动git命令行 输入命令： hexo n page tags 就会在source中创建tags文件夹，并在里面创建index.md文件，表示已经可以使用； 然后打开index.md 进行修改 注意冒号后面必须有一个空格； 对于分类页同理，hexo n page categories 然后修改的时候type: “categories”； 5、主题样式的更改在next的主题配置文件里面 找到Schemes ，发现有四种主题： 要用哪个就把哪个前面的#去掉，其它的三个加上# (#代表注释)； Muse： Mist： pisces： Gemini： 改完保存，本地预览即可； 6、更改图像在next配置文件中，找到 默认就是这个样子 更改的话只需改url后面的网站，网站的内容就是你将用的图像； 7、更改标题、作者和链接在Hexo的配置文件下，找到 然后对这些进行修改 保存即可； 8、启动侧边栏社交链接打开next的配置文件中，找到social links 对后面的链接进行修改 然后去掉# 即可显示； 注意 #号是注释作用，只有去掉#号才能生效； 9、启用友情链接在next的配置文件中 找到 links： 名称: url 显示出来是这样： 上面那个title：Links也是可以改的，比如我改成友情链接，显示是这样： 10、新建一篇文章Hexo文件中打开命令行； 12输入：hexo n 文件名//在Hexo\\source\\_posts下建立对应.md形式的文件 进入本地预览； 11、markdown基本使用创建一个测试文档 输入— 然后回车，头部格式就出来了，接着输入该文档的title、tag、categories、description等待；就是下面这样： 插入链接 [ 链接标题 ]（链接url） 插入图片/文件 ！[ 文件标题 ]（文件/图片url） 斜体两个*号中间的内容是斜体 字体是斜的 粗体两个**号之间的是粗体 字体是粗的 插入代码块单行：//单行代码 代码块： 123// 代码块x// xx// xx 引用输入一个&gt; 随后输入的内容就是引用； 分割线连续三个 - 或者 三个 *，然后回车 12、开启打赏功能next里面的配置文件中，找到Reward 然后enable 和 animation 设置为true 并添加个人的微信收款码和支付宝收款码； 放到 next/source/images 中； 13、开启订阅公众号在next的配置文件中找到subscribe 可通过以下四个方式订阅，也可添加； 14、设置头像为圆形可旋转需要对这个文件进行修改； 按下图修改 然后直接打开next的配置文件，找到avatar 把rounded和rotated设置为true； rounded是说要不要把图像设置为圆形； rotated是说要不要让它转，如果要修改转的一些详细信息，就要到之前说的那个siderbar-author那个文件去修改； 15、首页文章设置阅读全文next的配置文件下，找到这里 把这两个都设置为true，默认应该是true； 然后有两种方法： 法1： 在博客的头部 添加description，然后在后面输入你的描述，那么在你的博客中，这篇文章就只会显示你写的描述，剩下的由阅读全文这个按钮代替； 法2： 在文章中输入这一行代码，那么默认这行代码之前的部分为描述，之后的部分在阅读全文中显示； 16、添加动态背景今天在学习使用Hexo修改next的背景时，发现： 这几个东西我无论设置哪些个为true，都调不出动态背景；随后开始在网上搜，发现大多都是针对老版本的NexT调动态背景或者canvas_nest的解决方法，不过也受到一些启发，这里就用新版本的演示一下： 1、首先看这里Dependencies: https://github.com/theme-next/theme-next-three表示这三个动态背景依赖于git克隆(clone)才能使用； 2、然后在next文件下打开Git命令行界面，准备clone输入命令后，等待下载；下载后就会有一个这样的文件出现在next文件夹中 只需要将此文件重命名为three，然后剪贴到next/source/lib文件下下面即可； 3、依赖包已经克隆了，之后就只用改之前那几个参数就能调选择你喜欢的动态背景了；调完后，hexo s 本地预览下； 如果你对canva_nest有着独特的喜爱，那就clone它的依赖包放入next/source/lib中，然后千万记得，在next的_config.yml文件中加上这样两句话： ​ 想打开时，把enable置为true即可，这个与上面动态背景总开关没联系！等于说你可以上面设为false，canvas_nest设置为true，它一样可以用这个动态背景！ 17、给博客添加fork Github进入这个网站GitHub Corners 选一个心仪的图标，然后复制它旁边框框里的内容； 打开文件 搜索headband，在它下面插入这段复制的内容； 然后把 href 那里的网址改成自己github的地址！！！ 保存，再本地预览即可看见； 18、修改文章内链接样式打开next内部的这个文件： 在此文件的最后面加上代码块： 1234567.post-body p a&#123; color: #345; border-bottom: none; &amp;:hover&#123; color: white; &#125;&#125; 19、怎样修改文章底部#标签式样打开这个文件： 找到这个位置 在 rel=”tag”&gt; 后插入 图标可以在Font awesome中找自己喜欢的，替换就行； r然后修改next配置文件： 20、增加Valine评论功能注册LeanCloud网站 实名认证 验证邮箱 然后创建应用，进入应用设置 进入之后，复制应用Keys下的AppID和Appkey； 在next的配置文件中找到如图valine位置 更改为 将自己的appid和appkey复制过去； 保存； 21、增加搜索功能next的配置文件中，置local_search为true 22、增加不蒜子统计功能next的配置文件中找到这个并置为true； 23、内容分享服务（未完成） 24、增加加载效果 置为true； 然后在next下，打开git命令行，输入 git clone https://github.com/theme-next/theme-next-pace 等待依赖包下载成功即可； 25、增加点击爆炸效果(未完成)26、隐藏底部 强力驱动 置为false就行； 27、增加字数统计和阅读时长功能clone wordcount包：hexo文件夹内打开git命令行，输入命令npm i --save hexo-wordcount 如果根目录下的package.json文件有以下信息，则表示安装成； 然后打开此文件 在这个位置处插入下面代码块： 1234567 &lt;span title=\"&#123;&#123; __('post.wordcount') &#125;&#125;\"&gt; 字数统计 : &#123;&#123; wordcount(post.content) &#125;&#125; 字 | &lt;/span&gt; &lt;span title=\"&#123;&#123; __('post.min2read') &#125;&#125;\"&gt; 阅读时长 ≈ &#123;&#123; min2read(post.content) &#125;&#125; 分钟&lt;/span&gt; 然后在next的配置文件中 下面三个置为true； 然后就设置完成了 这是效果图： 在想办法，看如何把它放在标题下面；","categories":[{"name":"Github","slug":"Github","permalink":"http://yoursite.com/categories/Github/"}],"tags":[{"name":"Github","slug":"Github","permalink":"http://yoursite.com/tags/Github/"},{"name":"Hexo","slug":"Hexo","permalink":"http://yoursite.com/tags/Hexo/"},{"name":"Next","slug":"Next","permalink":"http://yoursite.com/tags/Next/"}]},{"title":"Github的介绍与使用","slug":"Github介绍与使用","date":"2020-06-27T19:20:12.000Z","updated":"2020-06-29T12:39:15.578Z","comments":true,"path":"2020/06/28/Github介绍与使用/","link":"","permalink":"http://yoursite.com/2020/06/28/Github%E4%BB%8B%E7%BB%8D%E4%B8%8E%E4%BD%BF%E7%94%A8/","excerpt":"","text":"一、绪论1.1 目的借助github托管项目代码 GitHub是全球最大的社交编程及代码托管网站； 可以托管各种git库，并提供一个web界面； 1.2 基本概念仓库(Repository)仓库即你的项目，在github上开源一个项目，就必须新建一个Repository； 收藏(Star)仓库主页star按钮，意思为收藏该项目的人数，一个项目有100个star都算很不容易了； 复制项目(Fork) 建立一份和别人一模一样的仓库，独立存在； 发起请求(Pull Request)若李四在这个仓库里进行修改，随后李四可以在自己仓库中点击 Pull Request 来请求张三合并仓库(待张三查看后确认合并后才执行)； 关注(Watch)关注某人或者某个项目，一旦项目有任何更新，则会收到提醒； 事务卡片(Issue)发现代码BUG，但是目前没有成型代码，需要讨论时使用； 1.3 注册 现在不管是私有还是公开都是免费的了！！！ 1.4 Notice1、因为 github 在国外服务器，所以访问速度较慢或者无法访问，需要翻墙(软件: Shadowsocks)； 2、私有仓库只能自己和指定的朋友才有权限操作； 二、仓库Repository2.1 创建仓库 2.2 仓库介绍 2.3 仓库管理创建文件 修改文件 +号代表新增的，-号代表删除的； 删除文件 上传文件 搜索文件 或者快捷键T 下载/检出项目 2.4 github Issues出现问题时，讨论使用； A在看B的仓库时，发现其中存在的问题，然后新建一个Issue，然后B的主页就会显示此Issue； 先谢谢 有问题就提 然后觉得没问题了就可以close 双方都可以close； 2.5 开源项目贡献流程1、新建Issue 提交使用问题或者建议、想法； 2、Pull Request 1）fork项目； 2）修改自己仓库的项目代码； 3）新建 pull Request； 4）等待作者操作审核，合并； 三、Git安装和使用3.1 目的通过 git 管理 github 托管项目代码 3.2 下载安装官网下载请点击 不过官网下载太慢了，给出一个网盘链接, 提取码：oiiy 一直next； 鼠标右击桌面出现两个Git 即为安装成功； 3.3 Git基础设置1、设置用户名git config –global user.name ‘用户名’ 2、设置用户名邮箱git config –global user.email ‘xxxxxx.com ‘ 初始化一次就不用初始化了！！！ 3.4 初始化Git仓库1、创建文件夹 2、在文件内初始化git（创建git仓库）选择目录命令：cd test 初始化：git init 创建了一个隐藏的文件 3.5 工作区域工作区 working Directory添加、编辑、修改文件等动作 仓库 Git Repository Git最终确定的文件保存到仓库，成为一个新的版本，并对他人可见； 暂存区暂存已经修改的文件，最后统一提交到git仓库； 3.6 常见命令cd 文件夹进入当前文件夹目录下 git status获得仓库状态 git add 文件名提交工作区的文件到暂存区 git commit -m ’提交描述‘提交暂存区的文件到git仓库 ls显示文件清单 nano 文件名对该文件内容进行修改； rm -rf 文件名删除该文件 git put提交本地仓库到git云仓库 3.7 常用操作1、向仓库提交文件1）创建文件 2）添加到暂存区 3）将文件从暂存区提交到仓库 2、修改仓库文件1）修改文件 notice： vi修改文件不太好用，建议nano修改； 2）添加到暂存区 ​ 3）提交到git仓库 3、删除仓库文件1）直接删除文件 rm -rf al.php 2）提交到暂存区 3）提交到仓库 四、 Git远程管理仓库4.1 目的作用：备份，实现代码共享集中化管理； 4.2 将本地仓库同步到git远程仓库 1、先fork到本地目的：将远程仓库（GitHub对应项目）复制到本地 代码：git clone 仓库地址 仓库地址怎么来： 成功复制到本地后： 与GitHub上的一致； 2、建立 文件，然后 提交到本地仓库后完成后提示以下内容： 3、键入 git push 完成云同步会提示登陆 github 完成操作； 登陆后依旧会要你 输入用户名和密码 全部输入后 会出现以下界面： 同时查看git仓库 发现已经提交上了 4.3 解决git push错误 config文件通过记事本打开，按图片内容修改即可； 五、Github Pages搭建个人网站5.1 访问 https://户名.github.io 5.2 搭建步骤1、创建个人站点 -&gt; 新建仓库 (仓库名必须是[ 用户名.github.io ] ) 2、在仓库下新建 index.html 的文件即可； 新建index.html文件，并输入内容 随后登陆网站可查看； Notice： 1、github pages 仅支持静态网页； 2、仓库里面只能是.html文件； 5.3 Projet Pages 项目站点https://用户名.github.io/仓库名 // 新版github好像没有； 搭建步骤1）进入项目主页，点击settings； 2）在settings里面点击choose a theme，来自动生成主题； 3）生成网页 六、博客主题及美化6.1 博客主题fork及使用博客主题的使用推荐阅读文章： Hexo博客优化之Next主题美化 使用 Github Pages 和 Hexo 搭建自己的独立博客【超级详细的小白教程】 6.2 博客主题美化博客美化推荐阅读文章： 这篇文章的有些修改适用，有些不适用Hexo框架下用NexT(v7.0+)主题美化博客 使用 Github Pages 和 Hexo 搭建自己的独立博客【超级详细的小白教程】 Hexo-Next 主题博客个性化配置超详细，超全面(两万字)","categories":[{"name":"Github","slug":"Github","permalink":"http://yoursite.com/categories/Github/"}],"tags":[]}],"categories":[{"name":"Privacy","slug":"Privacy","permalink":"http://yoursite.com/categories/Privacy/"},{"name":"C&&C++","slug":"C-C","permalink":"http://yoursite.com/categories/C-C/"},{"name":"Github","slug":"Github","permalink":"http://yoursite.com/categories/Github/"}],"tags":[{"name":"记录","slug":"记录","permalink":"http://yoursite.com/tags/%E8%AE%B0%E5%BD%95/"},{"name":"C&&C++","slug":"C-C","permalink":"http://yoursite.com/tags/C-C/"},{"name":"面试","slug":"面试","permalink":"http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"},{"name":"Github","slug":"Github","permalink":"http://yoursite.com/tags/Github/"},{"name":"Hexo","slug":"Hexo","permalink":"http://yoursite.com/tags/Hexo/"},{"name":"Next","slug":"Next","permalink":"http://yoursite.com/tags/Next/"}]}