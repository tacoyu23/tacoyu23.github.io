{"meta":{"title":"tacoyu'Blog","subtitle":"一旦你知道失败是什么感觉，就会决心追逐成功！","description":"坚持自己所坚持！热爱自己所热爱！","author":"Mr.L","url":"http://tacoyu23.github.io","root":"/"},"pages":[{"title":"关于","date":"2020-06-28T05:19:42.000Z","updated":"2020-06-29T06:23:33.380Z","comments":true,"path":"about/index.html","permalink":"http://tacoyu23.github.io/about/index.html","excerpt":"","text":""},{"title":"资源","date":"2020-06-30T01:32:19.000Z","updated":"2020-06-30T01:32:50.596Z","comments":true,"path":"resources/index.html","permalink":"http://tacoyu23.github.io/resources/index.html","excerpt":"","text":""},{"title":"分类","date":"2020-06-27T18:52:02.000Z","updated":"2020-06-27T18:53:04.252Z","comments":true,"path":"categories/index.html","permalink":"http://tacoyu23.github.io/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2020-06-28T05:19:42.000Z","updated":"2020-06-28T05:22:56.824Z","comments":true,"path":"tags/index.html","permalink":"http://tacoyu23.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"位运算的巧妙之处","slug":"位运算的巧妙之处","date":"2020-06-30T05:59:59.000Z","updated":"2020-06-30T07:47:16.240Z","comments":true,"path":"2020/06/30/位运算的巧妙之处/","link":"","permalink":"http://tacoyu23.github.io/2020/06/30/%E4%BD%8D%E8%BF%90%E7%AE%97%E7%9A%84%E5%B7%A7%E5%A6%99%E4%B9%8B%E5%A4%84/","excerpt":"","text":"位运算的巧妙之处算法中，位运算可以巧妙运用在一下几个方面： 1、判断奇偶数 =&gt; x&amp;1 2、判断数x中第k ( 从右至左 ) 位是1还是0 法1：( x &gt;&gt; ( k - 1 ) ) &amp; 1 法2：x &amp; ( 1 &lt;&lt; ( k - 1 ) ) 3、交换两个整数变量 a , b 的值 123a = a ^ b;b = b ^ a;a = a ^ b; 这里为什么能这样做，在后面的异或运算中会说明； 4、不用判断语句，求整数绝对值 1return (value ^ (value &gt;&gt; 31))-(value &gt;&gt;31) 同样在异或运算中说明； 应用二进制中1的个数描述：实现一个函数，输入一个正整数，输出该数二进制表示中1的个数。 例：9的二进制表示为1001，有2位是1； 思路：循环运用判断x的第k位是否为1的方法； 1234567int count=0;while(value)&#123; count += value &amp; 1; value = value &gt;&gt; 1;&#125;return count; 方法二： &amp;运算有这样一个性质：a = ( a - 1 ) &amp; a ； 这样a就能消除最低位的一个1； 思路：利用这一性质，我们可以每次将value-1，然后与自己&amp;，能做多少次这样的操作就说明有多少个1； 1234567int count=0;while(value)&#123; value = (value - 1) &amp; value; count++;&#125;return count; 异或运算的巧妙之处性质异或又称不进位加法，两个数相异或，对应位相同则为0，不同则为1； 具有以下性质： 1、a ^ a = 0； 2、0 ^ a = a； 3、异或具有交换律和结合律 b ^ c = c ^ b； a ^ b ^ c = a ^ ( b ^ c) = ( a ^ b ) ^ c；4、( -1 ) ^ a =！a; 应用交换两个变量的值交换变量a,b的值 123a = a ^ b;b = b ^ a;a = a ^ b; 利用异或运算的交换律和结合律，可以得到如下： 1、a = a ^ b; 2、b = b ^ a; 把1式代入2式中，此时 b = b ^ ( a ^ b ) ，则 b = b ^ b ^ a = a; 3、a = a ^ b; 将1式和 b = a 代入3式，则 a = a ^ b ^ a = b; 不用判断语句，求整数绝对值1return (value ^ (value &gt;&gt; 31))-(value &gt;&gt;31) 1、若value为正数，则value二进制表示中最高位一定为0，那么 value &gt;&gt; 31 =0; value ^ (value &gt;&gt; 31) = value ^ 0 = value; value - (value &gt;&gt; 31) = value - 0 = value; 即正数的绝对值仍是自身； 2、若value为负数，则value二进制表示中最高位一定为1，那么 value &gt;&gt; 31 = 111…1 ,一共32个1，即-1； value ^ (value &gt;&gt; 31) = ! value; 而负数以补码形式存放，==补码等于绝对值的原码取反+1==； 那么这里 ! value - (value &gt;&gt; 31) =&gt; ! value +1 即得到的是value的绝对值； 如果理解有困难，可以看这个例子： 如何找唯一成对的数？问题描述：1-1000这1000个数放在含有1001个元素的数组中，只有唯一的一个元素值重复，其它均只出现一次。每个数组元素只能访问一次，在不用辅助存储空间的前提下，设计一个算法，将它找出来； 思路：根据异或性质1： a ^ a = 0；可以用来==去重==； 令T = 1 ^ 2 ^ 3 ^….. ^ 1000 ； 那么遍历数组的同时将当前数字与 T 异或，在数组中只出现一次的数字会与 T 中的该数字相抵消，从而去重；最终会剩下重复的那个元素，因为它在数组和T中一共出现3次； 举一个只有11个数的例子： 重复的元素在任意位置出现都是可以找出来的； 12345678910int T=0;for(int i=1;i&lt;=1000;i++)&#123; T=T^i; &#125;for(int i=0;i&lt;=1000;i++)&#123; T=T^A[i];&#125;return T; 如有错误，感谢指正！","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://tacoyu23.github.io/categories/Algorithm/"}],"tags":[{"name":"Bit","slug":"Bit","permalink":"http://tacoyu23.github.io/tags/Bit/"}]},{"title":"十大经典排序算法C++实现及总结","slug":"十大经典排序算法C-实现及总结","date":"2020-06-30T05:58:23.000Z","updated":"2020-06-30T05:59:43.749Z","comments":true,"path":"2020/06/30/十大经典排序算法C-实现及总结/","link":"","permalink":"http://tacoyu23.github.io/2020/06/30/%E5%8D%81%E5%A4%A7%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95C-%E5%AE%9E%E7%8E%B0%E5%8F%8A%E6%80%BB%E7%BB%93/","excerpt":"","text":"算法性能总结 1、冒泡排序 123456789101112131415161718//1、Bubble Sort 冒泡排序void bubbleSort(int a[], int length)&#123; if (length &lt; 2) return; for (int i = 0; i &lt; length - 1; i++) //需length-1趟排序确定后length-1个数，剩下第一个数不用排序； &#123; for (int j = 0; j &lt; length - 1 - i; j++) &#123; if (a[j + 1] &lt; a[j]) &#123; int temp = a[j + 1]; a[j + 1] = a[j]; a[j] = temp; &#125; &#125; &#125;&#125; 2、选择排序 123456789101112131415161718//2、Select Sort 选择排序void selectSort(int a[], int length)&#123; if (length &lt; 2) return; for (int i = 0; i &lt; length; i++) &#123; int minIndex = i; for (int j = i + 1; j &lt; length; j++) //已确定a[0]~a[i-1],从i-1开始查找最小的数，然后与a[i]交换位置； &#123; if (a[j] &lt; a[minIndex]) minIndex = j; &#125; int temp = a[i]; a[i] = a[minIndex]; a[minIndex] = temp; &#125;&#125; 3、插入排序 1234567891011121314151617//3、Insert Sort 插入排序void insertSort(int a[], int length)&#123; if (length &lt; 2) return; for (int i = 1; i &lt; length; i++) //现在进行插入的是a[i] &#123; int cur = a[i]; int j = i; while (j &gt; 0 &amp;&amp; a[j - 1] &gt; cur) //如果前面的数比cur大，说明cur要插在它们前面，即将它们后移一个位置； &#123; a[j] = a[j - 1]; j--; &#125; a[j] = cur; &#125;&#125; 4、希尔排序 12345678910111213141516171819202122//4、Shell Sort 希尔排序void shellSort(int a[], int length)&#123; if (length &lt; 2) return; int gap = length / 2; //整个数组分为gap个组，即每隔 gap-1 个位置的元素为一组 while (gap &gt; 0) //最终整个数组分为一组 即所有元素为一组； &#123; for (int i = gap; i &lt; length; i++) &#123; int cur = a[i]; int preIndex = i - gap; while (preIndex &gt;= 0 &amp;&amp; a[preIndex] &gt; cur) //对每一组元素进行插入排序 &#123; a[i] = a[preIndex]; preIndex -= gap; &#125; a[preIndex + gap] = cur; &#125; gap /= 2; &#125;&#125; 5、归并排序 123456789101112131415161718192021222324252627282930313233343536373839404142434445//5、Merge Sort 归并排序void merge(int a[], int left, int mid, int right);void mergeSort(int a[], int left, int right) // left需要排序数组 a[] 的左端下标，right为右端下标&#123; int length = right - left + 1; if (length &lt; 2) return; int mid = (right + left) / 2; mergeSort(a, 0, mid); mergeSort(a, mid + 1, right); merge(a, left, mid, right); //调用merge函数 将二者合并&#125;void merge(int a[], int left, int mid, int right) //将数组a 的两个子数组a[left] ~ a[mid] 与 a[mid+1] ~ a[right] 合并&#123; int len = right - left + 1; vector&lt;int&gt; temp; int i = left, j = mid + 1; for (; i &lt;= mid &amp;&amp; j &lt;= right;) &#123; if (a[i] &lt; a[j]) &#123; temp.push_back(a[i]); i++; &#125; else &#123; temp.push_back(a[j]); j++; &#125; &#125; while (i &lt;= mid) temp.push_back(a[i++]); //此时必有一个子数组没有走完 需要把剩下的元素全部放进vector while (j &lt;= right) temp.push_back(a[j++]); for (int i = left, k = 0; i &lt;= right; i++) //把vector中已排完序的元素存入数组a[left]~a[right] &#123; a[i] = temp[k++]; &#125;&#125; 6、快速排序 12345678910111213141516171819202122232425//6、Quick Sort 快速排序void quickSort(int a[], int left, int right)&#123; if (left &gt;= right) return; int key = a[left]; //以第一个数为基数进行快排； int pointL = left, pointR = right; while (pointL &lt; pointR) &#123; //一定要先动右指针，否则右指针所指向的元素无处存放 while (pointR &gt; pointL &amp;&amp; a[pointR] &gt;= key) //若右指针指向的元素大于key 则右指针左移，直到右指针指向的元素小于key 或者 左右指针坐标相同 pointR--; a[pointL] = a[pointR]; //把这个小于key的元素放到key的左边，即左指针指向的位置 while (pointR &gt; pointL &amp;&amp; a[pointL] &lt;= key) //若左指针指向的元素小于key 则左指针右移，直到左指针指向的元素大于key 或者 左右指针坐标相同 pointL++; a[pointR] = a[pointL]; //把这个大于key的元素放到key的右边，即右指针指向的位置 &#125; a[pointR] = key; //此时左右指针指向同一位置，这个位置就是key应该放的位置 //对key两边的元素同样使用快排 quickSort(a, left, pointR - 1); quickSort(a, pointR + 1, right);&#125; 7、计数排序 12345678910111213141516171819202122232425262728293031323334//7、Counting Sort 计数排序void countingSort(int a[], int length)&#123; if (length &lt; 2) return; int min = a[0], max = a[0]; int bios; //偏移量 for (int i = 0; i &lt; length; i++) //找最大最小值 &#123; if (a[i] &lt; min) min = a[i]; if (a[i] &gt; max) max = a[i]; &#125; bios = 0 - min; vector&lt;int&gt; temp(max - min + 1, 0); for (int i = 0; i &lt; length; i++) //把出现了的元素作为temp的下标 并置1； &#123; temp[a[i] + bios]++; &#125; int index = 0; for (int i = 0; i &lt; max - min + 1; i++) //顺序扫描以便vector即可 &#123; while (temp[i]) &#123; a[index++] = i - bios; temp[i]--; &#125; &#125;&#125; 8、桶排序 12345678910111213141516171819202122232425262728293031323334353637383940414243//8、Bucket Sort 桶排序void bucketSort(int a[], int length)&#123; if (length &lt; 2) return; int min = a[0], max = a[0]; for (int i = 0; i &lt; length; i++) &#123; if (a[i] &lt; min) min = a[i]; if (a[i] &gt; max) max = a[i]; &#125; int buckNum = (max - min) / length + 1; //桶的数量 vector&lt;vector&lt;int&gt;&gt; bucketArr; for (int i = 0; i &lt; buckNum; i++) &#123; vector&lt;int&gt; temp; bucketArr.push_back(temp); &#125; //每个元素入桶 for (int i = 0; i &lt; length; i++) &#123; int num = (a[i] - min) / length; bucketArr[num].push_back(a[i]); &#125; //对每个桶排序 并且排序完后赋值 int index = 0; for (int i = 0; i &lt; bucketArr.size(); i++) &#123; if (bucketArr[i].size()) &#123; sort(bucketArr[i].begin(), bucketArr[i].end()); //快排 for (int j = 0; j &lt; bucketArr[i].size(); j++) &#123; a[index++] = bucketArr[i][j]; &#125; &#125; &#125;&#125; 9、基数排序 123456789101112131415161718192021222324252627282930313233343536373839//9、Base Sort 基数排序void baseSort(int a[], int length) &#123; //得到最大位数； int max = a[0]; int d = 0;//最大位数 for (int i = 0; i &lt; length; i++) &#123; if (a[i] &gt; max) max = a[i]; &#125; while (max) &#123; max /= 10; d++; &#125; int factor = 1; for (int i = 1; i &lt;= d; i++) //从个位数排到d位数 &#123; vector&lt;int&gt; bucket[10]; //初始化十个桶 for (int i = 0; i &lt; length; i++) &#123; int temp = (a[i] / factor) % 10; //得到a[i]的now_d位数，并放入对应桶中 bucket[temp].push_back(a[i]); &#125; int j = 0; for (int i = 0; i &lt; 10; i++) //遍历十个桶，按从小到大顺序放入原数组 &#123; int size = bucket[i].size(); for (int k = 0; k &lt; size; k++) &#123; a[j++] = bucket[i][k]; &#125; bucket[i].clear(); //桶置空 &#125; factor *= 10; &#125;&#125; 10、堆排序 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748//10、Heap Sort 堆排序 大顶堆做出来顺序，小顶堆做出来逆序void fixDown(int a[], int i, int length);void swap(int a[], int i, int j);void heapSort(int a[], int length)&#123; //先对 a 堆化 for (int i = length / 2 - 1; i &gt;= 0; i--) &#123; fixDown(a, i, length); //把i当前小顶堆的根节点 &#125; // 完成后 此时a已经是合法的小顶堆 //调整堆结构 for (int x = length - 1; x &gt; 0; x--) &#123; //把堆顶元素(0号元素)和末尾元素对调； swap(a, 0, x); //缩小堆的范围，对堆顶元素进行向下调整； fixDown(a, 0, x); &#125;&#125;void fixDown(int a[], int i, int length)&#123; //找到左右子孩子 int left = 2 * i + 1; int right = 2 * i + 2; int min = left; //min指向左右孩子中较小的那个 if (left &gt;= length) //若左孩子越界则右孩子必越界 return; if (right &lt; length &amp;&amp; a[right] &lt; a[left]) //右孩子未越界并且右孩子值比左孩子小 min = right; //如果a[i]比这两个孩子的值都要小，则不用调整； if (a[i] &lt; a[min]) return; //否则，其值和a[i]交换； swap(a, i, min); //小孩子那个位置的值发生变化，i变更为小孩子的那个位置，于是递归调整； fixDown(a, min, length);&#125;void swap(int a[], int i, int j)&#123; int temp = a[i]; a[i] = a[j]; a[j] = temp;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;//1、Bubble Sort 冒泡排序void bubbleSort(int a[], int length);//2、Select Sort 选择排序void selectSort(int a[], int length);//3、Insert Sort 插入排序void insertSort(int a[], int length);//4、Shell Sort 希尔排序void shellSort(int a[], int length);//5、Merge Sort 归并排序void merge(int a[], int left, int mid, int right);void mergeSort(int a[], int left, int right) ;//6、Quick Sort 快速排序void quickSort(int a[], int left, int right);//7、Counting Sort 计数排序void countingSort(int a[], int length);//8、Bucket Sort 桶排序void bucketSort(int a[], int length);//9、Base Sort 基数排序void baseSort(int a[], int length);//10、Heap Sort 堆排序 大顶堆做出来顺序，小顶堆做出来逆序void fixDown(int a[], int i, int length);void swap(int a[], int i, int j);void heapSort(int a[], int length)int main()&#123; int a[8] = &#123;3, 1, 5, 4, 5, 8, 7, 10&#125;; // bubbleSort(a, 8); // selectSort(a,8); // insertSort(a, 8); // shellSort(a, 8); // mergeSort(a, 0, 7); // quickSort(a, 0, 7); // countingSort(a, 8); // bucketSort(a, 8); // baseSort(a, 8); heapSort(a, 8); for (int i = 0; i &lt; 8; i++) cout &lt;&lt; a[i] &lt;&lt; ' '; return 0;&#125; 如有错误，欢迎评论指正，谢谢！","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://tacoyu23.github.io/categories/Algorithm/"}],"tags":[{"name":"Sort","slug":"Sort","permalink":"http://tacoyu23.github.io/tags/Sort/"}]},{"title":"多维数组和矩阵","slug":"多维数组和矩阵","date":"2020-06-30T05:56:53.000Z","updated":"2020-06-30T05:57:59.381Z","comments":true,"path":"2020/06/30/多维数组和矩阵/","link":"","permalink":"http://tacoyu23.github.io/2020/06/30/%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84%E5%92%8C%E7%9F%A9%E9%98%B5/","excerpt":"","text":"T 1：顺时针打印二维数组这个问题看起来很容易，逻辑清晰，但实现起来还是复杂些，要考虑到不能重复打印，超出边界； 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;void printMatrix(vector&lt;vector&lt;int&gt;&gt; a)&#123; int leftuprow = 0, leftupcol = 0, rightdownrow = a.size()-1, rightdowncol = a[0].size()-1; while (leftuprow &lt;= rightdownrow &amp;&amp; leftupcol &lt;= rightdowncol) &#123; int r = leftuprow; int c = leftupcol; while (c &lt;=rightdowncol) &#123; cout &lt;&lt; a[r][c++]&lt;&lt;\" \"; &#125; c = rightdowncol; r = leftuprow+1; while (r &lt;= rightdownrow) &#123; cout &lt;&lt; a[r++][c] &lt;&lt; \" \"; &#125; r = rightdownrow; c = rightdowncol - 1; while (c &gt;= leftupcol) &#123; cout &lt;&lt; a[r][c--]&lt;&lt;\" \"; &#125; c = leftupcol; r = rightdownrow - 1; while (r &gt; leftuprow) &#123; cout &lt;&lt; a[r--][c] &lt;&lt; \" \"; &#125; leftupcol++; leftuprow++; rightdowncol--; rightdownrow--; &#125;&#125;int main()&#123; vector&lt;vector&lt;int&gt;&gt; test; for(int i=1;i&lt;=12;i++) &#123; vector&lt;int&gt; temp; while (i%4) &#123; temp.push_back(i++); &#125; temp.push_back(i); test.push_back(temp); &#125; printMatrix(test); return 0;&#125; T 2：将0所在的行列清零 如果矩阵中某个元素为0，则将其所在行和列清零； 可能会想到，我一边遍历矩阵，遇到0就将它所在行列全部清0； 但这样存在一个问题：如果某一行有多个0，遇到第一个0，会将本行和该列清0，那么循环遍历下去，这一行剩下的都是0，会将这些本不该清0的列都清0； 思路：把每个值为0的位置标记，最后统一对它们所在的行和列清0； 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;void setZero(vector&lt;vector&lt;int&gt;&gt; &amp;a)&#123; vector&lt;vector&lt;int&gt;&gt; result; int lenRow=a.size(),lenCol=a[0].size(); for(int i=0;i&lt;lenRow;i++) &#123; for(int j=0;j&lt;lenCol;j++) &#123; if(a[i][j]==0) &#123; vector&lt;int&gt; temp; temp.push_back(i); temp.push_back(j); result.push_back(temp); &#125; &#125; &#125; for(auto r:result) &#123; int row=r[0],col=r[1]; for(int i=0;i&lt;lenCol;i++) &#123; a[i][col]=0; &#125; for(int i=0;i&lt;lenRow;i++) &#123; a[row][i]=0; &#125; &#125;&#125;int main()&#123; vector&lt;vector&lt;int&gt;&gt; test; for(int i=1;i&lt;=16;i++) &#123; vector&lt;int&gt; temp; while (i%4) &#123; temp.push_back(i++); &#125; temp.push_back(i); test.push_back(temp); &#125; test[1][2]=0; test[2][1]=0; setZero(test); for(auto a:test) &#123; for(auto aa:a) &#123; cout&lt;&lt;aa&lt;&lt;' '; &#125; cout&lt;&lt;endl; &#125; return 0;&#125; T 3：Z字形打印 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253void Z(vector&lt;vector&lt;int&gt;&gt; &amp;a)&#123; int r = 0, m = a.size();//m=最大行数 int c = 0, n = a[0].size();//n=最大列数 bool dir = true; //控制方向，true为向上，false为向下 while (r &lt; m &amp;&amp; c &lt; n) &#123; //从左下到右上，走上坡 if (dir) &#123; cout &lt;&lt; a[r][c] &lt;&lt; ' '; if (r == 0 &amp;&amp; c &lt; n - 1) //到第一行，但未到列边界，只能往右走 &#123; dir = !dir; c++; continue; &#125; else if (r &lt; m - 1 &amp;&amp; c == n - 1) //到最后一列，未到最后一行，只能向下走 &#123; dir = !dir; r++; continue; &#125; else &#123; r--; c++; &#125; &#125; else //相反，走下坡 &#123; cout &lt;&lt; a[r][c] &lt;&lt; ' '; if (c == 0 &amp;&amp; r &lt; m - 1) //到第一列，未到最后一行，只能往下走 &#123; dir = !dir; r++; continue; &#125; else if (r == m - 1 &amp;&amp; c &lt; n - 1) //到最后一行，未到最后一列，只能向右走 &#123; dir = !dir; c++; continue; &#125; else &#123; r++; c--; &#125; &#125; &#125;&#125; T 4：子数组的最大累加和给定一个数组，返回子数组的最大累加和； 如 a = {1,-2,3,5,-2,6,-1};所有的子数组中[3,5,-2,6]可以累加出最大的和12； 思路：若累加到当前数的和sum为负，那么比较sum和max，若sum比max大，则更新max，并中断此次累加操作（因为无论下个数next是正是负，sum+next都比next小），从下一个数开始累加； 若加到当前数的和sum为正，则继续累加下去，每次累加比较和max的大小； 12345678910111213141516171819int maxSubArray(vector&lt;int&gt; &amp;nums)&#123; int len = nums.size(); if (len == 0) return 0; int sum = 0, maxSum = nums[0]; for (int i = 0; i &lt; len; i++) &#123; sum += nums[i]; if (sum &gt; maxSum) maxSum = sum; if (sum &lt; 0) &#123; sum = 0; &#125; &#125; return maxSum;&#125; 详情见Leetcode第53题：最大子序和； T 5：矩阵的乘法 1234567891011121314151617181920212223vector&lt;vector&lt;int&gt;&gt; mutMatrix(vector&lt;vector&lt;int&gt;&gt; m1, vector&lt;vector&lt;int&gt;&gt; m2)&#123; int n = m1.size(); //矩阵1的行数 int m = m1[0].size(); //矩阵1的列数,矩阵2的行数肯定和矩阵1的列数相同 int p = m2[0].size(); //矩阵2的列数 vector&lt;vector&lt;int&gt;&gt; result; for (int i = 0; i &lt; n; i++) &#123; vector&lt;int&gt; temp; for (int j = 0; j &lt; p; j++) &#123; int sum = 0; for (int k = 0; k &lt; m; k++) &#123; sum += m1[i][k] * m2[k][j]; &#125; temp.push_back(sum); &#125; result.push_back(temp); &#125; return result;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://tacoyu23.github.io/categories/Algorithm/"}],"tags":[{"name":"数组","slug":"数组","permalink":"http://tacoyu23.github.io/tags/%E6%95%B0%E7%BB%84/"}]},{"title":"递归","slug":"递归","date":"2020-06-30T05:54:39.000Z","updated":"2020-06-30T05:57:01.447Z","comments":true,"path":"2020/06/30/递归/","link":"","permalink":"http://tacoyu23.github.io/2020/06/30/%E9%80%92%E5%BD%92/","excerpt":"","text":"递归思路1、找重复：找出子问题 2、找变化：变化的量应该作为参数； 3、找边界：设计函数的出口； T 1：求阶乘输入n，使用递归的方法输出n！ 123456int Rec(int n)&#123; if(n==1) return 1; return n*Rec(n-1);&#125; T 2：求数组元素和对arr的所有元素求和 123456int Rec(vector&lt;int&gt; arr,int begin)&#123; if (begin == arr.size() - 1) return arr[begin]; return arr[begin] + Rec(arr,begin + 1);&#125; T 3：斐波那契数列f(0)=1 f(1)=1 f(2)=f(0)+f(1)=2 f(3)=f(1)+f(2)=3 f(n)=f(n-2)+f(n-1) 输入n，求f(n) 123456int Feb(int n)&#123; if(n==0 || n==1) return 1; return Feb(n-2)+Feb(n-1); &#125; T 4：最大公约数输入m，n，求它俩的最大公约数(m&gt;n) 123456int Rec(int m,int n)&#123; if(n==0) return n; return Rec(n,m%n)&#125; T 5：插入排序改递归使用递归的方法对数组arr进行排序； 12345678910111213141516void insertSort(vector&lt;int&gt; &amp;arr, int pos)//对arr[0]-arr[pos]进行排序&#123; if (pos == 0) return; insertSort(arr, pos - 1);//等pos前面的元素都排序完了，我再对pos元素进行排序； int p = pos; int val = arr[p]; while (p &gt; 0 &amp;&amp; val &lt; arr[p - 1])//只要比前面的元素小，就继续向前找位置 &#123; arr[p] = arr[p - 1]; p--; &#125; //此时arr[p]&gt;arr[p-1]，在此位置插入； arr[p] = val;&#125; T 6：汉诺塔问题 A B C三处，将A处的n个盘子移动到C处，每次只能移动1个盘子，下盘子只能放在大盘子上面； 1、找重复：把n块盘子从A移动到C，那么我只需叫人通过中介C帮我把n-1个盘子移动到B处，然后我把第n个盘子移动到C处，再叫别人把B处的n-1个盘子通过中介A挪到C处； 2、找变化：移动过程中，初始地、中介、目的地以及目前移动的哪块盘子都不一样，这些都是变化量； 3、找边界：如果n==0时，不存在第0块盘子，所以此时什么都不用做，返回即可； 12345678910111213void Hanuo(int n, char begin, char help, char dest)&#123; if (n &lt; 1) return; Hanuo(n - 1, begin, dest, help); cout &lt;&lt; \"move \" &lt;&lt; n &lt;&lt; \" from \" &lt;&lt; begin &lt;&lt; \" to \" &lt;&lt; dest &lt;&lt; endl; Hanuo(n - 1, help, begin, dest);&#125;int main()&#123; Hanuo(3, 'A', 'B', 'C'); return 0;&#125; T 7：二分查找的递归算法对于有序数组arr，输入key，使用递归形式的二分查找方法查找key所对应的索引； 1234567891011121314151617int BinarySearch(vector&lt;int&gt; arr, int left, int right, int key)&#123; if(left &gt; right) //此时表示在数组arr中找不到该key值 return -1; //二分查找 int mid = left + (right - left) / 2; if (arr[mid] == key) return mid; else if (arr[mid] &lt; key) &#123; return BinarySearch(arr, mid + 1, right, key); &#125; else &#123; return BinarySearch(arr, left, mid - 1, key); &#125;&#125; 递归性能递归的时间复杂度取决于子问题的分支数； 比如求阶乘的时间复杂度为O(n)，而斐波那契时间复杂度大约为O(2^n^); 因为分支数越多意味着有更多的冗余运算，即多做了很多次重复的计算，这是就需要动态规划或者非递归的迭代形式来降低复杂度； 由于递归重复调用当前函数，函数主要使用栈空间，所以递归的空间复杂度也较高； 但递归有个最大的好处就是：==容易理解==； 总结==递归就是偷懒==： ​ 我解决问题的一个部分，剩下的交给别人处理；或者理解为一个蛋糕，我只切一小块，剩下的怎么分交给别人完成；","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://tacoyu23.github.io/categories/Algorithm/"}],"tags":[{"name":"递归","slug":"递归","permalink":"http://tacoyu23.github.io/tags/%E9%80%92%E5%BD%92/"}]},{"title":"心理学-影响力","slug":"心理学-影响力","date":"2020-06-30T02:26:01.000Z","updated":"2020-06-30T02:27:43.324Z","comments":true,"path":"2020/06/30/心理学-影响力/","link":"","permalink":"http://tacoyu23.github.io/2020/06/30/%E5%BF%83%E7%90%86%E5%AD%A6-%E5%BD%B1%E5%93%8D%E5%8A%9B/","excerpt":"","text":"1. 作者介绍本书《影响力》作者：罗伯特·西奥迪尼(Robert B．Cialdirli)，”影响力教父”，著名社会心理学家； 点评鉴赏：1、西奥迪尼在影响力方面对我的影响，其他任何科学家都比不上……这本最佳畅销书呈现了六至八种方法，让你精灵古怪的想法不会再阻碍你获得最佳利益。——查理·芒格巴菲特的黄金搭档，伯克希尔·哈撒韦公司副总裁2、如果总统只能随时向—位顾问请教的话，我推荐当今世界最了不起的社会心理学家、影响力大师——西奥迪尼。——《助推》作者理查德·泰勒3、在谈判中，如果所有事情都僵持不下，除了西奥迪尼我再也想不到还有谁可以给我建议。——全球最著名的管理学大师之一，商界教皇汤姆·彼得斯4、西奥迪尼的书是我们在FBl遥遥领先的基础，他的书使职业谈判专员成长为危机干预者。我们借鉴了西奥迪尼书里的很多内容。我们观察人们是怎样对别人施加影响的，发现影响是通过建立关系，赢得信任，并对别人的问题和关心的事情真正感兴趣而获得的。——FBI谈判专员，作家加里·内斯纳5、西奥迪尼《影响力》—书中的素材宛如一座金矿。——《社会与临床心理学杂志》6、如果你的时间只够看一本书，那就看《影响力》吧。——《全新销售》作者丹尼尔·平克7、西奥迪尼是社会心理学的真正先驱之一。——哈佛大学心理学教授，《撞上快乐》作者丹尼尔·吉尔伯特8、对从事市场营销的人员来说，本书是过去十年中最重要的著作之一。——《市场营销研究杂志》 2. 影响力的武器当某一个触发特征出现时，我们会不假思索地作出相应的反应，之所以会这样，就是因为我们被难以察觉的影响力武器摆布了； Q：为什么无人问津的东西，价格翻倍后，反而被一抢而空？ 哈佛心理学家埃伦·兰格得出结论：我们在需要别人帮忙的时候，要是能给一个理由，成功的概率会更大； 这里亦是如此，对于稍微富裕的人，他们用一套标准准则来指导自己买东西：一分钱一分货，价格贵等于东西好，才有买的必要；再加上他们对这个东西的了解甚少时，他们自然而然会用上价格这个一贯的准绳；即价格本身成为了质量的触发特征；而就算提价效果不佳，卖家仍可以按标价打折，面对虚高的标价，消费者仍然会产生“贵=好”的反应； Q：为什么房地产商在售楼时，先带顾客去看没人会买的破房子？ 知觉对比心理：如果两个东西本来就有很大不同，然后一前一后地展示出来，我们往往会认为两者的区别 比实际上更大；就像售货员往往先展示昂贵地物件； 先看标上虚高价的破房子，再带顾客看真正想卖的地方，正是利用对比心理； Q：为什么汽车经销商在顾客掏钱买车后才会建议顾客买各种配件？同样运用对比心理，几万元的生意要成交了，再花一些几百元升级以下配件似乎微不足道；即使这些价格单个看上去没多少，合在一起，整个车的价格就好像注水猪肉一般涨上去了； 3. 互惠 互惠原理认为，我们应该尽量以类似的方式报答他人为我们所做的一切； 每一笔债都还的干干净净，就好像上帝他老人家是债主； ——爱默生 正是因为有了互惠体系，人类才成为人类，祖先在“有债必还得信誉网”里分享食物和技巧，我们才成为人；——理查德·利基 不对等交换：互惠原理可触发不对等交换，因为亏欠感让人觉得很不舒服，然后违背互惠原理，接受而不试图回报他人善举的人，是不受社会群体欢迎的，谁也不愿意被贴上“忘恩负义”的标签； 互惠式让步：互惠原理通过两种途径来实现互惠让步，第一条：它迫使接受了对方让步的人以同样的方式回应；第二条尽管不明显，但很关键：由于接受了让步的人有回报的义务，任务就乐意率先让步，从而启动有益的交换过程； 拒绝-后撤术：你想让我答应你的请求，你可以先向我提一个更大的要求，这样的要求我肯定是拒绝的，等我拒绝后你再提一个稍小的要求，这个要求才是你真正的目标；若这样布置，我会把第二个要求当作你对我的让步，并可能感觉到我也应该让步，从而答应你的要求；这同样也运用了先大后小的知觉对比原理； 实验证明，拒绝-后撤手法似乎不仅刺激人们答应请求，还鼓励他们切身实践承诺，甚至叫他们自愿履行进一步的要求； 如何拒绝？倘若别人的提议我们确实赞同，那就不妨接受它；倘若这一提议别有用途，那我们就置之不理；互惠原理告诉你：别人怎么对你，你就有权怎么对他； Q：为什么精明的政客会让连普通人都能看出来的愚蠢的”水门事件”发生？水门事件的策划人是戈登·利迪，他一开始提的是100万美元 + 窃听器 +跟踪飞机 +绑架小分队 +游艇；这必然不会被其他人通过；随后他削减方案，降至50万美元，也被否定；最终米切尔等人同意了利迪的第三次提议：25万美元；在水门事件被曝光后，不难发掘互惠式让步的力量有多大； Q：为什么超时总喜欢提供”免费试用”？免费试用目的一是让公众知道自己产品的质量，二是它同时也是一份礼物，与互惠原理应用起来；这样就有一部分人购买了一些产品，哪怕并不是十分喜欢； 4.承诺和一致 承诺和一致原理认为，一旦做出了一个选择或采取了某种立场，我们就会立刻碰到来自内心和外部的压力，迫使我们的言行与它保持一致。在这种压力下，我们会想方设法地以行动证明自己先前地决定是正确的； 一开始就拒绝，比最后反悔要容易——达·芬奇 一旦做出艰难的选择，人就很乐意相信自己选择对了；事实上，我们所有人都会一次次地欺骗自己，并且愿意做出进一步的承诺，以便坚信自己做的没错， 在接受琐碎请求时务必小心谨慎，因为一旦同意了，他就可能影响我们的自我认知。它不仅能提高我们对分量更大的类似请求的顺从度，还能使我们更乐意去做一些跟先前答应的小要求毫不相关的事情； 书面声明能有效地真正改变人，原因之一在于他们很容易公之于众；公开承诺往往具有持久的效力； 每当一个人当众选择了一种立场，她便会产生维护它的动机，因为这样才能显得前后一致；前后一致是一种很好的为人特点，不具备这一特点的人会被视为浮躁、多变、优柔寡断等；而具备这一特点的人，则显得理性、自信、可靠、值得依赖； 为一个承诺符出的努力越多，它对承诺者的影响也就越大； 费尽周折才得到某样东西的人，比轻轻松松就得到的人，对这件东西往往更为珍视； 只有当我们认为外界不存在强大的压力时，我们才会为自己的行为发自内心地负起责任； 死脑筋地保持一致愚不可及，而不是保持一致愚不可及； 我们在生活中不可能完全摆脱它，如果我们一致纠结于做某件事的坏处，那就做不了什么事了； Q：为什么大公司常发起一些有奖征文比赛，参赛者无须购买该公司任何产品，却有机会获得大奖？征文比赛的目的是让尽量多的人写下对一种产品的表白；参赛者知道，要想胜出，就必须称赞相关的产品；于是，他们开始寻找该产品值得称道的地方，并在文章中加以描述；随之而来的结果是，成千上万的人以书面形式证明了该产品具有这样那样的优点，在书面文字的神奇推动下，他们就真的相信了自己所写的东西； Q：为什么一些二手车经销商在收购旧车，以旧换新时会故意高估旧车的价格？ 抛低球：先给人一个甜头，诱使人做出有力的购买决定，而后，等决定做好了，交易还没最终拍板，卖方巧妙地取消了最初的甜头； 此处二手经销商故意抬高旧车价格，客户觉得这笔交易太划算，立刻就想成交；之后等快签合同地时候，销售员说之前对旧车的股价高了400美元，并把换购补贴降至正常水平。客户知道扣了钱之后的交易仍是公平的，也就接受了； 5.社会认同 社会认同原理认为，在判断何为正确时，我们会根据别人的意见行事，尤其是当我们在特定情形下判断某一行为是否正确时。如果看到别人在某种场合做某件事，我们就会断定这样做是有道理的； 在人人想法都差不多的地方，没人会想得太多；——沃尔特·李普曼 社会认同原理指出：在判断何为正确时，我们会根据别人的意见行事； 问题在于：我们对社会认同的反应方式完全是无意识的、条件反射式的，这样一来，偏颇甚至伪造的证据也能愚弄我们； 卡维特·罗伯特：95%的人都爱模仿别人，只有5%的人能首先发起行动，所以，要想把人说服，我们提供任何证据的效果都比不上别人的行动； 一般来说，我们在自己不确定、情况不明或含糊不清、意外性太大的时候，我们最有可能觉得别人的行为是正确的； 1234对于社会认同的响应方式，我们有了进一步认识： 首先，我们似乎持有这样的假设，要是很多人在做同样的事情，他们必然知道一些我们不知道的事情。 尤其是在我们并不确定的时候，我们很乐意对这种集体智慧投入极大的信任。 其次，人群很多时候都是错的，因为群体的成员并不是根据优势信息才采取行动，而只是基于社会认同原理在做反应； Q：为什么现场有大量其他旁观者在场时，旁观者对紧急情况伸出援手的可能性最低？原因之一：周围有其他可以帮忙的人，单个人要承担的责任就减少了；人人都会想着会有别人帮忙，结果人人都没帮忙；原因之二：很多时候，紧急情况咋看起来并不显得十分紧急，碰到这种不确定的情况，人很自然地根据周围其他人的行动来判断，我们往往根据其他目击者的反应方式，得知事情到底够不够紧急； 多元无知状态：每个人都得做出判断：既然没人在乎，那就应该没什么问题。与此同时，危险也有可能累计到这样一个程度：某一个体不受看似平静的其他人所影响，采取了行动；多元无知效应似乎在陌生人里显得最为突出，因为我们喜欢在公众面前表现得优雅而成熟，又因为我们不熟悉陌生人的反应，所以，置身于一群素不相识的人里面，我们有可能无法流露出关切地表情，也无法正确地解读他人关切的表情； 旁观者群体没能帮忙，不是因为他们无情，而是因为他们不能确定；Q：在遇到紧急情况时，什么才是最有效的求救方式？在人群中找出一个人来，盯着他，直接指着说：你，穿蓝夹克的那位先生，我需要帮助，请叫救护车过来；这样一句话消除了一切有可能阻碍或拖延救助的不确定性，你把那位先生放在了“救助者”的位置上，他现在应该明白，紧急救助是必要的；他应该负起责；因此，一般而言，在需要紧急救助时，你的最佳策略就是减少不确定性，让周围人注意到你的状况，搞清楚自己的责任；不要让旁观者自己判断； Q：为什么自杀事件广为报道时，报道所覆盖地区的自杀事件反而增多？ 相似性：我们在观察与我们相似的人的行为时，社会认同理论会发挥出最大的影响力；社会认同原理的病态例证：一些人根据其他陷入困境的人如何行动来决定自己该怎么做； 轰动的自杀新闻之所以会引发事故热潮，原因其实就是：模仿自杀(维特效应)；我们根据他人的行为来判断自己怎么做才合适，尤其是在我们觉得这些人跟自己相似的时候； 要是自杀新闻后增多的事故真的意味着有人在蓄意模仿，那么这些跟风模仿者最可能效仿的是跟自己类似的人；事实证明：在自杀事件上头条新闻之后的一段时间改变出行方式，能提高生存概率； Q：为什么圭亚那琼斯敦的910名教徒会集体自杀？人们在不确定的时候，会根据他人的行动来指导自己的行动；不确定性是社会认同原理的左膀右臂；影响力最强的领导者是那些知道怎么安排群体内部条件，让社会认同原理朝对自己有利方向发挥作用的人；显然这里的领导者就是这些教徒之首，琼斯； 如何拒绝？面对明显是伪造的社会证据，我们只要多保持一点警惕感，就能很好地保护自己了； 6.喜好一个人的某个正面特征就能主导其他人看待此人的眼光；请求者还有另一种利用相似点增加好感及顺从概率的办法：他们假装跟我们有着相似的背景和兴趣； 虽然接触带来的熟悉往往能导致更大的好感，可要是接触本身蕴含了让人反感的体验，就会适得其反；证据表明，以团队为导向的学习能缓解敌对状态； 条件反射和关联：制造商们总是急着把自己的产品跟当前的文化热潮联系起来；把名人和产品联系在一起，是广告商利用关联原理赚钱的另一种方法； 根据关联原理，倘若我们能用一些哪怕非常表面的方式让自己跟成功联系起来，我们的公共形象也会显得光辉起来；我们展示积极的联系，隐藏消极的联系，努力让旁观者觉得我们更高大，更值得喜欢； Q：在审讯嫌疑犯时，为什么“好警察+坏警察”搭档的方法能够奏效？靠着坏警察的威胁，嫌犯心理很快充满了对长期监禁的恐惧情绪；知觉对比原理也发挥了作用，相较于满嘴胡言乱语的坏警察，好警察显得是非常讲道理的好人，且屡次帮嫌犯说话，互惠原理让嫌犯感到压力；这种刑讯手法见效的主要原因在于，它让犯人感觉有人站在自己这一边，有人为自己着想，也会更加容易向他坦白； 如何拒绝？我们有必要当心对顺从专业人士的过度好感，意识到这种好感，能提醒我们把交易者和交易分开，只根据生意本身的好坏做决定 7.权威每当面对人类行为背后的一种强力推动因素，我们都会很自然地想到，这种推动因素地村仔是有着充分理由的；就服从权威一例而言，稍微思考下人类社会地组织方式，我们就能找到很多说得过去的解释；被人类普遍接受的多层次权威体制能赋予社会巨大的优势，有了它，适于资源生产、贸易、国防、扩张和社会控制的成熟社会结构才得以发展； 一旦我们意识到服从权威在大对数情况下是有好处的，就很容易不假思索地服从； 在没有真正权威的情况下，有几种象征权威的符号能十分有效地触发我们的顺从态度——头衔、衣着和身份标志头衔比当事人的本质更能影响他人的行为；权力和权威的外部特征，说不定是靠假冒伪劣的材料编造出来的 Q：为什么受过正规培训的护理人员会毫不犹豫地执行来自医生地明明漏洞百出的提示？很多情况下，只要有正统地权威说了话，其他本来应该考虑地事情就变得不相关了；这种时候，我们并不从整体上来审视局面，而是只对其中的一个方面给予关注，作出反应； 8.稀缺 不管是什么东西，只要你晓得会失去它，自然就会爱上它了；——GK切斯特顿 对失去某种东西的恐惧似乎比对获得同一物品的渴望，更能激发人们的行动力； 基本可以根据一样东西的难易程度，迅速、准确地判断它的质量； 机会越来越少的话，我们的自由也会随之丧失； Q：为什么面值一元的错版纸币，其价值远远超出了面值的几百倍？倘若瑕疵把一样东西变得稀缺了，垃圾也能化成值钱的宝贝； Q：为什么在拍卖场里，人们会不由自主地举牌？渴望拥有一件众人争抢的东西，几乎是出于本能的身体反应；参与竞争稀缺资源的感觉，有着强大地刺激性； 如何拒绝？稀缺的东西并不因为难以弄到手，就变得更好吃、更好看、更好听、更好用了； 9. 尾声 贯穿本书的平行主题：尽管只靠孤立数据容易做出愚蠢的决定，可现代生活的节奏又要求我们频繁使用这一结局； 正常情况下，促使我们做出顺从决策的几个最常用的信息，都可以引导我们做出正确的决策，这就是为什么我们在决策时频繁、机械地使用互惠、承诺与一致、社会认同、喜好、权威以及稀缺原理的原因；每个原理本身都能极为可靠地提示我们，什么时候说”是“比说”不“更加有利；但现实中，大量的、极易伪造的信息被人利用，他们借此引诱我们做出机械的反应并从中获利，我们不得不防； 1234读后感： 一本很好的心理学书籍，用极易理解的几个维度概括出了我们为人处事所经历的或者即将经历的方方面面； 说实话，以前没看过心理学书籍，但很向往；这本书买了半年了，这是第一次简洁地将它看完，对其中的论点有所触动，句句都说到心理； 由于只是粗略的看了一遍，每个论点后仅细品了一个典型的例子，对于其他部分仍需要日后反复深究；","categories":[{"name":"课外读物","slug":"课外读物","permalink":"http://tacoyu23.github.io/categories/%E8%AF%BE%E5%A4%96%E8%AF%BB%E7%89%A9/"}],"tags":[{"name":"心理学","slug":"心理学","permalink":"http://tacoyu23.github.io/tags/%E5%BF%83%E7%90%86%E5%AD%A6/"}]},{"title":"PS技术大杂烩","slug":"PS技术大杂烩","date":"2020-06-30T02:22:17.000Z","updated":"2020-06-30T02:25:10.295Z","comments":true,"path":"2020/06/30/PS技术大杂烩/","link":"","permalink":"http://tacoyu23.github.io/2020/06/30/PS%E6%8A%80%E6%9C%AF%E5%A4%A7%E6%9D%82%E7%83%A9/","excerpt":"","text":"一、PS六个要点1、图层 2、形状3、选区选择的区域 4、画笔alt + 点击 ：取色到前景色； 5、文字6、钢笔创建圆滑的曲线 二、图像相关问题把竖图变横图图像变清晰(润滑)1、复制图层-&gt;滤镜-&gt;表面模糊-&gt;调透明度 2、复制图层-&gt;滤镜-&gt;其他-&gt;高反差保留(数值2-5之间)-&gt;混合模式选叠加 如何擦除图层A上图层B内容给图层B添加蒙版，在前景色黑色背景色白色的情况下是用画笔进行擦除 图像修复去水印不同的图片去水印的方法也不一样，关键看图片背景的纹理是不是太复杂； 复杂的话可能就要用仿制图章工具一点点弄，不复杂的话，直接修补工具去掉水印 1、背景不复杂的 修补工具选择要修补的区域 然后移动到纹理相似的区域即可完成修补 对于交界面的那个文字 修补时注意对齐 2、背景复杂的 用仿制图章一点点复制 去人物斑点 污点修复画笔工具 一个个点就行 消除图像中乱入的事物简单的直接选区，选择要消除的东西 然后填充 内容识别 内容感知工具：把区域A移到区域B，A的原区域部分会内容识别，移到B的A也会内容识别把A放到B那，如果有点瑕疵，再用别的工具处理； 图像合成P图、表情包制作等； 工具：套索 钢笔 + 图像混合； 把A的脸P到B的脸上 把这个图层复制到超越那里； 然后扣除原图对应区域，可以将区域进行一定的缩小 然后选择两个图层，编辑，自动混合图层，确定； 这种一般适合两个图片人物脸朝向相同，否则需要做出一些调整； 整个步骤为： 把完整的人P到另一个场景注意：姿势眼神、身体比例、光影颜色； 把图层复制过去后，调整好大小和位置，利用仿制图章、修补和选区自由变化、水平翻转等方法将周围背景进行修改，然后对色彩进行判断，看是否需要降低饱和度，是否需要加深颜色等等； 加阴影就是在图层上新建一个图层 然后调整画笔透明度和流量、硬度，进行刻画； 换头大法 把头和脖子扣下来，然后复制在图像2中，调整大小位置，对图像2背景利用图章等工具进行调整，然后给头，脖子添加阴影，方向键微调元素位置，然后用可选颜色调整肤色； 三、制作相关制作幻影复制多个该图层，调整好位置，依次调整透明度 用文字组成的图像特效 1、把图层填充为黑色； 2、选择文字框，复制一堆的英文；调整颜色为白色，调整字形，字体大小； 3、把图片粘贴进去，注意要在文字的上面，然后在图片图层上创建剪贴蒙版； 海报设计字体、层次、距离； 不要用一大堆乱七八糟的字体，会有凌乱的感觉； 海报的目的只是信息的传递，选三种以下的字体即可； 文字层次，决定信息的可读性；注意对齐； 人物与标题的排列方式 四、人物抠图相关问题抠图大法选择并遮住1、魔棒/快速/套索 选区/选择主题 2、选择并遮住 一般选择叠加模式，红色部分为非选择部分，调整下不透明度； ==半径==就是边缘的半径：越大则图像处理的边缘半径越大； 3、第二个神器工具：调整边缘画笔 对边缘细节拿这个笔刷 4、确定，添加图层蒙版，如果还需要修改细节部分，则选择==海绵工具==刷一下； ==海绵工具==就是去掉颜色的饱和度，或者直接选择头发，调整饱和度； 5、背景填充颜色； 人物磨皮/证件照/换背景 1、污点修复工具修复大块瑕疵； 2、磨皮滤镜工具Portraiture进行磨皮； 但是，磨皮后有些模糊，不清晰； 滤镜-&gt;其他-&gt;高反差保留-&gt;数值在2-5之间，确定-&gt;混合模式改成叠加； 发现图像清晰很多； 3、调整颜色 4、调整五官，用滤镜下的液化，有个人脸识别工具 5、换证件照背景 新建图层，背景色调为蓝色，然后填充； 各证件照大小： 新建-&gt;调整好证件照大小-&gt;分辨率300 颜色模式CMYK-&gt;创建； 给刚刚做完的图像盖印，然后复制过来，放缩，然后另存为； 人物精修 - 男 1、污点修复工具去除大斑点； 2、高低频； 先对低频处理： 在通道中找到对比度比较高的颜色图层-&gt;滤镜-&gt;其他-&gt;高反差保留-&gt;调到斑点刚刚好出现的数值即可； 图像-&gt;计算-&gt;混合模式-&gt;强光； 图像-&gt;计算-&gt;确定； 图像-&gt;计算-&gt;确定； 图像-&gt;计算-&gt;确定； 斑点越来越清楚； ctrl+点击 进行选区 选择二的是高光的部分，就是白色的部分； 反选； ctrl + M 把曲线拉高一点 这样就能把黑的斑点调亮； 滤镜-&gt; 模糊-&gt; 高斯模糊； 高频处理： 滤镜-&gt;高反差保留-&gt; 数值调到跟高斯模糊差不多即可； 混合模式改为线性光/点光； 3、修改 对低频进行修改： 选定暗斑区域，对区域选区，然后高斯模糊； 调整曲线; 用Portraiture插件对低频处理同理； 4、液化，人脸识别处理； 人物精修 - 女痘印、皱纹、暗斑(亮度问题) 法一 1、修补工具、污点工具处理； 2、黑白颜色调出，曲线调整图层调整使得对比明显，让痘痘显现出来，如果还不清楚，再复制一份曲线调整；把这三个打组； 3、新建空白图层，填充50%灰； 然后用画笔工具，降低流量和平滑， 前景白背景黑，在灰图层上进行精修，就是把黑色的斑点点白； 法二：双曲线 把亮曲线亮度调高，暗曲线的亮度调低，然后两个都填充黑色(两个图层不可见) 此时可以打开观察后图层组，如果把暗的地方变亮，就在亮图层上对暗的地方进行画笔涂抹；相当于把不可见的那里删除，让他变亮到开始亮曲线的程度； 把亮的地方变暗同理； 调整肤色可选颜色 黄色 降低黄色； 调整红色，红色降低，红色对立面青色增加； 给人物加影子/阴影1、ctrl + j 复制图层； 2、锁定透明像素； 3、alt + del 填充黑色 然后解锁； 4、ctrl + T 把影子往下压，然后垂直翻转，斜切到合适位置； 5、调整透明度或者调整混合选项； 嘴唇上色口红1、选区 羽化5像素左右 建立图层； 2、填充红色 3、混合模式更改为正片叠底 4、调整混合选项 按住ait+左键 调整 五、调色相关问题日系风格 滤镜-&gt;Camera滤镜 太黑了 =&gt; 曝光不够，加曝光，黑色，阴影； 调整对比度、饱和度等； 添加一些光线 =&gt; 新建图层 拿画笔点个白色的 然后放大 调整位置； 小清新 camera滤镜调整 HSL调整 饱和度：调整色彩浓度； 再调整下曲线，配上文字； Add：相关功能和选项介绍混合模式正片叠底正片叠底是 ps 中的一种混合模式，存在于颜色混合模式、通道混合模式、图层混合模式的变暗模式组中，是用户使用频率较高的一种变暗模式，使用“正片叠底” 混合模式时一般不会产生色阶溢出，当调换基色和混合色的位置，结果色相同。 调节颜色可选颜色拉低那个颜色就是将哪个颜色减弱； 注意看是对整个图像调色 还是对下一图层调色 设定好； Add：快捷键填充相关D 恢复前景背景黑白色 X 切换背景色 SHIFT + F5 填充 图层蒙版下： ctrl + delete 快速填充背景色； alt + delete 快速填充前景色 选区相关ctrl + j 快速创建选区； ctrl + 左键图层 选择图层所在选区； ctrl + H 隐藏选区； 变换相关ctrl + T 自由变换； 图层相关ctrl + 左键 选择改图层 ctrl + shift + alt + e 盖印图层，把下面所有操作合并在这个图层上； Add：待解决的问题滤镜等8BF工具不被兼容问题","categories":[{"name":"Software","slug":"Software","permalink":"http://tacoyu23.github.io/categories/Software/"}],"tags":[{"name":"PS","slug":"PS","permalink":"http://tacoyu23.github.io/tags/PS/"}]},{"title":"计算机方向及导师选择有感","slug":"计算机方向及导师选择有感","date":"2020-06-29T11:03:15.000Z","updated":"2020-06-30T01:55:11.444Z","comments":true,"path":"2020/06/29/计算机方向及导师选择有感/","link":"","permalink":"http://tacoyu23.github.io/2020/06/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%B9%E5%90%91%E5%8F%8A%E5%AF%BC%E5%B8%88%E9%80%89%E6%8B%A9%E6%9C%89%E6%84%9F/","excerpt":"","text":"​ 正常的话，初试成绩出来后就要联系并确定导师，拟录取后得到导师指点，适应研究生生活；但由于一些阻碍（前几个老师名额都满了，后两个老师的名额没确定下来，暂时无法答复我），导师和方向的问题迟迟没有解决，也是我一直打着等老师回复的幌子拖着这个事。 ​ 索性今天就把方向给定了，根据方向去联系导师，本来导师又多，我也不认识，学长学姐也没有参考性的建议，只能排除一些雷硬冲了； ​ 就我而言，喜欢一些有挑战的东西，但常常因为不够自信而不去尝试，这次就冲一把；搜了一些资料，也看了一些论坛帖子，对以下几个方向有了一些理解： ​ 人工智能/机器学习/深度学习：存在着分支关系的这三个方向，需要很好的数学功底，算法功底；读研期间处理模型的时候，需要往复的调参数，越熟练调得越快；而数学到了一定的高度后，就是靠天赋了；所以，这是一个极具有挑战的方向； 毕业后，工作一般是算法岗位、算法工程师，薪资待遇好；纯算法方向（对模型创新）比较吃学历、吃赛奖、吃顶会，工程方向（将现有模型变成落地项目）的话门槛要求相对低点； 其中的自然语言处理(NLP)和计算机视觉(CV)属于比较火热的方向，但CV由于人数多、落地少，NLP相对来说比较受青睐，但目前基本就大厂设了，进大厂难，小厂如果有的话，则进去相对容易一些，在以后的话应该有一个好的发展； 在我看来，智能推荐的领域应该比NLP的宽，并且感觉覆盖面更广一些，不知道就业形势会不会好点； ​ 大数据：大数据的方向大体有开发和分析两种，主要以java为主吧，python也有；大数据薪资也算可以，就业不错，应该算是主流方向吧； ​ 开发岗位：这个不算是研究方向，但是就业的一个很好的指南针；学好Java，步入开发岗位，岗位多，薪资过得去，避坑机器学习，也是大多数程序员的选择吧； 所以，读研期间就以优先NLP/推荐系统，然后机器学习/深度学习，其次大数据相关方向吧，毕竟很多东西都没真正接触过，也不知道自己真正喜欢什么，想要什么；课后就自己学学java开发，凡事留条后路； 最近国家还投了2000亿在电子产业上，估计通信电子行业在几年内会持续上升吧；","categories":[{"name":"Privacy","slug":"Privacy","permalink":"http://tacoyu23.github.io/categories/Privacy/"}],"tags":[{"name":"记录","slug":"记录","permalink":"http://tacoyu23.github.io/tags/%E8%AE%B0%E5%BD%95/"}]},{"title":"C++面试题","slug":"C++面试题","date":"2020-06-29T03:50:22.000Z","updated":"2020-06-29T07:30:28.651Z","comments":true,"path":"2020/06/29/C++面试题/","link":"","permalink":"http://tacoyu23.github.io/2020/06/29/C++%E9%9D%A2%E8%AF%95%E9%A2%98/","excerpt":"","text":"1. C++和C的区别1）在设计思想上： C++是面向对象的语言，而C是面向过程的结构化编程语言； 2）在内容方面： C++是C的超集，即C是C++的子集，C++兼容C； C++引入类、封装、隐藏、继承、多态等特性；引入STL标准模板库等； C++提供引用&amp;机制，降低使用指针的复杂度； C++提供内联函数inline； 3）在语法方面： C++中new和delete是对内存分配的运算符，取代了c的malloc和free； C++中用控制标准输入输出的iostream类库代替了标准C中的stdio函数库； C++中的try/catch/throw异常处理机制取代了C中的setjmp()和longjmp()； 强制类型转换，C++提供两种两种格式，而C只有第一种； 123float el = 123.233;int i = (int) el; //第一种 int j = int (el);//第二种 C++允许设置函数默认参数，而C不允许； C++允许对函数进行重载(两个同名函数，若它们参数类型不一致or参数个数不同，则为两个不同的函数)，而C不允许； C++允许在程序任何地方定义变量，而C只允许在函数开头部分定义； 详解可参考文章：C++和C的区别 2. static的作用1、全局静态变量 存放于静态存储区； 在整个程序运行期间都存在； 未被初始化时自动初始化为0； 作用域：从定义之处开始到文件结尾； 2、局部静态变量 仅作用域与全局静态变量不同：局部静态变量在定义它的函数or语句块结束时，作用域便结束，此时不可访问，当再次调用函数时，即可访问且值不变； 3、静态函数 函数默认extern，即可以被其他文件可用； 而静态函数只能在声明它的文件中可见，不能被其他文件所引用； 4、类的静态成员变量 类的静态成员可实现多个对象之间的数据共享，只存储于溢出，共该类的所有对象共用； 5、类的静态成员函数 调用静态成员函数不需要用对象名（但可以用），且静态成员函数中不能直接引用类中的非静态成员，因为它不知道这个成员为那个对象所有； 调用静态成员函数使用如下格式：&lt;类名&gt;::&lt;静态成员函数名&gt;(&lt;参数表&gt;); 3. C++中的四种cast转换C++中四种类型转换是：static_cast, dynamic_cast, const_cast, reinterpret_cast； 1、const_cast 用于将const变量转为非const； 2、static_cast 用于各种隐式转换，比如非const转const，void*转指针等, static_cast能用于多态向上转化，如果向下转能成功但是不安全，结果未知； 3、dynamic_cast 用于动态类型转换。只能用于含有虚函数的类，用于类层次间的向上和向下转化。只能转指针或引用。向下转化时，如果是非法的对于指针返回NULL，对于引用抛异常。 向上转换：指的是子类向基类的转换； 向下转换：指的是基类向子类的转换； 它通过判断在执行到该语句的时候变量的运行时类型和要转换的类型是否相同来判断是否能够进行向下转换； 4、reinterpret_cast 几乎什么都可以转，比如将int转指针，可能会出问题，尽量少用； 4. C++/C中指针和引用的区别1、指针有自己的一块空间，而引用只是别名； 12345short a=1;short *p=&amp;a;short &amp;b=a;cout&lt;&lt;sizeof(p);//输出4cout&lt;&lt;sizeof(b);//输出2 2、指针可被初始化为NULL，而引用必须被初始化且必须是一个已有对象的引用； 3、可以有const指针，但是没有const引用； 4、指针可以在使用中指向其他对象，而引用一旦初始化，便不能再指向别的对象； 5、指针可以有多级(**p)，而引用只有一级； 6、指针和引用使用++运算符的意义不同；如若变量i是int类型，p指向i，b是i的引用；那么++p表示p的值等于 i 的地址加四个地址单位后的地址；而++b的值是i+1； 7、如果返回动态内存分配的对象或者内存，必须使用指针，引用可能引起内存泄露； 5. 什么是野指针野指针就是指向一个已删除的对象或者未申请访问受限内存区域的指针； 6. 为什么对于会被继承的类，其析构函数必须是虚函数？将可能会被继承的父类的析构函数设置为虚函数，可以保证当我们new一个子类，然后使用基类指针指向该子类对象，释放该子类对象的空间时，可以释放掉子类的空间，防止内存泄漏。 C++默认的析构函数不是虚函数是因为虚函数需要额外的虚函数表和虚表指针，占用额外的内存。而对于不会被继承的类来说，其析构函数如果是虚函数，就会浪费内存。因此C++默认的析构函数不是虚函数，而是只有当需要当作父类时，设置为虚函数。 详解可参考：继承-虚析构函数 7. 函数指针1、定义 函数指针是指向函数的指针变量； 函数指针本身首先是一个指针变量，该指针变量指向一个具体的函数。这正如用指针变量可指向整型变量、字符型、数组一样，这里是指向函数； C在编译时，每一个函数都有一个入口地址，该入口地址就是函数指针所指向的地址；有了指向函数的指针变量后，可用该指针变量调用函数，就如同用指针变量可引用其他类型变量一样，在这些概念上是大体一致的； 2、用途： 调用函数和做函数的参数，比如回调函数。 3、示例： 12345678910int fun(char c) //函数fun&#123; return c;&#125;int main()&#123; int (*pf)(char c); //定义函数指针pf pf=fun; //将函数指针pf指向函数fun cout&lt;&lt;pf('a'); //输出97&#125; 8. C++中析构函数的作用析构函数与构造函数对应，当对象结束其生命周期，如对象所在的函数已调用完毕时，系统会自动执行析构函数。 析构函数名也应与类名相同，只是在函数名前面加一个位取反符，例如stud( )，以区别于构造函数。它不能带任何参数，也没有返回值（包括void类型）。只能有一个析构函数，不能重载； 如果用户没有编写析构函数，编译系统会自动生成一个缺省的析构函数（即使自定义了析构函数，编译器也总是会为我们合成一个析构函数，并且如果自定义了析构函数，编译器在执行时会先调用自定义的析构函数再调用合成的析构函数），它也不进行任何操作。所以许多简单的类中没有用显式的析构函数； 如果一个类中有指针，且在使用的过程中动态的申请了内存，那么最好显示构造析构函数在销毁类之前，释放掉申请的内存空间，避免内存泄漏； 类析构顺序：1）派生类本身的析构函数；2）对象成员析构函数；3）基类析构函数。 9. 静态函数和虚函数的区别静态函数在编译的时候就已经确定运行时机，虚函数在运行的时候动态绑定。虚函数因为用了虚函数表机制，调用的时候会增加一次内存开销； 10. 重载和覆盖重载：两个函数名相同，但是参数列表不同（个数，类型），返回值类型没有要求，在同一作用域中； 重写/覆盖：子类继承了父类，父类中的函数是虚函数，在子类中重新定义了这个虚函数，这种情况是重写; 11. 对虚函数和多态的理解多态的实现主要分为静态多态和动态多态，静态多态主要是重载，在编译的时候就已经确定；动态多态是用虚函数机制实现的，在运行期间动态绑定。举个例子：一个父类类型的指针指向一个子类对象时候，使用父类的指针去调用子类中重写了的父类中的虚函数的时候，会调用子类重写过后的函数，在父类中声明为加了virtual关键字的函数，在子类中重写时候不需要加virtual也是虚函数。虚函数的实现：在有虚函数的类中，类的最开始部分是一个虚函数表的指针，这个指针指向一个虚函数表，表中放了虚函数的地址，实际的虚函数在代码段(.text)中。当子类继承了父类的时候也会继承其虚函数表，当子类重写父类中虚函数时候，会将其继承到的虚函数表中的地址替换为重新写的函数地址。使用了虚函数，会增加访问内存开销，降低效率。 12. 写个函数在main函数执行前先运行C++ 的全局对象的构造函数会在 main 函数之前先运行； 其实在 c 语言里面很早就有了，在 gcc 中可以使用attribute关键字指定如下（在编译器编译的时候就绝决定了） 详解可参考文章：如何再main()执行之前先运行其他函数 13. const char *arr=”123”; char *brr=”123”;char crr[]=”123”;的区别首先， “123”永远都是保存在常量区，要么指针指向常量区”123”，要么数组复制“123”到栈区； 1）const char *arr=”123”; “123”保存在常量区，const本来是修饰arr指向的值不能通过arr去修改，但是字符串“123”在常量区，本来就不能改变，所以加不加const效果都一样; 2） char *brr=”123”; “123”保存在常量区,brr和arr指向的是同一个位置，同样不能通过brr去修改”123”的值 3）char crr[] = “123”; 这里“123”相当于一个字符数组，”123”从常量区复制到栈区，可以通过crr去修改； 14. C语言是怎么进行函数调用的？每一个函数调用都会分配函数栈，在栈内进行函数执行过程； 调用前，先把返回地址压栈，然后把当前函数的ebp指针压栈。然后ebp改为当前esp值，此时ebp=esp，表示初始的子函数帧栈大小为0，然后移动帧指针（修改ebp寄存器）与栈指针（修改esp寄存器），为swap函数创建一个栈帧结构； 详解可参考：C语言函数调用过程 15. 说一声fork,wait,exec函数父进程产生子进程使用fork()拷贝出来一个父进程的副本，此时只拷贝了父进程的页表，两个进程都读同一块内存，当有进程写的时候使用写时拷贝机制(可参考：操作系统面试题汇总中的fork()与vfork())分配内存，exec()函数可以加载一个elf文件去替换父进程，从此父进程和子进程就可以运行不同的程序了。fork()给父进程返回子进程的PID，给子进程返回0； 调用了wait()的父进程将会发生阻塞，直到有子进程状态改变,执行成功返回0，错误返回-1； exec()执行成功则子进程从新的程序开始运行，无返回值，执行失败返回-1； 16. 说一下C++中类成员的访问权限C++通过 public、protected、private 三个关键字来控制成员变量和成员函数的访问权限，它们分别表示公有的、受保护的、私有的，被称为成员访问限定符； 在类的内部（定义类的代码内部），无论成员被声明为 public、protected 还是 private，都是可以互相访问的，没有访问权限的限制； 在类的外部（定义类的代码之外），只能通过对象访问成员，并且通过对象只能访问 public 属性的成员，不能访问 private、protected 属性的成员； 17. C++源文件从文本到可执行文件经历的过程对于C++源文件，从文本到可执行文件一般需要四个过程： 1、预处理阶段：对源代码文件中文件包含关系（头文件）、预编译语句（宏定义）进行分析和替换，生成预编译文件; 2、编译阶段：将经过预处理后的预编译文件转换成特定汇编代码，生成汇编文件; 3、汇编阶段：将编译阶段生成的汇编文件转化成机器码，生成可重定位目标文件; 4、链接阶段：将多个目标文件及所需要的库连接成最终的可执行目标文件; 18. include头文件的顺序以及双引号””和尖括号&lt;&gt;的区别双引号和尖括号的区别：编译器预处理阶段查找头文件的路径不一样； 对于使用双引号””包含的头文件，查找头文件路径先从当前头文件目录开始，若没找到再从编译器设置的头文件路径开始查找； 而使用尖括号&lt;&gt;包含头文件，查找头文件路径直接从编译器设置的开始 19. malloc的原理Malloc函数用于动态分配内存。为了减少内存碎片和系统调用的开销，malloc其采用内存池的方式，先申请大块内存作为堆区，然后将堆区分为多个内存块，以块作为内存管理的基本单位；当用户申请内存时，直接从堆区分配一块合适的空闲块； Malloc采用隐式链表结构将堆区分成连续的、大小不一的块，包含已分配块和未分配块；同时malloc采用显示链表结构来管理所有的空闲块，即使用一个双向链表将空闲块连接起来，每一个空闲块记录了一个连续的、未分配的地址； 当进行内存分配时，Malloc会通过隐式链表遍历所有的空闲块，选择满足要求的块进行分配；当进行内存合并时，malloc采用边界标记法，根据每个块的前后块是否已经分配来决定是否进行块合并； Malloc在申请内存时，一般会通过brk或者mmap系统调用进行申请；其中当申请内存小于128K时，会使用系统函数brk在堆区中分配；而当申请内存大于128K时，会使用系统函数mmap ( mmap将一个文件或者其它对象映射进内存 ) 在映射区分配； 20. C++的内存管理是怎样的在C++中，虚拟内存分为代码段、数据段、BSS段、堆区、文件映射区以及栈区六部分。 1、代码段:包括只读存储区和文本区，其中只读存储区存储字符串常量，文本区存储程序的机器代码； 2、数据段：存储程序中已初始化的全局变量和静态变量； 3、BSS 段：存储未初始化的全局变量和静态变量（局部+全局），以及所有被初始化为0的全局变量和静态变量； 4、堆区：调用new/malloc函数时在堆区动态分配内存，同时需要调用delete/free来手动释放申请的内存； 5、映射区:存储动态链接库以及调用mmap函数进行的文件映射； 6、栈：使用栈空间存储函数的返回地址、参数、局部变量、返回值；","categories":[{"name":"C&&C++","slug":"C-C","permalink":"http://tacoyu23.github.io/categories/C-C/"}],"tags":[{"name":"C&&C++","slug":"C-C","permalink":"http://tacoyu23.github.io/tags/C-C/"},{"name":"面试","slug":"面试","permalink":"http://tacoyu23.github.io/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"tacoyu23的建站史","slug":"tacoyu的建站史","date":"2020-06-28T12:20:12.000Z","updated":"2020-06-30T00:13:14.991Z","comments":true,"path":"2020/06/28/tacoyu的建站史/","link":"","permalink":"http://tacoyu23.github.io/2020/06/28/tacoyu%E7%9A%84%E5%BB%BA%E7%AB%99%E5%8F%B2/","excerpt":"","text":"2020/6/27 初学Github 因为在线试衣系统以及以后做项目的需要，花了将近六个小时熟悉传说中的Github； 对自己的Github进行修改，并创建 .github.io博客； 2020/6/28 博客初成 在CSDN上找资料，学习使用Git命令以及Hexo； Github上使用Hexo配置初始的next主题； 使用next第四个主题，调暗模式，把开始的两篇文章传上去； 打开并正确使用标签、分类，设置图像、链接以及打赏功能； 2020/6/29 博客基本完善 增加了一些新功能，比如动态背景、加入fork Github图标(虽然这个基本用不着，哈哈)； 增加了评论啊、统计等功能，不过还是有两个没配置成功，新版和旧版的区别还是挺大的，网上大多是旧版的教程； 这个熟能生巧，慢慢摸索着前进吧！","categories":[{"name":"Privacy","slug":"Privacy","permalink":"http://tacoyu23.github.io/categories/Privacy/"}],"tags":[{"name":"记录","slug":"记录","permalink":"http://tacoyu23.github.io/tags/%E8%AE%B0%E5%BD%95/"}]},{"title":"Hexo搭建Next进行美化详解","slug":"Hexo搭建Next进行美化详解","date":"2020-06-28T09:24:22.000Z","updated":"2020-06-29T14:46:41.249Z","comments":true,"path":"2020/06/28/Hexo搭建Next进行美化详解/","link":"","permalink":"http://tacoyu23.github.io/2020/06/28/Hexo%E6%90%AD%E5%BB%BANext%E8%BF%9B%E8%A1%8C%E7%BE%8E%E5%8C%96%E8%AF%A6%E8%A7%A3/","excerpt":"","text":"前提是已经安装Node.js 、Git 和Hexo以及注册Github账户； 安装流程可见：使用 Github Pages 和 Hexo 搭建自己的独立博客【超级详细的小白教程】 1、Next主题的启用在Hexo下面的themes中，右键 选择Git base here 复制这行代码 1git clone https:&#x2F;&#x2F;github.com&#x2F;theme-next&#x2F;hexo-theme-next themes&#x2F;next 等待完成后，打开Hexo的这个文件 找到 theme 把 theme 后面的 landscape 改成 next 即可； 然后在Hexo文件夹中 右键 Git base here 输入以下命令，启动本地预览 出现下面两个INFO表示成功，在浏览器中进入http://localhost:4000进行查看； 查看后需要关闭的话 则要在命令行输入Ctrl + c 结束； 这样 next主题就启动成功了； 2、更改Next主题为中文同样打开Hexo的_config.yml文件，这是配置文件 找到Site 下的 language ，改成zh-CN即可 然后在命令行可开启本地预览查看； 3、添加标签页和分类页打开文件 找到meau 然后把tags 和 categories前面的#号去掉，然后保存 然后本地预览 可发现 但是点进去后不会显示，因为你没有创建标签页和分类页 4、正确打开标签页和分类页进入文件夹 启动git命令行 输入命令： hexo n page tags 就会在source中创建tags文件夹，并在里面创建index.md文件，表示已经可以使用； 然后打开index.md 进行修改 注意冒号后面必须有一个空格； 对于分类页同理，hexo n page categories 然后修改的时候type: “categories”； 5、主题样式的更改在next的主题配置文件里面 找到Schemes ，发现有四种主题： 要用哪个就把哪个前面的#去掉，其它的三个加上# (#代表注释)； Muse： Mist： pisces： Gemini： 改完保存，本地预览即可； 6、更改图像在next配置文件中，找到 默认就是这个样子 更改的话只需改url后面的网站，网站的内容就是你将用的图像； 7、更改标题、作者和链接在Hexo的配置文件下，找到 然后对这些进行修改 保存即可； 8、启动侧边栏社交链接打开next的配置文件中，找到social links 对后面的链接进行修改 然后去掉# 即可显示； 注意 #号是注释作用，只有去掉#号才能生效； 9、启用友情链接在next的配置文件中 找到 links： 名称: url 显示出来是这样： 上面那个title：Links也是可以改的，比如我改成友情链接，显示是这样： 10、新建一篇文章Hexo文件中打开命令行； 12输入：hexo n 文件名//在Hexo\\source\\_posts下建立对应.md形式的文件 进入本地预览； 11、markdown基本使用创建一个测试文档 输入— 然后回车，头部格式就出来了，接着输入该文档的title、tag、categories、description等待；就是下面这样： 插入链接 [ 链接标题 ]（链接url） 插入图片/文件 ！[ 文件标题 ]（文件/图片url） 斜体两个*号中间的内容是斜体 字体是斜的 粗体两个**号之间的是粗体 字体是粗的 插入代码块单行：//单行代码 代码块： 123// 代码块x// xx// xx 引用输入一个&gt; 随后输入的内容就是引用； 分割线连续三个 - 或者 三个 *，然后回车 12、开启打赏功能next里面的配置文件中，找到Reward 然后enable 和 animation 设置为true 并添加个人的微信收款码和支付宝收款码； 放到 next/source/images 中； 13、开启订阅公众号在next的配置文件中找到subscribe 可通过以下四个方式订阅，也可添加； 14、设置头像为圆形可旋转需要对这个文件进行修改； 按下图修改 然后直接打开next的配置文件，找到avatar 把rounded和rotated设置为true； rounded是说要不要把图像设置为圆形； rotated是说要不要让它转，如果要修改转的一些详细信息，就要到之前说的那个siderbar-author那个文件去修改； 15、首页文章设置阅读全文next的配置文件下，找到这里 把这两个都设置为true，默认应该是true； 然后有两种方法： 法1： 在博客的头部 添加description，然后在后面输入你的描述，那么在你的博客中，这篇文章就只会显示你写的描述，剩下的由阅读全文这个按钮代替； 法2： 在文章中输入这一行代码，那么默认这行代码之前的部分为描述，之后的部分在阅读全文中显示； 16、添加动态背景今天在学习使用Hexo修改next的背景时，发现： 这几个东西我无论设置哪些个为true，都调不出动态背景；随后开始在网上搜，发现大多都是针对老版本的NexT调动态背景或者canvas_nest的解决方法，不过也受到一些启发，这里就用新版本的演示一下： 1、首先看这里Dependencies: https://github.com/theme-next/theme-next-three表示这三个动态背景依赖于git克隆(clone)才能使用； 2、然后在next文件下打开Git命令行界面，准备clone输入命令后，等待下载；下载后就会有一个这样的文件出现在next文件夹中 只需要将此文件重命名为three，然后剪贴到next/source/lib文件下下面即可； 3、依赖包已经克隆了，之后就只用改之前那几个参数就能调选择你喜欢的动态背景了；调完后，hexo s 本地预览下； 如果你对canva_nest有着独特的喜爱，那就clone它的依赖包放入next/source/lib中，然后千万记得，在next的_config.yml文件中加上这样两句话： ​ 想打开时，把enable置为true即可，这个与上面动态背景总开关没联系！等于说你可以上面设为false，canvas_nest设置为true，它一样可以用这个动态背景！ 17、给博客添加fork Github进入这个网站GitHub Corners 选一个心仪的图标，然后复制它旁边框框里的内容； 打开文件 搜索headband，在它下面插入这段复制的内容； 然后把 href 那里的网址改成自己github的地址！！！ 保存，再本地预览即可看见； 18、修改文章内链接样式打开next内部的这个文件： 在此文件的最后面加上代码块： 1234567.post-body p a&#123; color: #345; border-bottom: none; &amp;:hover&#123; color: white; &#125;&#125; 19、怎样修改文章底部#标签式样打开这个文件： 找到这个位置 在 rel=”tag”&gt; 后插入 图标可以在Font awesome中找自己喜欢的，替换就行； r然后修改next配置文件： 20、增加Valine评论功能注册LeanCloud网站 实名认证 验证邮箱 然后创建应用，进入应用设置 进入之后，复制应用Keys下的AppID和Appkey； 在next的配置文件中找到如图valine位置 更改为 将自己的appid和appkey复制过去； 保存； 21、增加搜索功能next的配置文件中，置local_search为true 22、增加不蒜子统计功能next的配置文件中找到这个并置为true； 23、内容分享服务（未完成） 24、增加加载效果 置为true； 然后在next下，打开git命令行，输入 git clone https://github.com/theme-next/theme-next-pace 等待依赖包下载成功即可； 25、增加点击爆炸效果(未完成)26、隐藏底部 强力驱动 置为false就行； 27、增加字数统计和阅读时长功能clone wordcount包：hexo文件夹内打开git命令行，输入命令npm i --save hexo-wordcount 如果根目录下的package.json文件有以下信息，则表示安装成； 然后打开此文件 在这个位置处插入下面代码块： 1234567 &lt;span title=\"&#123;&#123; __('post.wordcount') &#125;&#125;\"&gt; 字数统计 : &#123;&#123; wordcount(post.content) &#125;&#125; 字 | &lt;/span&gt; &lt;span title=\"&#123;&#123; __('post.min2read') &#125;&#125;\"&gt; 阅读时长 ≈ &#123;&#123; min2read(post.content) &#125;&#125; 分钟&lt;/span&gt; 然后在next的配置文件中 下面三个置为true； 然后就设置完成了 这是效果图： 在想办法，看如何把它放在标题下面；","categories":[{"name":"Github","slug":"Github","permalink":"http://tacoyu23.github.io/categories/Github/"}],"tags":[{"name":"Github","slug":"Github","permalink":"http://tacoyu23.github.io/tags/Github/"},{"name":"Hexo","slug":"Hexo","permalink":"http://tacoyu23.github.io/tags/Hexo/"},{"name":"Next","slug":"Next","permalink":"http://tacoyu23.github.io/tags/Next/"}]},{"title":"Github的介绍与使用","slug":"Github介绍与使用","date":"2020-06-27T19:20:12.000Z","updated":"2020-06-29T12:39:15.578Z","comments":true,"path":"2020/06/28/Github介绍与使用/","link":"","permalink":"http://tacoyu23.github.io/2020/06/28/Github%E4%BB%8B%E7%BB%8D%E4%B8%8E%E4%BD%BF%E7%94%A8/","excerpt":"","text":"一、绪论1.1 目的借助github托管项目代码 GitHub是全球最大的社交编程及代码托管网站； 可以托管各种git库，并提供一个web界面； 1.2 基本概念仓库(Repository)仓库即你的项目，在github上开源一个项目，就必须新建一个Repository； 收藏(Star)仓库主页star按钮，意思为收藏该项目的人数，一个项目有100个star都算很不容易了； 复制项目(Fork) 建立一份和别人一模一样的仓库，独立存在； 发起请求(Pull Request)若李四在这个仓库里进行修改，随后李四可以在自己仓库中点击 Pull Request 来请求张三合并仓库(待张三查看后确认合并后才执行)； 关注(Watch)关注某人或者某个项目，一旦项目有任何更新，则会收到提醒； 事务卡片(Issue)发现代码BUG，但是目前没有成型代码，需要讨论时使用； 1.3 注册 现在不管是私有还是公开都是免费的了！！！ 1.4 Notice1、因为 github 在国外服务器，所以访问速度较慢或者无法访问，需要翻墙(软件: Shadowsocks)； 2、私有仓库只能自己和指定的朋友才有权限操作； 二、仓库Repository2.1 创建仓库 2.2 仓库介绍 2.3 仓库管理创建文件 修改文件 +号代表新增的，-号代表删除的； 删除文件 上传文件 搜索文件 或者快捷键T 下载/检出项目 2.4 github Issues出现问题时，讨论使用； A在看B的仓库时，发现其中存在的问题，然后新建一个Issue，然后B的主页就会显示此Issue； 先谢谢 有问题就提 然后觉得没问题了就可以close 双方都可以close； 2.5 开源项目贡献流程1、新建Issue 提交使用问题或者建议、想法； 2、Pull Request 1）fork项目； 2）修改自己仓库的项目代码； 3）新建 pull Request； 4）等待作者操作审核，合并； 三、Git安装和使用3.1 目的通过 git 管理 github 托管项目代码 3.2 下载安装官网下载请点击 不过官网下载太慢了，给出一个网盘链接, 提取码：oiiy 一直next； 鼠标右击桌面出现两个Git 即为安装成功； 3.3 Git基础设置1、设置用户名git config –global user.name ‘用户名’ 2、设置用户名邮箱git config –global user.email ‘xxxxxx.com ‘ 初始化一次就不用初始化了！！！ 3.4 初始化Git仓库1、创建文件夹 2、在文件内初始化git（创建git仓库）选择目录命令：cd test 初始化：git init 创建了一个隐藏的文件 3.5 工作区域工作区 working Directory添加、编辑、修改文件等动作 仓库 Git Repository Git最终确定的文件保存到仓库，成为一个新的版本，并对他人可见； 暂存区暂存已经修改的文件，最后统一提交到git仓库； 3.6 常见命令cd 文件夹进入当前文件夹目录下 git status获得仓库状态 git add 文件名提交工作区的文件到暂存区 git commit -m ’提交描述‘提交暂存区的文件到git仓库 ls显示文件清单 nano 文件名对该文件内容进行修改； rm -rf 文件名删除该文件 git put提交本地仓库到git云仓库 3.7 常用操作1、向仓库提交文件1）创建文件 2）添加到暂存区 3）将文件从暂存区提交到仓库 2、修改仓库文件1）修改文件 notice： vi修改文件不太好用，建议nano修改； 2）添加到暂存区 ​ 3）提交到git仓库 3、删除仓库文件1）直接删除文件 rm -rf al.php 2）提交到暂存区 3）提交到仓库 四、 Git远程管理仓库4.1 目的作用：备份，实现代码共享集中化管理； 4.2 将本地仓库同步到git远程仓库 1、先fork到本地目的：将远程仓库（GitHub对应项目）复制到本地 代码：git clone 仓库地址 仓库地址怎么来： 成功复制到本地后： 与GitHub上的一致； 2、建立 文件，然后 提交到本地仓库后完成后提示以下内容： 3、键入 git push 完成云同步会提示登陆 github 完成操作； 登陆后依旧会要你 输入用户名和密码 全部输入后 会出现以下界面： 同时查看git仓库 发现已经提交上了 4.3 解决git push错误 config文件通过记事本打开，按图片内容修改即可； 五、Github Pages搭建个人网站5.1 访问 https://户名.github.io 5.2 搭建步骤1、创建个人站点 -&gt; 新建仓库 (仓库名必须是[ 用户名.github.io ] ) 2、在仓库下新建 index.html 的文件即可； 新建index.html文件，并输入内容 随后登陆网站可查看； Notice： 1、github pages 仅支持静态网页； 2、仓库里面只能是.html文件； 5.3 Projet Pages 项目站点https://用户名.github.io/仓库名 // 新版github好像没有； 搭建步骤1）进入项目主页，点击settings； 2）在settings里面点击choose a theme，来自动生成主题； 3）生成网页 六、博客主题及美化6.1 博客主题fork及使用博客主题的使用推荐阅读文章： Hexo博客优化之Next主题美化 使用 Github Pages 和 Hexo 搭建自己的独立博客【超级详细的小白教程】 6.2 博客主题美化博客美化推荐阅读文章： 这篇文章的有些修改适用，有些不适用Hexo框架下用NexT(v7.0+)主题美化博客 使用 Github Pages 和 Hexo 搭建自己的独立博客【超级详细的小白教程】 Hexo-Next 主题博客个性化配置超详细，超全面(两万字)","categories":[{"name":"Github","slug":"Github","permalink":"http://tacoyu23.github.io/categories/Github/"}],"tags":[]}],"categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://tacoyu23.github.io/categories/Algorithm/"},{"name":"课外读物","slug":"课外读物","permalink":"http://tacoyu23.github.io/categories/%E8%AF%BE%E5%A4%96%E8%AF%BB%E7%89%A9/"},{"name":"Software","slug":"Software","permalink":"http://tacoyu23.github.io/categories/Software/"},{"name":"Privacy","slug":"Privacy","permalink":"http://tacoyu23.github.io/categories/Privacy/"},{"name":"C&&C++","slug":"C-C","permalink":"http://tacoyu23.github.io/categories/C-C/"},{"name":"Github","slug":"Github","permalink":"http://tacoyu23.github.io/categories/Github/"}],"tags":[{"name":"Bit","slug":"Bit","permalink":"http://tacoyu23.github.io/tags/Bit/"},{"name":"Sort","slug":"Sort","permalink":"http://tacoyu23.github.io/tags/Sort/"},{"name":"数组","slug":"数组","permalink":"http://tacoyu23.github.io/tags/%E6%95%B0%E7%BB%84/"},{"name":"递归","slug":"递归","permalink":"http://tacoyu23.github.io/tags/%E9%80%92%E5%BD%92/"},{"name":"心理学","slug":"心理学","permalink":"http://tacoyu23.github.io/tags/%E5%BF%83%E7%90%86%E5%AD%A6/"},{"name":"PS","slug":"PS","permalink":"http://tacoyu23.github.io/tags/PS/"},{"name":"记录","slug":"记录","permalink":"http://tacoyu23.github.io/tags/%E8%AE%B0%E5%BD%95/"},{"name":"C&&C++","slug":"C-C","permalink":"http://tacoyu23.github.io/tags/C-C/"},{"name":"面试","slug":"面试","permalink":"http://tacoyu23.github.io/tags/%E9%9D%A2%E8%AF%95/"},{"name":"Github","slug":"Github","permalink":"http://tacoyu23.github.io/tags/Github/"},{"name":"Hexo","slug":"Hexo","permalink":"http://tacoyu23.github.io/tags/Hexo/"},{"name":"Next","slug":"Next","permalink":"http://tacoyu23.github.io/tags/Next/"}]}